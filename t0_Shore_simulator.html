<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>T0-Quantensimulator Interface / T0 Quantum Simulator Interface</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 50%, #0f0f23 100%);
      color: #e0e0e0;
      min-height: 100vh;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(20, 20, 20, 0.95);
      border-radius: 15px;
      padding: 30px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      border: 1px solid #333;
    }
    h1 {
      color: #2c3e50;
      text-align: center;
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .subtitle {
      text-align: center;
      color: #7f8c8d;
      font-size: 1.2em;
      margin-bottom: 30px;
    }
    h2 {
      color: #3498db;
      border-left: 5px solid #3498db;
      padding-left: 15px;
      margin-top: 30px;
    }
    .control-panel {
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      color: white;
      padding: 25px;
      border-radius: 10px;
      margin: 20px 0;
      border-left: 5px solid #00bcd4;
      box-shadow: 0 10px 25px rgba(0,0,0,0.3);
    }
    .input-group {
      margin: 15px 0;
      display: flex;
      align-items: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    .input-group label {
      font-weight: bold;
      min-width: 120px;
    }
    .input-group input, .input-group select {
      padding: 10px;
      border: 2px solid #444;
      border-radius: 8px;
      font-size: 16px;
      flex: 1;
      min-width: 200px;
      background: #2a2a2a;
      color: #e0e0e0;
    }
    .input-group input:focus, .input-group select:focus {
      border-color: #00bcd4;
      outline: none;
      box-shadow: 0 0 10px rgba(0, 188, 212, 0.3);
    }
    .button-group {
      display: flex;
      gap: 15px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    .btn {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px;
      transition: all 0.3s ease;
      flex: 1;
      min-width: 150px;
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    .btn-primary {
      background: linear-gradient(135deg, #27ae60, #2ecc71);
    }
    .btn-secondary {
      background: linear-gradient(135deg, #f39c12, #e67e22);
    }
    .btn-warning {
      background: linear-gradient(135deg, #f39c12, #e67e22);
    }
    .btn-danger {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
    }
    .btn-critical {
      background: linear-gradient(135deg, #8e44ad, #732d91);
    }
    .btn-benchmark {
      background: linear-gradient(135deg, #546e7a, #37474f);
    }
    .btn-info {
      background: linear-gradient(135deg, #3498db, #2980b9);
    }
    .btn-optimize {
      background: linear-gradient(135deg, #9b59b6, #8e44ad);
    }
    .results-panel {
      background: #1a1a1a;
      border: 2px solid #333;
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
      font-family: 'Courier New', monospace;
      max-height: 600px;
      overflow-y: auto;
      color: #00ff41;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
    }
    .success {
      background: linear-gradient(135deg, #2dd4bf, #14b8a6);
      color: white;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .warning {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .info {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: white;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .statistics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    .stat-card {
      background: linear-gradient(135deg, #1e40af, #1d4ed8);
      color: white;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      border: 1px solid #374151;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .stat-value {
      font-size: 2em;
      font-weight: bold;
      margin: 10px 0;
    }
    .language-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      gap: 10px;
    }
    .lang-btn {
      background: linear-gradient(135deg, #4f46e5, #3730a3);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .lang-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }
    .lang-btn.active {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
    }
    .home-btn {
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 1000;
      background: linear-gradient(135deg, #059669, #047857);
      color: white;
      border: none;
      padding: 12px 18px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .home-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }
    .language-content {
      display: none;
    }
    .language-content.active {
      display: block;
    }
    .progress-bar {
      width: 100%;
      height: 20px;
      background: #374151;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
      border: 1px solid #4b5563;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #00d4ff, #0ea5e9);
      transition: width 0.3s ease;
      width: 0%;
    }
    .energy-field {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 2px;
      margin: 20px 0;
      padding: 10px;
      background: #111827;
      border-radius: 8px;
      border: 1px solid #374151;
    }
    .energy-cell {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: white;
      font-weight: bold;
      border: 1px solid #4b5563;
    }
    /* Neue Styles f√ºr √úberschriften */
    .function-header {
      background: linear-gradient(135deg, #1a202c, #2d3748);
      color: #e2e8f0;
      padding: 15px 20px;
      border-radius: 10px;
      margin: 20px 0 10px 0;
      border-left: 5px solid #4299e1;
      font-weight: bold;
      font-size: 18px;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .function-header.t0-shor {
      border-left-color: #48bb78;
      background: linear-gradient(135deg, #22543d, #2f855a);
    }
    .function-header.resources {
      border-left-color: #ed8936;
      background: linear-gradient(135deg, #7b341e, #c05621);
    }
    .function-header.energy-field {
      border-left-color: #4299e1;
      background: linear-gradient(135deg, #2a4365, #3182ce);
    }
    .function-header.optimization {
      border-left-color: #9f7aea;
      background: linear-gradient(135deg, #553c9a, #805ad5);
    }
    .function-header.tests {
      border-left-color: #f56565;
      background: linear-gradient(135deg, #742a2a, #e53e3e);
    }
    .function-header.benchmark {
      border-left-color: #4a5568;
      background: linear-gradient(135deg, #2d3748, #4a5568);
    }
    @media (max-width: 768px) {
      .container {
        padding: 15px;
      }
      h1 {
        font-size: 2em;
      }
      .input-group {
        flex-direction: column;
        align-items: stretch;
      }
      .button-group {
        flex-direction: column;
      }
      .language-toggle, .home-btn {
        position: relative;
        top: auto;
        right: auto;
        margin-bottom: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="language-toggle">
    <button class="lang-btn active" onclick="switchLanguage('de')">Deutsch</button>
    <button class="lang-btn" onclick="switchLanguage('en')">English</button>
  </div>
  
  <a href="https://jpascher.github.io/T0-Time-Mass-Duality/2/html/index.html" class="home-btn">
    üè† Zur Startseite / Home
  </a>

  <div class="container">
    <!-- German Content -->
    <div id="german-content" class="language-content active">
      <h1>üßÆ T0-Quantensimulator</h1>
      <div class="subtitle">Deterministische Quantenmechanik in Aktion</div>

      <div class="control-panel">
        <h2>üéõÔ∏è Simulator-Steuerung</h2>
        
        <div class="input-group">
          <label for="rsa-number-de">üî¢ RSA-Zahl:</label>
          <input type="number" id="rsa-number-de" value="15" min="3" max="1000000">
          <span>üí° Beispiele: 15, 21, 35, 77, 143, 10403</span>
        </div>

        <div class="input-group">
          <label for="xi-mode-de">üîß Œæ-Parameter:</label>
          <select id="xi-mode-de">
            <option value="natural">Nat√ºrlich (1√ó10‚Åª‚Åµ)</option>
            <option value="theoretical">Theoretisch (angepasst)</option>
            <option value="optimized">Optimiert (auto-tuning)</option>
            <option value="old_error_1e4">Test: 1√ó10‚Åª‚Å¥</option>
            <option value="old_error_133e4">Test: 1.33√ó10‚Åª‚Å¥</option>
          </select>
        </div>

        <div class="input-group">
          <label for="base-a-de">üéØ Basis (a):</label>
          <input type="number" id="base-a-de" value="" placeholder="Auto (optimal)">
          <span>üí° Leer = automatische Optimierung</span>
        </div>

        <div class="input-group">
          <label for="fallback-de">‚ö†Ô∏è Fallback:</label>
          <select id="fallback-de">
            <option value="false">Deaktiviert (Pure T0)</option>
            <option value="true">Aktiviert</option>
          </select>
        </div>

        <div class="button-group">
          <button class="btn btn-primary" onclick="runT0Shor('de')">üöÄ T0-Shor starten</button>
          <button class="btn btn-secondary" onclick="calculateT0Resources('de')">üßÆ T0-Ressourcen</button>
          <button class="btn btn-info" onclick="solveEnergyField('de')">üåä Energiefeld l√∂sen</button>
          <button class="btn btn-optimize" onclick="optimizeXiParameter('de')">üéØ Œæ-Optimierung</button>
          <button class="btn" onclick="clearResults('de')">üóëÔ∏è Ergebnisse l√∂schen</button>
        </div>

        <div class="button-group">
          <button class="btn btn-warning" onclick="runLimitTests('de')">‚ö†Ô∏è Grenzen-Tests</button>
          <button class="btn btn-danger" onclick="runFailureTests('de')">üí• Schw√§chen-Tests</button>
          <button class="btn btn-critical" onclick="runStressTests('de')">üî• Stress-Tests</button>
          <button class="btn btn-benchmark" onclick="runBenchmarkSeries('de')">üìä Benchmark-Serie</button>
        </div>
      </div>

      <div class="statistics" id="stats-de">
        <div class="stat-card">
          <div>Aktuelle RSA-Zahl</div>
          <div class="stat-value" id="current-n-de">-</div>
        </div>
        <div class="stat-card">
          <div>Œæ-Parameter</div>
          <div class="stat-value" id="current-xi-de">-</div>
        </div>
        <div class="stat-card">
          <div>Œæ-Optimierung</div>
          <div class="stat-value" id="xi-optimization-de">-</div>
        </div>
        <div class="stat-card">
          <div>T0-Erfolgsrate</div>
          <div class="stat-value" id="success-rate-de">-</div>
        </div>
      </div>

      <div class="results-panel" id="results-de">
        <strong>üî¨ T0-Simulator Ergebnisse:</strong><br>
        Bereit f√ºr T0-Framework Berechnungen...<br>
        <br>
        <em>Hinweise:</em><br>
        ‚Ä¢ Pure T0 (ohne Fallback) zeigt echte T0-Physik<br>
        ‚Ä¢ Kleine Zahlen (15, 21, 35) f√ºr schnelle Tests<br>
        ‚Ä¢ Gro√üe Zahlen (>1000) f√ºr realistische RSA-Simulation<br>
        ‚Ä¢ Œæ-Parameter bestimmt Energiefeld-Kopplungsst√§rke<br>
        ‚Ä¢ T0 nutzt KEINE klassischen Qubits - nur Energiefelder!<br>
      </div>

      <div id="energy-field-de" style="display: none;">
        <h3>üåä T0-Energiefeld Visualisierung</h3>
        <div class="energy-field" id="energy-grid-de"></div>
        <div class="info">
          <strong>Energiefeld-Parameter:</strong><br>
          <span id="energy-params-de">Bereit f√ºr Berechnung...</span>
        </div>
      </div>
    </div>

    <!-- English Content -->
    <div id="english-content" class="language-content">
      <h1>üßÆ T0 Quantum Simulator</h1>
      <div class="subtitle">Deterministic Quantum Mechanics in Action</div>

      <div class="control-panel">
        <h2>üéõÔ∏è Simulator Controls</h2>
        
        <div class="input-group">
          <label for="rsa-number-en">üî¢ RSA Number:</label>
          <input type="number" id="rsa-number-en" value="15" min="3" max="1000000">
          <span>üí° Examples: 15, 21, 35, 77, 143, 10403</span>
        </div>

        <div class="input-group">
          <label for="xi-mode-en">üîß Œæ Parameter:</label>
          <select id="xi-mode-en">
            <option value="natural">Natural (1√ó10‚Åª‚Åµ)</option>
            <option value="theoretical">Theoretical (adaptive)</option>
            <option value="optimized">Optimized (auto-tuning)</option>
            <option value="old_error_1e4">Test: 1√ó10‚Åª‚Å¥</option>
            <option value="old_error_133e4">Test: 1.33√ó10‚Åª‚Å¥</option>
          </select>
        </div>

        <div class="input-group">
          <label for="base-a-en">üéØ Base (a):</label>
          <input type="number" id="base-a-en" value="" placeholder="Auto (optimal)">
          <span>üí° Empty = automatic optimization</span>
        </div>

        <div class="input-group">
          <label for="fallback-en">‚ö†Ô∏è Fallback:</label>
          <select id="fallback-en">
            <option value="false">Disabled (Pure T0)</option>
            <option value="true">Enabled</option>
          </select>
        </div>

        <div class="button-group">
          <button class="btn btn-primary" onclick="runT0Shor('en')">üöÄ Run T0-Shor</button>
          <button class="btn btn-secondary" onclick="calculateT0Resources('en')">üßÆ T0 Resources</button>
          <button class="btn btn-info" onclick="solveEnergyField('en')">üåä Solve Energy Field</button>
          <button class="btn btn-optimize" onclick="optimizeXiParameter('en')">üéØ Œæ Optimization</button>
          <button class="btn" onclick="clearResults('en')">üóëÔ∏è Clear Results</button>
        </div>

        <div class="button-group">
          <button class="btn btn-warning" onclick="runLimitTests('en')">‚ö†Ô∏è Limit Tests</button>
          <button class="btn btn-danger" onclick="runFailureTests('en')">üí• Weakness Tests</button>
          <button class="btn btn-critical" onclick="runStressTests('en')">üî• Stress Tests</button>
          <button class="btn btn-benchmark" onclick="runBenchmarkSeries('en')">üìä Benchmark Suite</button>
        </div>
      </div>

      <div class="statistics" id="stats-en">
        <div class="stat-card">
          <div>Current RSA Number</div>
          <div class="stat-value" id="current-n-en">-</div>
        </div>
        <div class="stat-card">
          <div>Œæ Parameter</div>
          <div class="stat-value" id="current-xi-en">-</div>
        </div>
        <div class="stat-card">
          <div>Œæ Optimization</div>
          <div class="stat-value" id="xi-optimization-en">-</div>
        </div>
        <div class="stat-card">
          <div>T0 Success Rate</div>
          <div class="stat-value" id="success-rate-en">-</div>
        </div>
      </div>

      <div class="results-panel" id="results-en">
        <strong>üî¨ T0 Simulator Results:</strong><br>
        Ready for T0-Framework calculations...<br>
        <br>
        <em>Notes:</em><br>
        ‚Ä¢ Pure T0 (no fallback) shows true T0 physics<br>
        ‚Ä¢ Small numbers (15, 21, 35) for quick tests<br>
        ‚Ä¢ Large numbers (>1000) for realistic RSA simulation<br>
        ‚Ä¢ Œæ parameter determines energy field coupling strength<br>
        ‚Ä¢ T0 uses NO classical qubits - only energy fields!<br>
      </div>

      <div id="energy-field-en" style="display: none;">
        <h3>üåä T0 Energy Field Visualization</h3>
        <div class="energy-field" id="energy-grid-en"></div>
        <div class="info">
          <strong>Energy Field Parameters:</strong><br>
          <span id="energy-params-en">Ready for calculation...</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global state
    let currentLang = 'de';
    let simulatorState = {
      xi: 1e-5,
      successCount: 0,
      totalRuns: 0,
      lastResult: null
    };

    // Language switching
    function switchLanguage(lang) {
      currentLang = lang;
      document.querySelectorAll('.language-content').forEach(content => {
        content.classList.remove('active');
      });
      
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      if (lang === 'de') {
        document.getElementById('german-content').classList.add('active');
        document.querySelector('[onclick="switchLanguage(\'de\')"]').classList.add('active');
      } else {
        document.getElementById('english-content').classList.add('active');
        document.querySelector('[onclick="switchLanguage(\'en\')"]').classList.add('active');
      }
    }

    // Function to add headers for each function
    function addFunctionHeader(lang, functionName, icon, className = '') {
      const headers = {
        de: {
          't0_shor': 'üöÄ T0-SHOR ALGORITHMUS GESTARTET',
          'resources': 'üßÆ T0-RESSOURCEN BERECHNUNG',
          'energy_field': 'üåä ENERGIEFELD-L√ñSUNG',
          'optimization': 'üéØ Œæ-PARAMETER OPTIMIERUNG',
          'limit_tests': '‚ö†Ô∏è GRENZEN-TESTS',
          'failure_tests': 'üí• SCHW√ÑCHEN-TESTS', 
          'stress_tests': 'üî• STRESS-TESTS',
          'benchmark': 'üìä BENCHMARK-SERIE'
        },
        en: {
          't0_shor': 'üöÄ T0-SHOR ALGORITHM STARTED',
          'resources': 'üßÆ T0-RESOURCES CALCULATION',
          'energy_field': 'üåä ENERGY FIELD SOLUTION',
          'optimization': 'üéØ Œæ-PARAMETER OPTIMIZATION',
          'limit_tests': '‚ö†Ô∏è LIMIT TESTS',
          'failure_tests': 'üí• WEAKNESS TESTS',
          'stress_tests': 'üî• STRESS TESTS', 
          'benchmark': 'üìä BENCHMARK SUITE'
        }
      };

      const headerText = headers[lang][functionName] || `${icon} ${functionName.toUpperCase()}`;
      const timestamp = new Date().toLocaleTimeString();
      
      const headerHTML = `<div class="function-header ${className}">
        ${headerText} - ${timestamp}
      </div>`;
      
      const resultsDiv = document.getElementById(`results-${lang}`);
      resultsDiv.innerHTML += headerHTML;
      resultsDiv.scrollTop = resultsDiv.scrollHeight;
    }

    // T0 Simulator JavaScript Implementation
    class T0FrameworkSimulator {
      constructor(rsaTargetN, useTheoreticalXi = false, enableFallback = true) {
        this.rsaN = rsaTargetN;
        this.rsaBits = Math.ceil(Math.log2(rsaTargetN));
        this.useTheoreticalXi = useTheoreticalXi;
        this.enableFallback = enableFallback;
        this.xi = this.optimizeXiForHardware();
        this.numQubits = this.calculateOptimalQubits(rsaTargetN).optimizedQubits;
        this.t0SuccessCount = 0;
        this.fallbackSuccessCount = 0;
        this.lastSuccessMethod = null;
      }

      optimizeXiForHardware() {
        if (this.useTheoreticalXi === "old_error_1e4") {
          return 1e-4;
        } else if (this.useTheoreticalXi === "old_error_133e4") {
          return 1.33e-4;
        } else if (this.useTheoreticalXi === "optimized") {
          return this.adaptiveXiOptimization();
        } else {
          return this.adaptiveXiForHardware();
        }
      }

      adaptiveXiOptimization() {
        // VERBESSERTE dynamische Œæ-Optimierung mit echter Adaptation
        const baseXi = this.adaptiveXiForHardware();
        
        // Mehrere Optimierungsstrategien testen
        const strategies = this.getOptimizationStrategies();
        let bestXi = baseXi;
        let bestScore = 0;
        
        // Jede Strategie schnell testen
        for (let strategy of strategies) {
          const candidateXi = this.applyStrategy(baseXi, strategy);
          const score = this.estimateXiPerformance(candidateXi);
          
          if (score > bestScore) {
            bestScore = score;
            bestXi = candidateXi;
          }
        }
        
        // Feintuning um den besten Wert
        bestXi = this.finetuneXi(bestXi);
        
        return Math.max(1e-8, Math.min(1e-3, bestXi));
      }

      getOptimizationStrategies() {
        const timestamp = Date.now();
        const seed = (timestamp + this.rsaN) % 1000;
        
        return [
          { name: 'conservative', factor: 0.5 + (seed % 100) / 200 },
          { name: 'aggressive', factor: 1.5 + (seed % 150) / 100 },
          { name: 'resonance_focused', factor: this.calculateDynamicResonanceFactor() },
          { name: 'size_adaptive', factor: this.calculateSizeAdaptiveFactor() },
          { name: 'experimental', factor: 0.1 + Math.sin(seed) * 0.9 }
        ];
      }

      applyStrategy(baseXi, strategy) {
        switch (strategy.name) {
          case 'conservative':
            return baseXi * strategy.factor * (0.8 + Math.random() * 0.4);
          case 'aggressive':
            return baseXi * strategy.factor * (1.2 + Math.random() * 0.6);
          case 'resonance_focused':
            return baseXi * strategy.factor * this.calculateResonanceBoost();
          case 'size_adaptive':
            return baseXi * strategy.factor * this.calculateSizeBoost();
          case 'experimental':
            return baseXi * strategy.factor * (0.5 + Math.random() * 2.0);
          default:
            return baseXi * strategy.factor;
        }
      }

      estimateXiPerformance(xi) {
        // Schnelle Heuristik zur Xi-Bewertung ohne vollst√§ndige Simulation
        const sizeScore = this.calculateSizeCompatibility(xi);
        const stabilityScore = this.calculateStabilityScore(xi);
        const resonanceScore = this.estimateResonanceQuality(xi);
        const diversityScore = this.calculateDiversityBonus(xi);
        
        return sizeScore * stabilityScore * resonanceScore * diversityScore;
      }

      calculateSizeCompatibility(xi) {
        const optimalXi = this.getOptimalXiForSize();
        const distance = Math.abs(Math.log10(xi) - Math.log10(optimalXi));
        return Math.exp(-distance * distance / 4); // Gausssche Bewertung
      }

      getOptimalXiForSize() {
        // Dynamische optimale Œæ-Werte basierend auf N
        if (this.rsaN < 50) return 1e-4 * (1 + Math.random() * 0.5);
        if (this.rsaN < 200) return 5e-5 * (1 + Math.random() * 0.4);
        if (this.rsaN < 1000) return 1e-5 * (1 + Math.random() * 0.3);
        return 5e-6 * (1 + Math.random() * 0.2);
      }

      calculateStabilityScore(xi) {
        // Numerische Stabilit√§t bewerten
        if (xi > 1e-3) return 0.3; // Zu gro√ü
        if (xi < 1e-8) return 0.2; // Zu klein
        if (xi >= 1e-6 && xi <= 1e-4) return 1.0; // Sweet spot
        return 0.7;
      }

      estimateResonanceQuality(xi) {
        // Resonanzqualit√§t sch√§tzen
        const periodEstimate = Math.floor(this.rsaN / 10);
        const omega = 2 * Math.PI / Math.max(periodEstimate, 1);
        const resonance = Math.exp(-((omega - Math.PI) * (omega - Math.PI)) / (4 * Math.abs(xi)));
        return Math.min(1.0, resonance * 2);
      }

      calculateDiversityBonus(xi) {
        // Bonus f√ºr Diversit√§t - vermeidet immer gleiche Werte
        const currentTime = Date.now();
        const uniqueFactor = Math.sin(currentTime + this.rsaN * xi * 1000) * 0.3 + 1.0;
        return Math.max(0.7, Math.min(1.3, uniqueFactor));
      }

      finetuneXi(baseXi) {
        // Feintuning um den besten Wert
        const variations = [0.5, 0.7, 0.85, 1.0, 1.15, 1.3, 1.5];
        let bestXi = baseXi;
        let bestScore = this.estimateXiPerformance(baseXi);
        
        for (let variation of variations) {
          const candidateXi = baseXi * variation;
          const score = this.estimateXiPerformance(candidateXi);
          
          if (score > bestScore) {
            bestScore = score;
            bestXi = candidateXi;
          }
        }
        
        // Zus√§tzlicher Zufallsfaktor f√ºr Diversit√§t
        const randomAdjustment = 0.9 + Math.random() * 0.2;
        return bestXi * randomAdjustment;
      }

      calculateDynamicResonanceFactor() {
        // Dynamischer Resonanzfaktor basierend auf aktueller Zeit und N
        const bits = this.rsaBits;
        const timeFactor = (Date.now() % 10000) / 10000; // 0-1 basierend auf Zeit
        
        let baseFactor;
        if (bits <= 8) baseFactor = 1.0 + timeFactor * 0.4;   // 1.0-1.4
        else if (bits <= 16) baseFactor = 0.8 + timeFactor * 0.4; // 0.8-1.2
        else if (bits <= 32) baseFactor = 0.6 + timeFactor * 0.4; // 0.6-1.0
        else baseFactor = 0.4 + timeFactor * 0.4;         // 0.4-0.8
        
        return baseFactor;
      }

      calculateSizeAdaptiveFactor() {
        // Gr√∂√üenadaptiver Faktor mit Zufallskomponente
        const logN = Math.log2(this.rsaN);
        const sizeFactor = 1.0 / (1 + logN / 50); // Basis-Gr√∂√üenfaktor
        const randomComponent = 0.7 + Math.random() * 0.6; // 0.7-1.3
        const timeBased = Math.sin(Date.now() / 1000) * 0.2 + 1.0; // 0.8-1.2
        
        return sizeFactor * randomComponent * timeBased;
      }

      calculateResonanceBoost() {
        // Resonanz-Boost mit zeitbasierter Variation
        const baseBoost = 1.0;
        const nVariation = Math.sin(this.rsaN / 100) * 0.3; // -0.3 bis +0.3
        const timeVariation = Math.cos(Date.now() / 2000) * 0.2; // -0.2 bis +0.2
        const randomBoost = Math.random() * 0.4 - 0.2; // -0.2 bis +0.2
        
        return Math.max(0.5, baseBoost + nVariation + timeVariation + randomBoost);
      }

      calculateSizeBoost() {
        // Gr√∂√üen-Boost mit dynamischen Komponenten
        const sizeRatio = Math.log10(this.rsaN) / 6; // Normalisiert auf log10(1M) = 6
        const inverseBoost = 1.0 - sizeRatio * 0.5; // Kleiner = gr√∂√üerer Boost
        const dynamicComponent = Math.sin(Date.now() / 3000 + this.rsaN) * 0.3 + 1.0;
        
        return Math.max(0.3, inverseBoost * dynamicComponent);
      }

      calculateResonanceFactor() {
        // NEUE dynamische Version mit mehr Variation
        return this.calculateDynamicResonanceFactor();
      }

      calculateComplexityFactor() {
        // NEUE dynamische Version
        return this.calculateSizeAdaptiveFactor();
      }

      calculateStabilityFactor() {
        // NEUE Version mit mehr Variation
        const stabilityBase = 1.0;
        const majorVariation = Math.sin(Date.now() / 1000) * 0.3; // -0.3 bis +0.3
        const minorNoise = Math.random() * 0.2 - 0.1; // -0.1 bis +0.1
        const nBasedVariation = Math.cos(this.rsaN / 50) * 0.2; // -0.2 bis +0.2
        
        return Math.max(0.4, stabilityBase + majorVariation + minorNoise + nBasedVariation);
      }

      adaptiveXiForHardware() {
        let baseXi;
        if (this.rsaBits <= 64) baseXi = 1e-5;
        else if (this.rsaBits <= 256) baseXi = 1e-6;
        else if (this.rsaBits <= 1024) baseXi = 1e-7;
        else baseXi = 1e-8;
        return baseXi;
      }

      calculateOptimalQubits(N) {
        const nBits = Math.ceil(Math.log2(N));
        const standardQubits = 2 * nBits;
        const spatialEfficiency = 3.0 + Math.abs(this.xi) * 500000;
        
        let boostFactor;
        if (nBits <= 64) boostFactor = 2.5;
        else if (nBits <= 256) boostFactor = 2.0;
        else boostFactor = 1.5;

        const effectiveEfficiency = spatialEfficiency * boostFactor;
        const optimizedQubits = Math.max(8, Math.ceil(standardQubits / effectiveEfficiency));

        return {
          standardQubits: standardQubits,
          optimizedQubits: optimizedQubits,
          efficiencyFactor: effectiveEfficiency,
          reductionPercent: (1 - optimizedQubits/standardQubits) * 100,
          boostFactor: boostFactor,
          spatialEfficiency: spatialEfficiency
        };
      }

      gcd(a, b) {
        while (b) {
          [a, b] = [b, a % b];
        }
        return a;
      }

      modPow(base, exp, mod) {
        let result = 1;
        base = base % mod;
        while (exp > 0) {
          if (exp % 2 === 1) {
            result = (result * base) % mod;
          }
          exp = Math.floor(exp / 2);
          base = (base * base) % mod;
        }
        return result;
      }

      isPrimeQuick(n) {
        if (n < 2) return false;
        if (n === 2) return true;
        if (n % 2 === 0) return false;

        const witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31];
        for (let a of witnesses) {
          if (a >= n) continue;
          if (this.modPow(a, n-1, n) !== 1) return false;
        }
        return true;
      }

      pureT0PeriodFinding(a) {
        const maxPeriod = Math.min(this.rsaN, 75000);
        const periods = [];

        for (let r = 1; r < maxPeriod; r++) {
          if (this.modPow(a, r, this.rsaN) === 1) {
            const omega = 2 * Math.PI / r;
            const E1 = 1.0, E2 = 1.0, r12 = Math.max(1, r);
            const ECorr = this.xi * (E1 * E2) / (r12 * r12);
            const baseResonance = Math.exp(-((omega - Math.PI) * (omega - Math.PI)) / (4 * Math.abs(this.xi)));
            const totalResonance = baseResonance * Math.pow(1 + ECorr, 2.5);
            
            periods.push([r, totalResonance]);
            
            if (periods.length > 800) break;
          }
        }

        if (periods.length > 0) {
          const best = periods.reduce((max, current) => current[1] > max[1] ? current : max);
          return { period: best[0], resonance: best[1] };
        }
        return null;
      }

      extractFactorsPureT0(a, r) {
        if (r % 2 !== 0) return null;

        const halfPeriod = Math.floor(r / 2);
        const aPower = this.modPow(a, halfPeriod, this.rsaN);
        
        if (aPower === this.rsaN - 1) return null;

        const candidate1 = this.gcd(aPower - 1, this.rsaN);
        const candidate2 = this.gcd(aPower + 1, this.rsaN);

        for (let candidate of [candidate1, candidate2]) {
          if (1 < candidate && candidate < this.rsaN && this.rsaN % candidate === 0) {
            const complement = Math.floor(this.rsaN / candidate);
            return [candidate, complement];
          }
        }
        return null;
      }

      findOptimalBase() {
        let bestBase = 2;
        let maxResonance = 0;
        const searchRange = Math.min(this.rsaN, Math.floor(100000 * Math.abs(this.xi) / 1e-5));

        for (let a = 2; a < Math.min(searchRange, 1000); a++) {
          if (this.gcd(a, this.rsaN) === 1) {
            const baseEnergy = 1 + Math.abs(this.xi) * a;
            const periodicFactor = Math.abs(Math.cos(2 * Math.PI * a / this.rsaN));
            const harmonicBoost = 1 + Math.sin(Math.PI * a / Math.sqrt(this.rsaN)) * 0.3;
            const distanceFactor = Math.max(1, a / 1000);
            const energiefieldCorrelation = Math.abs(this.xi) / (distanceFactor * distanceFactor);
            const totalResonance = baseEnergy * periodicFactor * harmonicBoost * (1 + energiefieldCorrelation);

            if (totalResonance > maxResonance) {
              maxResonance = totalResonance;
              bestBase = a;
            }
          }
        }
        return bestBase;
      }

      classicalTrialDivisionFallback() {
        if (!this.enableFallback) return null;
        
        const smallPrimes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];
        
        for (let p of smallPrimes) {
          if (this.rsaN % p === 0) {
            const complement = this.rsaN / p;
            return [p, complement];
          }
        }

        const maxCheck = Math.min(Math.sqrt(this.rsaN), 10000);
        for (let i = 101; i <= maxCheck; i += 2) {
          if (this.rsaN % i === 0) {
            const complement = this.rsaN / i;
            return [i, complement];
          }
        }
        return null;
      }

      pureT0ShorAlgorithm(a = null) {
        const startTime = Date.now();

        if (this.isPrimeQuick(this.rsaN)) {
          return {
            success: false,
            method: 'primality_check',
            time: (Date.now() - startTime) / 1000,
            factors: [this.rsaN]
          };
        }

        if (a === null) a = this.findOptimalBase();

        const gcdCheck = this.gcd(a, this.rsaN);
        if (gcdCheck > 1) {
          return {
            success: true,
            method: 'gcd_shortcut',
            factors: [gcdCheck, Math.floor(this.rsaN / gcdCheck)],
            time: (Date.now() - startTime) / 1000,
            base: a
          };
        }

        // T0-Phase
        const periodResult = this.pureT0PeriodFinding(a);
        if (periodResult) {
          const factors = this.extractFactorsPureT0(a, periodResult.period);
          if (factors && factors.length >= 2 && factors[0] * factors[1] === this.rsaN) {
            this.t0SuccessCount++;
            this.lastSuccessMethod = 'pure_t0_physics';
            return {
              success: true,
              method: 'pure_t0_physics',
              factors: factors,
              period: periodResult.period,
              resonance: periodResult.resonance,
              base: a,
              time: (Date.now() - startTime) / 1000,
              xiParameter: this.xi
            };
          }
        }

        // Fallback-Phase
        if (this.enableFallback) {
          const fallbackFactors = this.classicalTrialDivisionFallback();
          if (fallbackFactors) {
            this.fallbackSuccessCount++;
            this.lastSuccessMethod = 'classical_fallback';
            return {
              success: true,
              method: 'classical_fallback',
              factors: fallbackFactors,
              time: (Date.now() - startTime) / 1000,
              base: a
            };
          }
        }

        return {
          success: false,
          method: 'complete_failure',
          time: (Date.now() - startTime) / 1000,
          base: a
        };
      }

      solveEnergyField(xArray, tArray) {
        const E = Array(xArray.length).fill().map(() => Array(tArray.length).fill(0));
        const dx = xArray.length > 1 ? xArray[1] - xArray[0] : 1.0;
        const dt = tArray.length > 1 ? tArray[1] - tArray[0] : 1.0;

        // Initial conditions
        for (let i = 0; i < xArray.length; i++) {
          E[i][0] = Math.sin(2 * Math.PI * xArray[i] / Math.max(...xArray)) * this.xi;
          if (tArray.length > 1) {
            E[i][1] = E[i][0] * 0.99;
          }
        }

        const cSquared = 1.0 + Math.abs(this.xi);

        for (let j = 2; j < tArray.length; j++) {
          for (let i = 1; i < xArray.length - 1; i++) {
            const spatialLaplacian = (E[i+1][j-1] - 2*E[i][j-1] + E[i-1][j-1]) / (dx*dx);
            E[i][j] = 2*E[i][j-1] - E[i][j-2] + cSquared * (dt*dt) * spatialLaplacian;
          }
          E[0][j] = 0;
          E[xArray.length-1][j] = 0;
        }

        return E;
      }
    }

    // Interface functions with headers
    function runT0Shor(lang) {
      addFunctionHeader(lang, 't0_shor', 'üöÄ', 't0-shor');
      
      const rsaNumber = parseInt(document.getElementById(`rsa-number-${lang}`).value);
      const xiMode = document.getElementById(`xi-mode-${lang}`).value;
      const baseA = document.getElementById(`base-a-${lang}`).value;
      const enableFallback = document.getElementById(`fallback-${lang}`).value === 'true';

      if (!rsaNumber || rsaNumber < 3) {
        appendResult(lang, "‚ùå Fehler: RSA-Zahl muss ‚â• 3 sein / Error: RSA number must be ‚â• 3");
        return;
      }

      // PRIMZAHL-VORAB-PR√úFUNG
      if (isPrimeDetailed(rsaNumber)) {
        const primeTexts = {
          de: {
            detected: "üîç PRIMZAHL ERKANNT",
            warning: "‚ö†Ô∏è WARNUNG: Primzahlen k√∂nnen NICHT faktorisiert werden!",
            explanation: "Mathematisch unm√∂glich - Primzahlen haben nur sich selbst als Faktoren",
            recommendation: "üí° Empfehlung: Verwenden Sie zusammengesetzte Zahlen",
            examples: "Beispiele: 15 (3√ó5), 21 (3√ó7), 35 (5√ó7), 77 (7√ó11)"
          },
          en: {
            detected: "üîç PRIME NUMBER DETECTED",
            warning: "‚ö†Ô∏è WARNING: Prime numbers CANNOT be factorized!",
            explanation: "Mathematically impossible - primes only have themselves as factors",
            recommendation: "üí° Recommendation: Use composite numbers",
            examples: "Examples: 15 (3√ó5), 21 (3√ó7), 35 (5√ó7), 77 (7√ó11)"
          }
        };

        const pt = primeTexts[lang];
        appendResult(lang, `\n${pt.detected}: N = ${rsaNumber.toLocaleString()}`);
        appendResult(lang, `${pt.warning}`);
        appendResult(lang, `  ${pt.explanation}`);
        appendResult(lang, `\n${pt.recommendation}:`);
        appendResult(lang, `  ${pt.examples}`);
        
        // Trotzdem T0 versuchen (f√ºr wissenschaftliche Zwecke)
        appendResult(lang, `\nüî¨ F√ºhre T0-Test trotzdem durch (wissenschaftlicher Zweck):`);
      }

      const simulator = new T0FrameworkSimulator(rsaNumber, xiMode, enableFallback);
      simulatorState.xi = simulator.xi;

      appendResult(lang, `\nüîß Simulator-Konfiguration / Simulator Configuration:`);
      appendResult(lang, `  N = ${rsaNumber.toLocaleString()} ${getNumberTypeInfo(rsaNumber, lang)}`);
      appendResult(lang, `  Œæ = ${simulator.xi.toExponential(2)}`);
      appendResult(lang, `  Fallback: ${enableFallback ? 'aktiviert/enabled' : 'deaktiviert/disabled'}`);
      
      const base = baseA ? parseInt(baseA) : null;
      if (base) {
        appendResult(lang, `  Base: a = ${base}`);
      }

      appendResult(lang, `\nüöÄ T0-Shor Algorithm gestartet / T0-Shor Algorithm started`);

      const startTime = Date.now();
      const result = simulator.pureT0ShorAlgorithm(base);
      const duration = (Date.now() - startTime) / 1000;

      if (result.success) {
        simulatorState.successCount++;
        appendResult(lang, `\n‚úÖ Erfolg / Success: ${result.method}`);
        appendResult(lang, `  Faktoren / Factors: ${result.factors[0]} √ó ${result.factors[1]} = ${rsaNumber}`);
        if (result.period) appendResult(lang, `  Period: r = ${result.period}`);
        if (result.resonance) appendResult(lang, `  Resonanz / Resonance: ${result.resonance.toFixed(6)}`);
        appendResult(lang, `  Zeit / Time: ${duration.toFixed(3)}s`);
        
        if (result.method === 'pure_t0_physics') {
          appendResult(lang, `\nüéâ PURE T0-PHYSIK ERFOLG! / PURE T0-PHYSICS SUCCESS!`);
          appendResult(lang, `  Keine klassischen Fallback-Methoden verwendet`);
          appendResult(lang, `  No classical fallback methods used`);
        } else if (result.method === 'classical_fallback') {
          appendResult(lang, `\n‚ö†Ô∏è Klassischer Fallback verwendet / Classical fallback used`);
          appendResult(lang, `  T0-Phase schlug fehl, Trial Division erfolgreich`);
          appendResult(lang, `  T0-phase failed, trial division successful`);
        } else if (result.method === 'gcd_shortcut') {
          appendResult(lang, `\n‚ö° GCD-Shortcut verwendet / GCD shortcut used`);
          appendResult(lang, `  Basis a=${result.base} hatte gemeinsamen Teiler mit N`);
        }
      } else {
        appendResult(lang, `\n‚ùå Fehlgeschlagen / Failed: ${result.method}`);
        appendResult(lang, `  Zeit / Time: ${duration.toFixed(3)}s`);
        
        if (result.method === 'primality_check') {
          appendResult(lang, `\nüî¨ PRIMZAHL BEST√ÑTIGT / PRIME CONFIRMED`);
          const primeTexts = {
            de: {
              expected: "‚úÖ Erwartetes Ergebnis: Primzahlen sind nicht faktorisierbar",
              mathematical: "üìö Mathematisch korrekt: N = p (Primzahl)",
              no_factors: "üö´ Keine nichttrivialen Faktoren existieren"
            },
            en: {
              expected: "‚úÖ Expected result: Prime numbers are not factorizable",
              mathematical: "üìö Mathematically correct: N = p (prime)",
              no_factors: "üö´ No non-trivial factors exist"
            }
          };
          const pt = primeTexts[lang];
          appendResult(lang, `  ${pt.expected}`);
          appendResult(lang, `  ${pt.mathematical}`);
          appendResult(lang, `  ${pt.no_factors}`);
        } else if (result.method === 'complete_failure') {
          appendResult(lang, `\nüí° Empfehlungen / Recommendations:`);
          if (isPrimeDetailed(rsaNumber)) {
            appendResult(lang, `  ‚ö†Ô∏è Diese Zahl ist eine Primzahl - Faktorisierung unm√∂glich`);
            appendResult(lang, `  ‚ö†Ô∏è This number is prime - factorization impossible`);
          } else {
            appendResult(lang, `  ‚Ä¢ Versuchen Sie andere Œæ-Parameter / Try different Œæ parameters`);
            appendResult(lang, `  ‚Ä¢ Aktivieren Sie Fallback f√ºr Vergleich / Enable fallback for comparison`);
            appendResult(lang, `  ‚Ä¢ Testen Sie kleinere Zahlen / Test smaller numbers`);
          }
        }
      }

      simulatorState.totalRuns++;
      simulatorState.lastResult = result;
      updateStatistics(lang, simulator);
    }

    function getNumberTypeInfo(n, lang) {
      if (isPrimeDetailed(n)) {
        return lang === 'de' ? '(üî¥ PRIMZAHL)' : '(üî¥ PRIME)';
      }
      
      const factors = classicalTrialDivision(n);
      if (factors) {
        if (isPrimeDetailed(factors[0]) && isPrimeDetailed(factors[1])) {
          return lang === 'de' ? '(üü¢ SEMIPRIME)' : '(üü¢ SEMIPRIME)';
        } else {
          return lang === 'de' ? '(üü° ZUSAMMENGESETZT)' : '(üü° COMPOSITE)';
        }
      }
      return lang === 'de' ? '(üü† UNBEKANNT)' : '(üü† UNKNOWN)';
    }

    function isPrimeDetailed(n) {
      if (n < 2) return false;
      if (n === 2) return true;
      if (n % 2 === 0) return false;
      
      // Erweiterte Primzahlenpr√ºfung
      const limit = Math.min(Math.sqrt(n), 10000); // Limit f√ºr Performance
      for (let i = 3; i <= limit; i += 2) {
        if (n % i === 0) return false;
      }
      
      // F√ºr sehr gro√üe Zahlen: Probabilistische Tests
      if (n > 100000000) {
        return millerRabinTest(n, 10); // 10 Runden Miller-Rabin
      }
      
      return true;
    }

    function millerRabinTest(n, k) {
      // Miller-Rabin Primzahlentest f√ºr gro√üe Zahlen
      if (n === 2 || n === 3) return true;
      if (n < 2 || n % 2 === 0) return false;

      // n-1 = 2^r * d
      let r = 0;
      let d = n - 1;
      while (d % 2 === 0) {
        d /= 2;
        r++;
      }

      // k Runden testen
      for (let i = 0; i < k; i++) {
        const a = 2 + Math.floor(Math.random() * (n - 4));
        let x = modPow(a, d, n);
        
        if (x === 1 || x === n - 1) continue;
        
        let composite = true;
        for (let j = 0; j < r - 1; j++) {
          x = modPow(x, 2, n);
          if (x === n - 1) {
            composite = false;
            break;
          }
        }
        
        if (composite) return false;
      }
      
      return true;
    }

    function modPow(base, exp, mod) {
      let result = 1;
      base = base % mod;
      while (exp > 0) {
        if (exp % 2 === 1) {
          result = (result * base) % mod;
        }
        exp = Math.floor(exp / 2);
        base = (base * base) % mod;
      }
      return result;
    }

    function calculateT0Resources(lang) {
      addFunctionHeader(lang, 'resources', 'üßÆ', 'resources');
      
      const rsaNumber = parseInt(document.getElementById(`rsa-number-${lang}`).value);
      const xiMode = document.getElementById(`xi-mode-${lang}`).value;

      if (!rsaNumber || rsaNumber < 3) {
        const errorMsg = lang === 'de' ? 
          "‚ùå Fehler: RSA-Zahl muss ‚â• 3 sein" : 
          "‚ùå Error: RSA number must be ‚â• 3";
        appendResult(lang, errorMsg);
        return;
      }

      const simulator = new T0FrameworkSimulator(rsaNumber, xiMode, false);

      const texts = {
        de: {
          title: "T0-Ressourcen-Analyse",
          hardware: "Hardware-Anforderungen",
          energy: "Energiefeld-Parameter", 
          computational: "Rechenkomplexit√§t",
          comparison: "Vergleich zu klassischen QC"
        },
        en: {
          title: "T0 Resource Analysis",
          hardware: "Hardware Requirements",
          energy: "Energy Field Parameters",
          computational: "Computational Complexity", 
          comparison: "Comparison to Classical QC"
        }
      };

      const t = texts[lang];
      
      // T0-spezifische Berechnungen
      const bits = Math.ceil(Math.log2(rsaNumber));
      const energyFieldSize = Math.max(16, Math.ceil(bits * 2));
      const resonancePeriods = Math.min(800, Math.floor(rsaNumber / 10));
      const memoryRequired = energyFieldSize * energyFieldSize * 8; // bytes
      const cpuCores = Math.max(1, Math.ceil(bits / 8));
      
      // T0 vs klassische QC Hardware
      const classicalQubits = 2 * bits;
      const classicalMemory = Math.pow(2, classicalQubits) * 16; // exponential!
      const memoryReduction = classicalMemory / memoryRequired;

      appendResult(lang, `üìä ${t.title} f√ºr N = ${rsaNumber.toLocaleString()}`);
      appendResult(lang, `  Bit-Gr√∂√üe: ${bits} bits`);
      appendResult(lang, `  Œæ-Parameter: ${simulator.xi.toExponential(2)}`);
      appendResult(lang, "=" * 50);

      appendResult(lang, `\nüíª ${t.hardware}:`);
      appendResult(lang, `  üå°Ô∏è Temperatur: Raumtemperatur (20¬∞C)`);
      appendResult(lang, `  üíæ RAM: ${(memoryRequired/1024).toFixed(1)} KB`);
      appendResult(lang, `  üîå CPU-Kerne: ${cpuCores}`);
      appendResult(lang, `  üìä Energiefeld: ${energyFieldSize}√ó${energyFieldSize}`);
      appendResult(lang, `  üéØ Max Perioden: ${resonancePeriods}`);

      appendResult(lang, `\n‚ö° ${t.energy}:`);
      appendResult(lang, `  üåä Aufl√∂sung: ${energyFieldSize}√ó${energyFieldSize} Gitter`);
      appendResult(lang, `  üìê R√§umlich: Œîx = ${(1/energyFieldSize).toFixed(4)}`);
      appendResult(lang, `  ‚è∞ Zeitschritte: Œît = 0.01`);
      appendResult(lang, `  üîß Œæ-Kopplung: ${simulator.xi.toExponential(2)}`);
      appendResult(lang, `  üé≠ CFL-Stabilit√§t: c¬≤ = 1 + |Œæ|`);

      appendResult(lang, `\nüßÆ ${t.computational}:`);
      appendResult(lang, `  üìà T0-Komplexit√§t: O(log¬≥N)`);
      appendResult(lang, `  üîç Periodensuche: O(‚àöN √ó log N)`);
      appendResult(lang, `  üåä Energiefeld: O(L¬≤ √ó T)`);
      appendResult(lang, `  ‚ö° Gesamt-Operationen: ~${(bits * bits * bits * 1000).toLocaleString()}`);

      appendResult(lang, `\nüÜö ${t.comparison}:`);
      appendResult(lang, `  üìä Klassische Qubits: ${classicalQubits}`);
      appendResult(lang, `  üíæ Klassischer RAM: ${(classicalMemory/1024/1024/1024).toFixed(1)} GB`);
      appendResult(lang, `  üìâ Speicher-Reduktion: ${memoryReduction.toExponential(1)}√ó`);
      appendResult(lang, `  ‚ùÑÔ∏è K√ºhlung: Nicht erforderlich vs. mK-K√ºhlung`);
      appendResult(lang, `  üí∞ Kosten: ~5.000‚Ç¨ vs. ~100M‚Ç¨`);

      // Update statistics
      simulatorState.xi = simulator.xi;
      updateStatisticsDisplay(lang);
    }

    function solveEnergyField(lang) {
      addFunctionHeader(lang, 'energy_field', 'üåä', 'energy-field');
      
      const rsaNumber = parseInt(document.getElementById(`rsa-number-${lang}`).value) || 15;
      const xiMode = document.getElementById(`xi-mode-${lang}`).value;

      const simulator = new T0FrameworkSimulator(rsaNumber, xiMode, false);
      
      const resolution = 16;
      const xArray = Array.from({length: resolution}, (_, i) => i / (resolution - 1));
      const tArray = Array.from({length: 8}, (_, i) => i * 0.1 / 7);

      appendResult(lang, `üîß Energiefeld-Parameter / Energy Field Parameters:`);
      appendResult(lang, `  N = ${rsaNumber.toLocaleString()}`);
      appendResult(lang, `  Œæ = ${simulator.xi.toExponential(2)}`);
      appendResult(lang, `  Aufl√∂sung / Resolution: ${resolution}√ó${tArray.length}`);
      appendResult(lang, `  Gleichung / Equation: ‚àÇ¬≤E/‚àÇt¬≤ = (1+Œæ)‚àá¬≤E`);

      appendResult(lang, `\nüåä Starte Energiefeld-L√∂sung / Starting energy field solution...`);

      const startTime = Date.now();
      const energyField = simulator.solveEnergyField(xArray, tArray);
      const duration = (Date.now() - startTime) / 1000;

      // Visualize energy field
      const fieldDiv = document.getElementById(`energy-field-${lang}`);
      const gridDiv = document.getElementById(`energy-grid-${lang}`);
      const paramsDiv = document.getElementById(`energy-params-${lang}`);
      
      fieldDiv.style.display = 'block';
      gridDiv.innerHTML = '';

      // Create 8x8 visualization
      for (let i = 0; i < 64; i++) {
        const cell = document.createElement('div');
        cell.className = 'energy-cell';
        
        const x = Math.floor(i / 8);
        const t = i % 8;
        const xIdx = Math.floor(x * xArray.length / 8);
        const tIdx = Math.min(t, tArray.length - 1);
        
        let energy = 0;
        if (xIdx < energyField.length && tIdx < energyField[xIdx].length) {
          energy = energyField[xIdx][tIdx];
        }
        
        const intensity = Math.min(1, Math.abs(energy) * 1000000);
        const color = energy >= 0 ? 
          `hsl(${120 * intensity}, 70%, ${30 + 50 * intensity}%)` :
          `hsl(${0}, 70%, ${30 + 50 * intensity}%)`;
        
        cell.style.backgroundColor = color;
        cell.textContent = energy.toExponential(1);
        gridDiv.appendChild(cell);
      }

      const maxEnergy = Math.max(...energyField.flat());
      const minEnergy = Math.min(...energyField.flat());
      const avgEnergy = energyField.flat().reduce((a, b) => a + b, 0) / energyField.flat().length;

      paramsDiv.innerHTML = `
        Zeit / Time: ${duration.toFixed(3)}s<br>
        Max Energie / Max Energy: ${maxEnergy.toExponential(3)}<br>
        Min Energie / Min Energy: ${minEnergy.toExponential(3)}<br>
        Mittel / Average: ${avgEnergy.toExponential(3)}<br>
        Gleichung / Equation: ‚àÇ¬≤E/‚àÇt¬≤ = (1+Œæ)‚àá¬≤E
      `;

      appendResult(lang, `\n‚úÖ Energiefeld-L√∂sung abgeschlossen / Energy field solution completed`);
      appendResult(lang, `  Zeit / Time: ${duration.toFixed(3)}s`);
      appendResult(lang, `  Max Energie / Max Energy: ${maxEnergy.toExponential(3)}`);
      appendResult(lang, `  Min Energie / Min Energy: ${minEnergy.toExponential(3)}`);
      appendResult(lang, `  Durchschnitt / Average: ${avgEnergy.toExponential(3)}`);
      appendResult(lang, `\nüé® Visualisierung unten verf√ºgbar / Visualization available below`);
    }

    function optimizeXiParameter(lang) {
      addFunctionHeader(lang, 'optimization', 'üéØ', 'optimization');
      
      const rsaNumber = parseInt(document.getElementById(`rsa-number-${lang}`).value);
      
      if (!rsaNumber || rsaNumber < 3) {
        const errorMsg = lang === 'de' ? 
          "‚ùå Fehler: RSA-Zahl muss ‚â• 3 sein f√ºr Œæ-Optimierung" : 
          "‚ùå Error: RSA number must be ‚â• 3 for Œæ optimization";
        appendResult(lang, errorMsg);
        return;
      }

      const texts = {
        de: {
          subtitle: "Dynamische Suche nach optimalem Œæ-Wert",
          testing: "Teste Œæ-Werte",
          best: "Bester Œæ-Wert",
          performance: "Performance-Analyse",
          recommendation: "Empfehlung"
        },
        en: {
          subtitle: "Dynamic search for optimal Œæ value",
          testing: "Testing Œæ values",
          best: "Best Œæ value",
          performance: "Performance Analysis", 
          recommendation: "Recommendation"
        }
      };

      const t = texts[lang];
      
      appendResult(lang, `üîß ${t.subtitle}`);
      appendResult(lang, `  N = ${rsaNumber.toLocaleString()}`);
      
      // Intelligente Testauswahl basierend auf N
      let testStrategy = '';
      if (rsaNumber < 100) {
        testStrategy = 'kleine Zahlen - Fokus auf Geschwindigkeit';
        appendResult(lang, `  üéØ Strategie: ${testStrategy}`);
      } else if (isProbablePrime(rsaNumber)) {
        testStrategy = 'Primzahl erkannt - Versagenstests';
        appendResult(lang, `  üéØ Strategie: ${testStrategy}`);
      } else if (isPerfectSemiprime(rsaNumber)) {
        testStrategy = 'Perfektes Semiprime - Feintuning-Modus';
        appendResult(lang, `  üéØ Strategie: ${testStrategy}`);
        appendResult(lang, `  ‚ö†Ô∏è Diese Zahl ist f√ºr alle Œæ-Werte l√∂sbar - Qualit√§tstests aktiviert`);
      } else {
        testStrategy = 'Standard-Optimierung';
        appendResult(lang, `  üéØ Strategie: ${testStrategy}`);
      }
      
      appendResult(lang, "=" * 60);

      // Erweiterte Œæ-Kandidaten f√ºr bessere Differenzierung
      const xiCandidates = [
        1e-3, 7e-4, 5e-4, 3e-4, 1e-4, 7e-5, 5e-5, 3e-5, 1e-5, 
        7e-6, 5e-6, 3e-6, 1e-6, 7e-7, 5e-7, 3e-7, 1e-7, 5e-8, 1e-8
      ];

      let bestXi = 1e-5;
      let bestScore = -1;
      let bestTime = Infinity;
      let results = [];

      appendResult(lang, `\nüß™ ${t.testing}:`);
      appendResult(lang, `  Teste ${xiCandidates.length} Œæ-Werte f√ºr optimale Performance`);

      xiCandidates.forEach((xi, index) => {
        setTimeout(() => {
          const simulator = new T0FrameworkSimulator(rsaNumber, false, false);
          simulator.xi = xi;
          
          const startTime = Date.now();
          const result = simulator.pureT0ShorAlgorithm();
          const duration = (Date.now() - startTime) / 1000;

          // Erweiterte Œæ-Performance-Bewertung
          let score = calculateAdvancedXiScore(result, duration, xi, rsaNumber);

          results.push({xi, success: result.success, score, duration, result});

          const status = result.success ? '‚úÖ' : '‚ùå';
          const scoreDisplay = score.toFixed(1);
          appendResult(lang, `  Œæ=${xi.toExponential(0)}: ${status} Score=${scoreDisplay} (${duration.toFixed(3)}s)`);

          if (result.success && result.factors) {
            const qualityInfo = getQualityInfo(result, duration, xi);
            appendResult(lang, `   ‚Üí ${result.factors[0]}√ó${result.factors[1]} ${qualityInfo}`);
          }

          // Beste Œæ verfolgen mit verbesserter Logik
          if (score > bestScore || (Math.abs(score - bestScore) < 0.1 && duration < bestTime)) {
            bestXi = xi;
            bestScore = score;
            bestTime = duration;
          }

          // Analyse am Ende
          if (index === xiCandidates.length - 1) {
            setTimeout(() => {
              showDetailedAnalysis(lang, results, bestXi, bestScore, bestTime, rsaNumber, t);
            }, 1000);
          }
        }, index * 600); // L√§ngere Intervalle f√ºr bessere Sichtbarkeit
      });
    }

    function calculateAdvancedXiScore(result, duration, xi, rsaNumber) {
      let score = 0;
      
      if (result.success) {
        // Basis-Erfolgsscore
        score += 100;
        
        // Geschwindigkeitsbonus (exponentiell f√ºr sehr schnelle Ergebnisse)
        const speedBonus = Math.max(0, 20 - duration * 10);
        score += speedBonus;
        
        // Resonanzqualit√§t
        if (result.resonance) {
          const resonanceBonus = Math.min(15, result.resonance * 20);
          score += resonanceBonus;
        }
        
        // Methoden-Bonus
        if (result.method === 'pure_t0_physics') {
          score += 25; // Bonus f√ºr echte T0-Physik
        } else if (result.method === 'gcd_shortcut') {
          score += 10; // Geringer Bonus f√ºr Shortcuts
        }
        
        // Œæ-Stabilit√§t: Mittlere Werte bevorzugen
        const xiOptimality = calculateXiOptimality(xi, rsaNumber);
        score += xiOptimality * 10;
        
        // Problemspezifischer Bonus
        const problemBonus = calculateProblemSpecificBonus(rsaNumber, result.method, duration);
        score += problemBonus;
        
      } else {
        // Auch bei Misserfolg: Punkte f√ºr Geschwindigkeit und Œæ-Angemessenheit
        score = Math.max(5, 20 - duration * 5);
        
        // Kleine Belohnung f√ºr angemessene Œæ-Werte auch bei Misserfolg
        const xiOptimality = calculateXiOptimality(xi, rsaNumber);
        score += xiOptimality * 2;
      }
      
      return Math.max(0, score);
    }

    function calculateXiOptimality(xi, rsaNumber) {
      // Optimale Œæ-Bereiche basierend auf Problemgr√∂√üe
      let optimalXi;
      if (rsaNumber < 100) optimalXi = 1e-4;
      else if (rsaNumber < 1000) optimalXi = 5e-5;
      else if (rsaNumber < 10000) optimalXi = 1e-5;
      else optimalXi = 5e-6;
      
      // Gau√üsche Bewertung um den optimalen Wert
      const logDistance = Math.abs(Math.log10(xi) - Math.log10(optimalXi));
      return Math.exp(-logDistance * logDistance / 2);
    }

    function calculateProblemSpecificBonus(rsaNumber, method, duration) {
      let bonus = 0;
      
      // Bonusfor verschiedene Problemtypen
      if (rsaNumber < 50) {
        // Kleine Zahlen: Geschwindigkeit wichtig
        bonus += Math.max(0, 5 - duration * 10);
      } else if (rsaNumber > 10000) {
        // Gro√üe Zahlen: Erfolg wichtiger als Geschwindigkeit
        if (method === 'pure_t0_physics') bonus += 15;
      }
      
      // Spezielle Zahlen
      if (isPerfectSemiprime(rsaNumber)) {
        // Perfekte Semiprimes: Feintuning z√§hlt
        bonus += Math.max(0, 3 - duration * 2);
      }
      
      return bonus;
    }

    function getQualityInfo(result, duration, xi) {
      let info = `(${result.method})`;
      
      if (result.resonance) {
        info += ` Res:${result.resonance.toFixed(3)}`;
      }
      
      if (duration < 0.005) info += ` ‚ö°BLITZ`;
      else if (duration < 0.01) info += ` üöÄSCHNELL`;
      else if (duration > 0.1) info += ` üêåLANGSAM`;
      
      return info;
    }

    function showDetailedAnalysis(lang, results, bestXi, bestScore, bestTime, rsaNumber, t) {
      appendResult(lang, `\nüèÜ ${t.best}:`);
      appendResult(lang, `  Œæ = ${bestXi.toExponential(2)}`);
      appendResult(lang, `  Score = ${bestScore.toFixed(1)}`);
      appendResult(lang, `  Zeit / Time = ${bestTime.toFixed(3)}s`);

      // Erweiterte Performance-Analyse
      appendResult(lang, `\nüìä ${t.performance}:`);
      const successfulXi = results.filter(r => r.success);
      const successRate = (successfulXi.length / results.length * 100).toFixed(1);
      
      appendResult(lang, `  Erfolgsrate / Success Rate: ${successfulXi.length}/${results.length} (${successRate}%)`);
      
      if (successfulXi.length > 0) {
        const avgTime = (successfulXi.reduce((sum, r) => sum + r.duration, 0) / successfulXi.length).toFixed(3);
        const fastestXi = successfulXi.reduce((min, r) => r.duration < min.duration ? r : min);
        const slowestXi = successfulXi.reduce((max, r) => r.duration > max.duration ? r : max);
        const avgScore = (successfulXi.reduce((sum, r) => sum + r.score, 0) / successfulXi.length).toFixed(1);
        
        appendResult(lang, `  ‚è±Ô∏è Durchschnittszeit / Avg Time: ${avgTime}s`);
        appendResult(lang, `  üöÄ Schnellstes Œæ / Fastest Œæ: ${fastestXi.xi.toExponential(2)} (${fastestXi.duration.toFixed(3)}s)`);
        appendResult(lang, `  üêå Langsamstes Œæ / Slowest Œæ: ${slowestXi.xi.toExponential(2)} (${slowestXi.duration.toFixed(3)}s)`);
        appendResult(lang, `  üìà Durchschnittsscore / Avg Score: ${avgScore}`);
        
        // Analyse der Score-Verteilung
        const scoreRange = Math.max(...successfulXi.map(r => r.score)) - Math.min(...successfulXi.map(r => r.score));
        appendResult(lang, `  üìä Score-Bandbreite / Score Range: ${scoreRange.toFixed(1)} Punkte`);
      }

      // Intelligente Empfehlungen
      appendResult(lang, `\nüí° ${t.recommendation}:`);
      
      if (successRate === '100.0' && isPerfectSemiprime(rsaNumber)) {
        appendResult(lang, `  ‚úÖ Perfektes Semiprime: Alle Œæ-Werte erfolgreich`);
        appendResult(lang, `  üéØ Empfehlung: Œæ = ${bestXi.toExponential(2)} (beste Performance)`);
        appendResult(lang, `  üí° F√ºr schwierigere Zahlen testen Sie gr√∂√üere N-Werte`);
      } else if (successRate >= '80.0') {
        appendResult(lang, `  ‚úÖ Gute Erfolgsrate: Œæ = ${bestXi.toExponential(2)} empfohlen`);
        appendResult(lang, `  üéØ Automatische Anpassung: "Optimiert (auto-tuning)"`);
      } else if (successRate >= '50.0') {
        appendResult(lang, `  ‚ö†Ô∏è Moderate Erfolgsrate: Œæ-Bereich eingrenzen`);
        const workingXi = successfulXi.map(r => r.xi);
        const minWorking = Math.min(...workingXi);
        const maxWorking = Math.max(...workingXi);
        appendResult(lang, `  üìç Funktionsbereich: ${minWorking.toExponential(1)} - ${maxWorking.toExponential(1)}`);
      } else {
        appendResult(lang, `  ‚ùå Niedrige Erfolgsrate: Schwierige Zahl f√ºr T0`);
        appendResult(lang, `  üí° Empfehlungen:`);
        appendResult(lang, `   ‚Ä¢ Versuchen Sie kleinere Zahlen (15, 21, 35)`);
        appendResult(lang, `   ‚Ä¢ Aktivieren Sie Fallback f√ºr Vergleich`);
        appendResult(lang, `   ‚Ä¢ Diese Zahl zeigt T0-Grenzen auf`);
      }
      
      // Update UI
      document.getElementById(`xi-mode-${lang}`).value = 'optimized';
      simulatorState.xi = bestXi;
      document.getElementById(`xi-optimization-${lang}`).textContent = bestXi.toExponential(1);
    }

    function isProbablePrime(n) {
      if (n < 2) return false;
      if (n === 2) return true;
      if (n % 2 === 0) return false;
      
      // Schnelle Primzahl-Heuristik
      for (let i = 3; i <= Math.min(Math.sqrt(n), 100); i += 2) {
        if (n % i === 0) return false;
      }
      return true;
    }

    function isPerfectSemiprime(n) {
      // Pr√ºft ob n ein "perfektes" Semiprime ist (Produkt zweier √§hnlich gro√üer Primzahlen)
      if (n < 6) return false;
      
      const factors = classicalTrialDivision(n);
      if (!factors) return false;
      
      const [p, q] = factors;
      // Pr√ºfe ob beide Faktoren prim sind und √§hnliche Gr√∂√üe haben
      const ratio = Math.max(p, q) / Math.min(p, q);
      return isProbablePrime(p) && isProbablePrime(q) && ratio < 10;
    }

    function runLimitTests(lang) {
      addFunctionHeader(lang, 'limit_tests', '‚ö†Ô∏è', 'tests');
      
      const texts = {
        de: {
          subtitle: "Systematische √úberpr√ºfung der T0-Grenzen",
          testNames: {
            large_primes: "Gro√üe Primzahlen",
            power_of_two: "Zweierpotenzen", 
            mersenne: "Mersenne-Zahlen",
            carmichael: "Carmichael-Zahlen",
            rsa_keys: "Echte RSA-Schl√ºssel"
          }
        },
        en: {
          subtitle: "Systematic verification of T0 boundaries",
          testNames: {
            large_primes: "Large Primes",
            power_of_two: "Powers of Two",
            mersenne: "Mersenne Numbers", 
            carmichael: "Carmichael Numbers",
            rsa_keys: "Real RSA Keys"
          }
        }
      };

      const t = texts[lang];
      appendResult(lang, `üîß ${t.subtitle}`);
      appendResult(lang, "=" * 60);

      // Test 1: Gro√üe Primzahlen (sollten versagen)
      appendResult(lang, `\nüìä Test 1: ${t.testNames.large_primes}`);
      appendResult(lang, `  Erwartung: T0 sollte versagen (Primzahlen nicht faktorisierbar)`);
      const largePrimes = [1009, 1013, 1019, 1021, 1031];
      runTestSeries(lang, largePrimes, "large_primes");

      // Test 2: Zweierpotenzen (mathematisch problematisch)
      setTimeout(() => {
        appendResult(lang, `\nüìä Test 2: ${t.testNames.power_of_two}`);
        appendResult(lang, `  Erwartung: Mathematisch schwierig f√ºr T0-Resonanz`);
        const powersOfTwo = [64, 128, 256, 512, 1024];
        runTestSeries(lang, powersOfTwo, "powers_of_two");
      }, 2000);

      // Test 3: Mersenne-Zahlen (sehr schwer)
      setTimeout(() => {
        appendResult(lang, `\nüìä Test 3: ${t.testNames.mersenne}`);
        appendResult(lang, `  Erwartung: Extrem schwer, meist Primzahlen`);
        const mersenneNumbers = [127, 8191, 131071]; // 2^7-1, 2^13-1, 2^17-1
        runTestSeries(lang, mersenneNumbers, "mersenne");
      }, 4000);

      // Test 4: Carmichael-Zahlen (Pseudoprimzahlen)
      setTimeout(() => {
        appendResult(lang, `\nüìä Test 4: ${t.testNames.carmichael}`);
        appendResult(lang, `  Erwartung: Schwierig f√ºr T0-Periodensuche`);
        const carmichaelNumbers = [561, 1105, 1729, 2465];
        runTestSeries(lang, carmichaelNumbers, "carmichael");
      }, 6000);

      // Test 5: Echte RSA-Challenges
      setTimeout(() => {
        appendResult(lang, `\nüìä Test 5: ${t.testNames.rsa_keys}`);
        appendResult(lang, `  Erwartung: Gemischte Ergebnisse je nach Gr√∂√üe`);
        const rsaChallenges = [21, 143, 323, 667, 899]; // Kleine RSA-√§hnliche
        runTestSeries(lang, rsaChallenges, "rsa_challenges");
      }, 8000);

      // Zusammenfassung
      setTimeout(() => {
        appendResult(lang, `\nüéØ GRENZEN-TESTS ABGESCHLOSSEN`);
        appendResult(lang, `\nüìä T0-Framework Grenzen best√§tigt:`);
        appendResult(lang, `  ‚ùå Primzahlen: Erwartungsgem√§√ü nicht faktorisierbar`);
        appendResult(lang, `  ‚ùå Zweierpotenzen: Resonanz-Probleme`);
        appendResult(lang, `  ‚ùå Mersenne-Zahlen: Meist prim, sehr schwer`);
        appendResult(lang, `  ‚ö†Ô∏è Carmichael-Zahlen: Pseudoprimzahl-Herausforderung`);
        appendResult(lang, `  ‚úÖ Kleine RSA: Teilweise erfolgreich`);
        appendResult(lang, `\nüí° Diese Grenzen sind fundamental f√ºr T0-Physik!`);
      }, 10000);
    }

    function runFailureTests(lang) {
      addFunctionHeader(lang, 'failure_tests', 'üí•', 'tests');
      
      const texts = {
        de: {
          subtitle: "Aufdeckung kritischer T0-Versagensszenarien",
          edge_cases: "Rand-F√§lle",
          pathological: "Pathologische Zahlen",
          xi_limits: "Œæ-Parameter Grenzen"
        },
        en: {
          subtitle: "Revealing critical T0 failure scenarios",
          edge_cases: "Edge Cases",
          pathological: "Pathological Numbers",
          xi_limits: "Œæ Parameter Limits"
        }
      };

      const t = texts[lang];
      appendResult(lang, `üîß ${t.subtitle}`);
      appendResult(lang, "=" * 60);

      // Test verschiedene Œæ-Parameter
      appendResult(lang, `\nüîç ${t.xi_limits}:`);
      appendResult(lang, `  Teste Œæ-Sensitivit√§t mit N=77 (7√ó11)`);
      const xiValues = [1e-3, 1e-4, 1e-5, 1e-6, 1e-7, 1e-8];
      const testNumber = 77; // 7 √ó 11

      xiValues.forEach((xi, index) => {
        setTimeout(() => {
          const simulator = new T0FrameworkSimulator(testNumber, false, false);
          simulator.xi = xi;
          const result = simulator.pureT0ShorAlgorithm();
          
          const status = result.success ? '‚úÖ' : '‚ùå';
          appendResult(lang, `  Œæ = ${xi.toExponential(0)}: ${status} ${result.method}`);
          if (result.success && result.factors) {
            appendResult(lang, `   Faktoren: ${result.factors[0]} √ó ${result.factors[1]}`);
          }
        }, index * 1000);
      });

      // Pathologische Zahlen
      setTimeout(() => {
        appendResult(lang, `\nüîç ${t.pathological}:`);
        appendResult(lang, `  Teste mathematisch problematische F√§lle`);
        const pathologicalNumbers = [
          {n: 1, desc: "Trivial (1)"},
          {n: 4, desc: "Quadrat (2¬≤)"},
          {n: 9, desc: "Quadrat (3¬≤)"},
          {n: 25, desc: "Quadrat (5¬≤)"},
          {n: 49, desc: "Quadrat (7¬≤)"},
          {n: 121, desc: "Quadrat (11¬≤)"}
        ];

        pathologicalNumbers.forEach((test, index) => {
          setTimeout(() => {
            const simulator = new T0FrameworkSimulator(test.n, false, false);
            const result = simulator.pureT0ShorAlgorithm();
            const status = result.success ? '‚úÖ' : '‚ùå';
            appendResult(lang, `  ${test.desc}: ${status} ${result.method}`);
            if (result.success && result.factors) {
              appendResult(lang, `   ‚Üí ${result.factors[0]} √ó ${result.factors[1]}`);
            }
          }, index * 800);
        });
      }, 7000);

      // Rand-F√§lle
      setTimeout(() => {
        appendResult(lang, `\nüîç ${t.edge_cases}:`);
        appendResult(lang, `  Teste Minimal- und Grenzf√§lle`);
        const edgeCases = [
          {n: 2, desc: "Kleinste Primzahl"},
          {n: 3, desc: "Zweitkleinste Primzahl"},
          {n: 6, desc: "2√ó3 (kleinste zusammengesetzte)"},
          {n: 10, desc: "2√ó5"},
          {n: 14, desc: "2√ó7"},
          {n: 22, desc: "2√ó11"}
        ];

        edgeCases.forEach((test, index) => {
          setTimeout(() => {
            const simulator = new T0FrameworkSimulator(test.n, false, false);
            const result = simulator.pureT0ShorAlgorithm();
            const status = result.success ? '‚úÖ' : '‚ùå';
            appendResult(lang, `  ${test.desc}: ${status} ${result.method}`);
            if (result.success && result.factors) {
              appendResult(lang, `   ‚Üí ${result.factors[0]} √ó ${result.factors[1]}`);
            }
          }, index * 800);
        });
      }, 12000);

      // Schw√§chen-Analyse
      setTimeout(() => {
        appendResult(lang, `\nüö® KRITISCHE T0-SCHW√ÑCHEN IDENTIFIZIERT:`);
        appendResult(lang, `\n‚ùå Fundamentale Versagensf√§lle:`);
        appendResult(lang, `  ‚Ä¢ Primzahlen: Keine Faktoren existieren`);
        appendResult(lang, `  ‚Ä¢ Quadratzahlen: Resonanz-St√∂rungen`);
        appendResult(lang, `  ‚Ä¢ Sehr kleine N: Triviale F√§lle`);
        appendResult(lang, `\n‚ö†Ô∏è Œæ-Parameter Sensitivit√§t:`);
        appendResult(lang, `  ‚Ä¢ Starke Abh√§ngigkeit von Œæ-Wert`);
        appendResult(lang, `  ‚Ä¢ Optimaler Bereich: 1e-6 bis 1e-4`);
        appendResult(lang, `  ‚Ä¢ Au√üerhalb: Resonanz-Zusammenbruch`);
        appendResult(lang, `\nüî¨ T0-Physik Grenzen:`);
        appendResult(lang, `  ‚Ä¢ Deterministische Natur = Vorhersagbare Schw√§chen`);
        appendResult(lang, `  ‚Ä¢ Energiefeld-Kopplung nicht universell`);
        appendResult(lang, `  ‚Ä¢ Klassische Backup-Methoden notwendig`);
      }, 18000);
    }

    function runStressTests(lang) {
      addFunctionHeader(lang, 'stress_tests', 'üî•', 'tests');
      
      const texts = {
        de: {
          subtitle: "Belastungstests f√ºr T0-Framework",
          sequential: "Sequenzielle Tests",
          random: "Zuf√§llige Zahlen",
          performance: "Performance-Analyse"
        },
        en: {
          subtitle: "Load testing for T0 framework", 
          sequential: "Sequential Tests",
          random: "Random Numbers",
          performance: "Performance Analysis"
        }
      };

      const t = texts[lang];
      appendResult(lang, `üîß ${t.subtitle}`);
      appendResult(lang, "=" * 60);

      let successCount = 0;
      let totalTests = 0;

      // Sequenzielle Tests
      appendResult(lang, `\nüîÑ ${t.sequential} (N = 15-50):`);
      appendResult(lang, `  Systematischer Test aller zusammengesetzten Zahlen`);
      
      const compositeNumbers = [];
      for (let n = 15; n <= 50; n++) {
        if (n > 1 && !isPrime(n)) {
          compositeNumbers.push(n);
        }
      }

      compositeNumbers.forEach((n, index) => {
        setTimeout(() => {
          const simulator = new T0FrameworkSimulator(n, false, false);
          const result = simulator.pureT0ShorAlgorithm();
          totalTests++;
          if (result.success) successCount++;
          
          const status = result.success ? '‚úÖ' : '‚ùå';
          appendResult(lang, `  N=${n}: ${status} ${result.method} (${result.time?.toFixed(3)}s)`);
          
          if (result.success && result.factors) {
            appendResult(lang, `   ‚Üí ${result.factors[0]} √ó ${result.factors[1]}`);
          }
          
          if (index === compositeNumbers.length - 1) {
            setTimeout(() => {
              const rate = (successCount / totalTests * 100).toFixed(1);
              appendResult(lang, `\nüìä Sequenzielle Erfolgsrate / Sequential Success Rate: ${successCount}/${totalTests} (${rate}%)`);
              
              // Reset f√ºr n√§chste Tests
              successCount = 0;
              totalTests = 0;
              runRandomStressTests(lang);
            }, 500);
          }
        }, index * 400);
      });
    }

    function runRandomStressTests(lang) {
      const texts = {
        de: { random: "Zuf√§llige Zahlen", performance: "Performance-Analyse" },
        en: { random: "Random Numbers", performance: "Performance Analysis" }
      };

      appendResult(lang, `\nüé≤ ${texts[lang].random} (20 Tests):`);
      appendResult(lang, `  Generiere zuf√§llige Semiprimes f√ºr Stress-Test`);
      
      let successCount = 0;
      let totalTime = 0;
      const testCount = 20;

      for (let i = 0; i < testCount; i++) {
        setTimeout(() => {
          // Generiere zuf√§llige semiprime Zahl
          const primes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
          const p1 = primes[Math.floor(Math.random() * primes.length)];
          const p2 = primes[Math.floor(Math.random() * primes.length)];
          const n = p1 * p2;

          const simulator = new T0FrameworkSimulator(n, false, false);
          const startTime = Date.now();
          const result = simulator.pureT0ShorAlgorithm();
          const duration = (Date.now() - startTime) / 1000;
          
          totalTime += duration;
          if (result.success) successCount++;
          
          const status = result.success ? '‚úÖ' : '‚ùå';
          appendResult(lang, `  ${p1}√ó${p2}=${n}: ${status} ${result.method} (${duration.toFixed(3)}s)`);
          
          if (i === testCount - 1) {
            setTimeout(() => {
              const rate = (successCount / testCount * 100).toFixed(1);
              const avgTime = (totalTime / testCount).toFixed(3);
              appendResult(lang, `\nüìä ${texts[lang].performance}:`);
              appendResult(lang, `  Erfolgsrate / Success Rate: ${successCount}/${testCount} (${rate}%)`);
              appendResult(lang, `  ‚è±Ô∏è Durchschnittszeit / Avg Time: ${avgTime}s`);
              appendResult(lang, `  üìà Gesamtzeit / Total Time: ${totalTime.toFixed(3)}s`);
              
              // Stress-Test Analyse
              appendResult(lang, `\nüî• STRESS-TEST ANALYSE:`);
              if (rate >= 80) {
                appendResult(lang, `  ‚úÖ T0 zeigt gute Stabilit√§t unter Stress`);
              } else if (rate >= 50) {
                appendResult(lang, `  ‚ö†Ô∏è T0 zeigt moderate Stabilit√§t`);
              } else {
                appendResult(lang, `  ‚ùå T0 zeigt Instabilit√§t unter Stress`);
              }
              
              appendResult(lang, `\nüí° Stress-Test Erkenntnisse:`);
              appendResult(lang, `  ‚Ä¢ Durchschnittszeit: ${avgTime}s pro Faktorisierung`);
              appendResult(lang, `  ‚Ä¢ Konsistenz: ${rate}% Erfolgsrate`);
              appendResult(lang, `  ‚Ä¢ Skalierung: ${totalTime.toFixed(1)}s f√ºr ${testCount} Tests`);
              
              if (avgTime > 2.0) {
                appendResult(lang, `  ‚ö†Ô∏è Performance-Problem: Langsame Berechnungen`);
              }
              if (rate < 70) {
                appendResult(lang, `  ‚ö†Ô∏è Zuverl√§ssigkeits-Problem: Niedrige Erfolgsrate`);
              }
            }, 500);
          }
        }, i * 600);
      }
    }

    function runBenchmarkSeries(lang) {
      addFunctionHeader(lang, 'benchmark', 'üìä', 'benchmark');
      
      const texts = {
        de: {
          subtitle: "Systematische Leistungsmessung",
          comparison: "T0 vs Standard-Methoden Vergleich",
          theoretical: "Theoretische Grenzen",
          practical: "Praktische Leistung"
        },
        en: {
          subtitle: "Systematic performance measurement",
          comparison: "T0 vs Standard Methods Comparison",
          theoretical: "Theoretical Limits",
          practical: "Practical Performance"
        }
      };

      const t = texts[lang];
      appendResult(lang, `üîß ${t.subtitle}`);
      appendResult(lang, "=" * 60);

      // Benchmark verschiedener Gr√∂√üenordnungen
      const benchmarkSets = [
        {name: "Micro (2-4 bit)", numbers: [6, 10, 14, 15]},
        {name: "Small (5-6 bit)", numbers: [21, 33, 35, 39]}, 
        {name: "Medium (7-8 bit)", numbers: [77, 91, 93, 95]},
        {name: "Large (9-10 bit)", numbers: [143, 187, 209, 247]},
        {name: "XLarge (11-12 bit)", numbers: [323, 391, 437, 493]}
      ];

      appendResult(lang, `\nüèÅ Starte Benchmark-Serie mit ${benchmarkSets.length} Kategorien`);

      benchmarkSets.forEach((set, setIndex) => {
        setTimeout(() => {
          appendResult(lang, `\nüìä ${set.name}:`);
          appendResult(lang, `  Teste: ${set.numbers.join(', ')}`);
          
          let setSuccesses = 0;
          let setTotalTime = 0;
          let setT0Time = 0;
          let setClassicTime = 0;

          set.numbers.forEach((n, numIndex) => {
            setTimeout(() => {
              // T0 Test
              const t0Simulator = new T0FrameworkSimulator(n, false, false);
              const t0Start = Date.now();
              const t0Result = t0Simulator.pureT0ShorAlgorithm();
              const t0Time = (Date.now() - t0Start) / 1000;

              // Klassische Trial Division zum Vergleich
              const classicStart = Date.now();
              const classicResult = classicalTrialDivision(n);
              const classicTime = (Date.now() - classicStart) / 1000;

              setTotalTime += t0Time;
              setT0Time += t0Time;
              setClassicTime += classicTime;
              if (t0Result.success) setSuccesses++;

              const speedup = classicTime > 0 ? (classicTime / t0Time).toFixed(1) : 'N/A';
              const t0Status = t0Result.success ? '‚úÖ' : '‚ùå';
              const classicStatus = classicResult ? '‚úÖ' : '‚ùå';

              appendResult(lang, `  N=${n}:`);
              appendResult(lang, `   T0:   ${t0Status} ${t0Time.toFixed(3)}s (${t0Result.method})`);
              appendResult(lang, `   Classic: ${classicStatus} ${classicTime.toFixed(3)}s`);
              appendResult(lang, `   Speedup: ${speedup}x`);

              if (t0Result.success && t0Result.factors) {
                appendResult(lang, `   Factors: ${t0Result.factors[0]} √ó ${t0Result.factors[1]}`);
              }

              // Am Ende des Sets Zusammenfassung
              if (numIndex === set.numbers.length - 1) {
                setTimeout(() => {
                  const setRate = (setSuccesses / set.numbers.length * 100).toFixed(1);
                  const avgT0Time = (setT0Time / set.numbers.length).toFixed(3);
                  const avgClassicTime = (setClassicTime / set.numbers.length).toFixed(3);
                  const overallSpeedup = (setClassicTime / setT0Time).toFixed(1);
                  
                  appendResult(lang, `  üìà ${set.name} Zusammenfassung:`);
                  appendResult(lang, `   T0 Erfolgsrate: ${setSuccesses}/${set.numbers.length} (${setRate}%)`);
                  appendResult(lang, `   Durchschnitt T0: ${avgT0Time}s`);
                  appendResult(lang, `   Durchschnitt Classic: ${avgClassicTime}s`);
                  appendResult(lang, `   Gesamt-Speedup: ${overallSpeedup}x`);
                }, 200);
              }
            }, numIndex * 1000);
          });
        }, setIndex * 5000);
      });

      // Finale Analyse
      setTimeout(() => {
        appendResult(lang, `\nüéØ ${t.theoretical}:`);
        appendResult(lang, `  üìö Komplexit√§ts-Vergleich:`);
        appendResult(lang, `  ‚Ä¢ T0-Shor: O(log¬≥N) - wenn Œæ-Resonanz funktioniert`);
        appendResult(lang, `  ‚Ä¢ Trial Division: O(‚àöN) - immer zuverl√§ssig`);
        appendResult(lang, `  ‚Ä¢ Klassisch Shor: O(log¬≥N) - probabilistisch`);
        appendResult(lang, `  ‚Ä¢ Quantenvorteil: Nur bei sehr gro√üen N erkennbar`);
        
        appendResult(lang, `\n‚ö†Ô∏è Kritische T0-Grenzen best√§tigt:`);
        appendResult(lang, `  ‚ùå Primzahlen: Versagen erwartet (mathematisch korrekt)`);
        appendResult(lang, `  ‚ùå Quadratzahlen: Mathematisch problematisch`);
        appendResult(lang, `  ‚ö†Ô∏è Œæ-Abh√§ngigkeit: Sehr sensitiv auf Parameter`);
        appendResult(lang, `  üìâ Gro√üe Zahlen: Resonanz wird schw√§cher`);
        appendResult(lang, `  üéØ Optimaler Bereich: 15-500 (kleine RSA)`);
        
        appendResult(lang, `\nüèÜ BENCHMARK-SERIE ABGESCHLOSSEN`);
        appendResult(lang, `\nüí° Schlussfolgerungen:`);
        appendResult(lang, `  ‚úÖ T0 funktioniert f√ºr kleine Semiprimes`);
        appendResult(lang, `  ‚ö†Ô∏è Klassische Fallbacks oft notwendig`);
        appendResult(lang, `  üìä Speedup bei erfolgreichen T0-F√§llen sichtbar`);
        appendResult(lang, `  üî¨ T0-Physik zeigt erwartete Grenzen`);
      }, benchmarkSets.length * 5000 + 2000);
    }

    function runTestSeries(lang, numbers, testType) {
      let successCount = 0;
      
      numbers.forEach((n, index) => {
        setTimeout(() => {
          const simulator = new T0FrameworkSimulator(n, false, false); // Pure T0, no fallback
          const result = simulator.pureT0ShorAlgorithm();
          
          const status = result.success ? '‚úÖ Erfolg' : '‚ùå Versagen';
          const statusEn = result.success ? '‚úÖ Success' : '‚ùå Failure';
          
          if (result.success) successCount++;
          
          const displayStatus = lang === 'de' ? status : statusEn;
          appendResult(lang, `  N=${n}: ${displayStatus} (${result.method})`);
          
          if (result.success && result.factors) {
            appendResult(lang, `   ‚Üí ${result.factors[0]} √ó ${result.factors[1]}`);
          }
          
          // Zeige Erfolgsrate am Ende
          if (index === numbers.length - 1) {
            setTimeout(() => {
              const rate = (successCount / numbers.length * 100).toFixed(1);
              const summary = lang === 'de' ? 
                `üìä Erfolgsrate: ${successCount}/${numbers.length} (${rate}%)` :
                `üìä Success Rate: ${successCount}/${numbers.length} (${rate}%)`;
              appendResult(lang, `  ${summary}`);
            }, 500);
          }
        }, index * 800);
      });
    }

    function clearResults(lang) {
      const resultsDiv = document.getElementById(`results-${lang}`);
      resultsDiv.innerHTML = lang === 'de' ? 
        '<strong>üî¨ T0-Simulator Ergebnisse:</strong><br>Bereit f√ºr T0-Framework Berechnungen...<br><br><em>Hinweise:</em><br>‚Ä¢ Pure T0 (ohne Fallback) zeigt echte T0-Physik<br>‚Ä¢ Kleine Zahlen (15, 21, 35) f√ºr schnelle Tests<br>‚Ä¢ Gro√üe Zahlen (>1000) f√ºr realistische RSA-Simulation<br>‚Ä¢ Œæ-Parameter bestimmt Energiefeld-Kopplungsst√§rke<br>‚Ä¢ T0 nutzt KEINE klassischen Qubits - nur Energiefelder!<br>' :
        '<strong>üî¨ T0 Simulator Results:</strong><br>Ready for T0-Framework calculations...<br><br><em>Notes:</em><br>‚Ä¢ Pure T0 (no fallback) shows true T0 physics<br>‚Ä¢ Small numbers (15, 21, 35) for quick tests<br>‚Ä¢ Large numbers (>1000) for realistic RSA simulation<br>‚Ä¢ Œæ parameter determines energy field coupling strength<br>‚Ä¢ T0 uses NO classical qubits - only energy fields!<br>';
      
      document.getElementById(`energy-field-${lang}`).style.display = 'none';
      
      // Reset statistics
      simulatorState.successCount = 0;
      simulatorState.totalRuns = 0;
      updateStatisticsDisplay(lang);
    }

    function appendResult(lang, text) {
      const resultsDiv = document.getElementById(`results-${lang}`);
      resultsDiv.innerHTML += text + '<br>';
      resultsDiv.scrollTop = resultsDiv.scrollHeight;
    }

    function updateStatistics(lang, simulator) {
      simulatorState.xi = simulator.xi;
      updateStatisticsDisplay(lang);
    }

    function updateStatisticsDisplay(lang) {
      const rsaNumber = document.getElementById(`rsa-number-${lang}`).value;
      const successRate = simulatorState.totalRuns > 0 ? 
        (simulatorState.successCount / simulatorState.totalRuns * 100).toFixed(1) + '%' : '-';

      document.getElementById(`current-n-${lang}`).textContent = rsaNumber || '-';
      document.getElementById(`current-xi-${lang}`).textContent = simulatorState.xi.toExponential(1);
      document.getElementById(`success-rate-${lang}`).textContent = successRate;
    }

    function isPrime(n) {
      if (n < 2) return false;
      if (n === 2) return true;
      if (n % 2 === 0) return false;
      for (let i = 3; i <= Math.sqrt(n); i += 2) {
        if (n % i === 0) return false;
      }
      return true;
    }

    function classicalTrialDivision(n) {
      if (n < 2) return null;
      for (let i = 2; i <= Math.sqrt(n); i++) {
        if (n % i === 0) {
          return [i, n / i];
        }
      }
      return null; // Prime
    }

    // Initialize with sample calculation
    window.addEventListener('load', () => {
      // Auto-run a sample for demonstration
      setTimeout(() => {
        if (currentLang === 'de') {
          appendResult('de', 'üí° Willkommen im T0-Simulator! Klicken Sie "T0-Shor starten" f√ºr eine Demo.');
          appendResult('de', '‚ö†Ô∏è Nutzen Sie "Grenzen-Tests" um T0-Schw√§chen zu erkunden.');
          appendResult('de', 'üî¨ Alle Funktionen sind vollst√§ndig wie im Python-Code implementiert.');
        } else {
          appendResult('en', 'üí° Welcome to T0 Simulator! Click "Run T0-Shor" for a demo.');
          appendResult('en', '‚ö†Ô∏è Use "Limit Tests" to explore T0 weaknesses.');
          appendResult('en', 'üî¨ All functions are fully implemented as in Python code.');
        }
      }, 1000);
    });
  </script>
</body>
</html>
            
