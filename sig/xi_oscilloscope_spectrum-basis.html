<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î¾-Oszilloskop mit Spektrum-Analyzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(102,126,234,0.3);
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .header h1 {
            font-size: 2.4em;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            position: relative;
            z-index: 1;
        }
        
        .header p {
            position: relative;
            z-index: 1;
            opacity: 0.9;
        }
        
        .main-container {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            padding: 20px;
            max-width: 1900px;
            margin: 0 auto;
            min-height: calc(100vh - 140px);
        }
        
        .display-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .oscilloscope-section {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            flex: 1;
        }
        
        .spectrum-section {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            flex: 1;
        }
        
        .controls-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            max-height: calc(100vh - 160px);
        }
        
        .control-group {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        
        .control-group:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            border-color: rgba(102,126,234,0.3);
        }
        
        .canvas-container {
            position: relative;
            flex: 1;
            background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);
            border-radius: 15px;
            border: 2px solid #667eea;
            margin-bottom: 15px;
            overflow: hidden;
            min-height: 300px;
            box-shadow: 0 0 20px rgba(102,126,234,0.3);
        }
        
        .spectrum-container {
            position: relative;
            flex: 1;
            background: linear-gradient(135deg, #001122 0%, #112233 100%);
            border-radius: 15px;
            border: 2px solid #00ff88;
            overflow: hidden;
            min-height: 300px;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
        }
        
        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 5px 0;
        }
        
        .canvas-title {
            color: #00ff41;
            font-size: 1.2em;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0,255,65,0.5);
        }
        
        .spectrum-title {
            color: #00ff88;
            font-size: 1.2em;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0,255,136,0.5);
        }
        
        .canvas-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .control-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-item label {
            color: #ffd700;
            font-size: 0.85em;
            white-space: nowrap;
            text-shadow: 0 0 5px rgba(255,215,0,0.3);
        }
        
        .slider {
            width: 100px;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .slider:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3), 0 0 10px rgba(102,126,234,0.4);
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4), 0 0 15px rgba(102,126,234,0.6);
        }
        
        .value-display {
            color: #32cd32;
            font-weight: bold;
            min-width: 70px;
            font-size: 0.85em;
            text-shadow: 0 0 5px rgba(50,205,50,0.3);
        }
        
        .btn {
            padding: 10px 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.85em;
            transition: all 0.3s ease;
            color: white;
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .btn-success { background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%); }
        .btn-warning { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .btn-danger { background: linear-gradient(135deg, #ff4757 0%, #ff3742 100%); }
        .btn-info { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .section-title {
            color: #667eea;
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px rgba(102,126,234,0.5);
        }
        
        .mode-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.85em;
            position: relative;
        }
        
        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: 0 4px 15px rgba(102,126,234,0.3);
            transform: translateY(-1px);
        }
        
        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            background: rgba(255,255,255,0.15);
        }
        
        .mode-btn.active:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .spectrum-mode-btn {
            background: rgba(0,255,136,0.1);
            border: 1px solid rgba(0,255,136,0.3);
        }
        
        .spectrum-mode-btn.active {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #000;
        }
        
        .generator-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 15px;
        }
        
        .freq-control {
            grid-column: span 2;
            text-align: center;
            padding: 15px;
            background: rgba(102,126,234,0.15);
            border-radius: 10px;
            border: 1px solid rgba(102,126,234,0.3);
            box-shadow: 0 4px 12px rgba(102,126,234,0.1);
        }
        
        .freq-display {
            font-size: 1.8em;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
            text-shadow: 0 0 10px rgba(102,126,234,0.5);
        }
        
        .slider-container {
            margin-top: 10px;
        }
        
        .slider-value {
            text-align: center;
            font-size: 0.85em;
            color: #32cd32;
            font-weight: bold;
            margin-top: 6px;
            text-shadow: 0 0 5px rgba(50,205,50,0.3);
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .log-container {
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            overflow-y: auto;
            color: #32cd32;
            height: 160px;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .status-display {
            background: linear-gradient(135deg, #2ed573 0%, #17a2b8 100%);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 20px;
            font-size: 1em;
            box-shadow: 0 4px 15px rgba(46,213,115,0.3);
            transition: all 0.3s ease;
            position: relative;
        }
        
        .status-display .fps-indicator {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 0.7em;
            opacity: 0.8;
            color: #ffffff;
        }
        
        .control-item-full {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .control-item-full label {
            font-weight: bold;
            color: #ffd700;
            font-size: 0.9em;
            text-shadow: 0 0 5px rgba(255,215,0,0.3);
        }
        
        .control-item-full .slider {
            width: 100%;
        }
        
        .signal-info-panel {
            background: rgba(255,215,0,0.1);
            border: 1px solid rgba(255,215,0,0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            box-shadow: 0 4px 12px rgba(255,215,0,0.1);
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9em;
        }
        
        .info-row:last-child {
            border-bottom: none;
        }
        
        .info-value {
            color: #ffd700;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255,215,0,0.3);
        }

        .mic-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .mic-level-display {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .mic-level-bar {
            width: 100%;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 8px 0;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .mic-level-indicator {
            height: 100%;
            background: linear-gradient(90deg, #32cd32 0%, #ffa500 70%, #ff4757 100%);
            width: 0%;
            transition: width 0.1s ease;
            border-radius: 5px;
            box-shadow: 0 0 8px rgba(50,205,50,0.5);
        }
        
        .frequency-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid rgba(0,255,65,0.4);
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0,255,65,0.6);
            backdrop-filter: blur(5px);
        }

        .spectrum-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid rgba(0,255,136,0.4);
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0,255,136,0.6);
            backdrop-filter: blur(5px);
            font-size: 0.9em;
        }

        .xi-analysis-panel {
            background: rgba(50,205,50,0.1);
            border: 1px solid rgba(50,205,50,0.3);
            border-radius: 10px;
            padding: 12px;
            margin-top: 10px;
            font-size: 0.85em;
        }
        
        .xi-analysis-panel h4 {
            color: #32cd32;
            margin-bottom: 8px;
            text-shadow: 0 0 5px rgba(50,205,50,0.5);
        }

        .profile-selector {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .profile-btn {
            width: 100%;
            padding: 8px;
            margin: 2px 0;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8em;
        }

        .profile-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .performance-panel {
            background: rgba(0,255,255,0.1);
            border: 1px solid rgba(0,255,255,0.3);
            border-radius: 10px;
            padding: 12px;
            margin-top: 10px;
        }

        .performance-panel h4 {
            color: #00ffff;
            margin-bottom: 8px;
            text-shadow: 0 0 5px rgba(0,255,255,0.5);
        }

        .spectrum-controls {
            background: rgba(0,255,136,0.1);
            border: 1px solid rgba(0,255,136,0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .spectrum-controls h4 {
            color: #00ff88;
            margin-bottom: 12px;
            text-shadow: 0 0 5px rgba(0,255,136,0.5);
        }
        
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .display-section {
                grid-template-columns: 1fr;
            }
            
            .generator-controls {
                grid-template-columns: 1fr;
            }
            
            .freq-control {
                grid-column: span 1;
            }
            
            .canvas-controls {
                flex-wrap: wrap;
                gap: 10px;
            }
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .main-container {
                padding: 10px;
            }
            
            .action-buttons {
                grid-template-columns: 1fr;
            }
            
            .mode-selector {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ð¬ Î¾-Oszilloskop mit Spektrum-Analyzer</h1>
        <p>Î¾-Harmonic Analyzer v2.0 â¢ Autokorrelations-basiert â¢ Harmonik-Analyse â¢ FFT-Spektrum â¢ Real-time</p>
    </div>

    <div class="status-display" id="statusDisplay">
        ð Î¾-Oszilloskop mit Spektrum-Analyzer wird initialisiert...
        <div class="fps-indicator" id="fpsIndicator">FPS: --</div>
    </div>

    <div class="main-container">
        <div class="display-section">
            <div class="oscilloscope-section">
                <div class="canvas-header">
                    <h3 class="canvas-title">ð Oszilloskop</h3>
                    <div class="canvas-controls">
                        <div class="control-item">
                            <label>Zeitbereich:</label>
                            <input type="range" class="slider" id="timeRangeSlider" 
                                   min="10" max="1000" step="10" value="100">
                            <span id="timeRangeValue" class="value-display">100 ms</span>
                        </div>
                        <div class="control-item">
                            <label>Amplitude:</label>
                            <input type="range" class="slider" id="amplitudeSlider" 
                                   min="0.1" max="3.0" step="0.1" value="1.0">
                            <span id="amplitudeValue" class="value-display">1.0x</span>
                        </div>
                    </div>
                </div>
                
                <div class="canvas-container">
                    <canvas id="oscilloscopeCanvas"></canvas>
                    <div class="frequency-indicator" id="frequencyIndicator">fâ: --- Hz</div>
                </div>
            </div>

            <div class="spectrum-section">
                <div class="canvas-header">
                    <h3 class="spectrum-title">ð Spektrum-Analyzer</h3>
                    <div class="canvas-controls">
                        <div class="mode-selector">
                            <button class="mode-btn spectrum-mode-btn active" id="fftModeBtn" data-spectrum="fft">FFT</button>
                            <button class="mode-btn spectrum-mode-btn" id="xiModeBtn" data-spectrum="xi">Î¾-Harmonic</button>
                            <button class="mode-btn spectrum-mode-btn" id="waterfallModeBtn" data-spectrum="waterfall">Waterfall</button>
                        </div>
                        <div class="control-item">
                            <label>Freq-Range:</label>
                            <input type="range" class="slider" id="freqRangeSlider" 
                                   min="100" max="8000" step="100" value="2000">
                            <span id="freqRangeValue" class="value-display">2000 Hz</span>
                        </div>
                        <div class="control-item">
                            <label>dB-Range:</label>
                            <input type="range" class="slider" id="dbRangeSlider" 
                                   min="40" max="120" step="10" value="80">
                            <span id="dbRangeValue" class="value-display">80 dB</span>
                        </div>
                    </div>
                </div>
                
                <div class="spectrum-container">
                    <canvas id="spectrumCanvas"></canvas>
                    <div class="spectrum-info" id="spectrumInfo">Modus: FFT | 0 Peaks</div>
                </div>
            </div>
            
            <div class="xi-analysis-panel" id="xiAnalysisPanel">
                <h4>ðµ Î¾-Harmonic Analyzer</h4>
                <div class="info-row">
                    <span>Erkannte Perioden:</span>
                    <span class="info-value" id="detectedPeriods">---</span>
                </div>
                <div class="info-row">
                    <span>Dominante Frequenz:</span>
                    <span class="info-value" id="dominantFrequency">---</span>
                </div>
                <div class="info-row">
                    <span>Î¾-Ratios gefunden:</span>
                    <span class="info-value" id="xiRatiosCount">---</span>
                </div>
                <div class="info-row">
                    <span>Analyse-Zeit:</span>
                    <span class="info-value" id="analysisTime">---</span>
                </div>
                <div class="info-row">
                    <span>Strategie:</span>
                    <span class="info-value" id="engineStrategy">---</span>
                </div>
            </div>

            <div class="performance-panel" id="performancePanel">
                <h4>â¡ Analyzer Performance</h4>
                <div class="info-row">
                    <span>Profil:</span>
                    <span class="info-value" id="currentProfile">---</span>
                </div>
                <div class="info-row">
                    <span>Cache Hits:</span>
                    <span class="info-value" id="cacheHits">---</span>
                </div>
                <div class="info-row">
                    <span>FFT-GrÃ¶Ãe:</span>
                    <span class="info-value" id="fftSize">---</span>
                </div>
                <div class="info-row">
                    <span>Spektrum-Modus:</span>
                    <span class="info-value" id="spectrumMode">FFT</span>
                </div>
            </div>
            
            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h3 style="color: #32cd32; font-size: 1.1em; margin: 0;">Î¾-Harmonic Analyzer Log</h3>
                    <button class="btn btn-success" id="saveLogBtn" style="padding: 8px 12px; font-size: 0.8em;">ð¾ Log speichern</button>
                </div>
                
                <div class="log-container" id="logContainer">
                    === Î¾-OSZILLOSKOP mit SPEKTRUM-ANALYZER ===<br>
                    System bereit fÃ¼r Autokorrelations-basierte Harmonik-Analyse...<br>
                </div>
            </div>
        </div>

        <div class="controls-panel">
            <div class="control-group">
                <h3 class="section-title">ð¯ Î¾-Harmonic Profile</h3>
                
                <div class="profile-selector">
                    <button class="profile-btn active" id="realtimeProfile" data-profile="realtime">â¡ Real-time</button>
                    <button class="profile-btn" id="balancedProfile" data-profile="balanced">âï¸ Balanced</button>
                    <button class="profile-btn" id="qualityProfile" data-profile="quality">ð¯ Quality</button>
                    <button class="profile-btn" id="researchProfile" data-profile="research">ð¬ Research</button>
                </div>
            </div>

            <div class="control-group">
                <h3 class="section-title">ð Spektrum Einstellungen</h3>
                
                <div class="spectrum-controls">
                    <h4>FFT Konfiguration</h4>
                    <div class="control-item-full">
                        <label>ð FFT-GrÃ¶Ãe</label>
                        <input type="range" class="slider" id="fftSizeSlider" 
                               min="10" max="14" step="1" value="12">
                        <div class="slider-value" id="fftSizeValue">4096</div>
                    </div>
                    
                    <div class="control-item-full">
                        <label>ðª Fenster-Funktion</label>
                        <select id="windowFunction" style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3);">
                            <option value="hanning">Hanning</option>
                            <option value="hamming">Hamming</option>
                            <option value="blackman">Blackman</option>
                            <option value="rectangular">Rechteck</option>
                        </select>
                    </div>
                    
                    <div class="control-item-full">
                        <label>ð Averaging</label>
                        <input type="range" class="slider" id="averagingSlider" 
                               min="1" max="10" step="1" value="3">
                        <div class="slider-value" id="averagingValue">3 Frames</div>
                    </div>
                    
                    <div class="control-item-full">
                        <label>ð¨ Darstellung</label>
                        <select id="spectrumDisplay" style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3);">
                            <option value="magnitude">Magnitude</option>
                            <option value="power">Power</option>
                            <option value="db">dB Scale</option>
                            <option value="log">Log Scale</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3 class="section-title">ðï¸ Signal-Generator</h3>
                
                <div class="mode-selector">
                    <button class="mode-btn active" id="frequencyModeBtn" data-mode="frequency">Frequenz-Modus</button>
                    <button class="mode-btn" id="beatModeBtn" data-mode="beat">Differenzton-Modus</button>
                    <button class="mode-btn" id="harmonicModeBtn" data-mode="harmonic">Harmonik-Modus</button>
                </div>
                
                <div class="mode-selector" id="symmetrySelector" style="display: none;">
                    <button class="mode-btn active" id="symmetricBtn" data-symmetry="symmetric">Symmetrisch</button>
                    <button class="mode-btn" id="asymmetricBtn" data-symmetry="asymmetric">Asymmetrisch</button>
                </div>
                
                <div class="freq-control">
                    <label>ðµ Grundfrequenz fâ</label>
                    <div class="freq-display" id="baseFreqDisplay">440 Hz</div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="baseFreqSlider" 
                               min="80" max="2000" step="1" value="440" style="width: 100%;">
                        <div class="slider-value" id="baseFreqValue">440 Hz</div>
                    </div>
                    <div class="control-item-full" style="margin-top: 10px;">
                        <label>ð Amplitude fâ</label>
                        <input type="range" class="slider" id="baseAmpSlider" 
                               min="0" max="100" step="1" value="60">
                        <div class="slider-value" id="baseAmpValue">60%</div>
                    </div>
                </div>
                
                <div class="generator-controls">
                    <div id="frequencyControls">
                        <div class="control-item-full">
                            <label>ð½ Untere Frequenz fáµ¤</label>
                            <input type="range" class="slider" id="lowerFreqSlider" 
                                   min="80" max="2000" step="1" value="438">
                            <div class="slider-value" id="lowerFreqValue">438 Hz</div>
                            <div style="margin-top: 8px;">
                                <label style="font-size: 0.8em;">ð Amplitude fáµ¤</label>
                                <input type="range" class="slider" id="lowerAmpSlider" 
                                       min="0" max="100" step="1" value="30">
                                <div class="slider-value" id="lowerAmpValue">30%</div>
                            </div>
                        </div>
                        
                        <div class="control-item-full">
                            <label>ð¼ Obere Frequenz fâ</label>
                            <input type="range" class="slider" id="upperFreqSlider" 
                                   min="80" max="2000" step="1" value="442">
                            <div class="slider-value" id="upperFreqValue">442 Hz</div>
                            <div style="margin-top: 8px;">
                                <label style="font-size: 0.8em;">ð Amplitude fâ</label>
                                <input type="range" class="slider" id="upperAmpSlider" 
                                       min="0" max="100" step="1" value="30">
                                <div class="slider-value" id="upperAmpValue">30%</div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="beatControls" style="display: none;">
                        <div class="control-item-full">
                            <label>ð Differenzton fáµ¤âfâ</label>
                            <input type="range" class="slider" id="lowerBeatSlider" 
                                   min="0.1" max="50" step="0.1" value="2.0">
                            <div class="slider-value" id="lowerBeatValue">2.0 Hz</div>
                            <div style="margin-top: 8px;">
                                <label style="font-size: 0.8em;">ð Amplitude fáµ¤</label>
                                <input type="range" class="slider" id="lowerBeatAmpSlider" 
                                       min="0" max="100" step="1" value="30">
                                <div class="slider-value" id="lowerBeatAmpValue">30%</div>
                            </div>
                        </div>
                        
                        <div class="control-item-full">
                            <label>ð Differenzton fââfâ</label>
                            <input type="range" class="slider" id="upperBeatSlider" 
                                   min="0.1" max="50" step="0.1" value="2.0">
                            <div class="slider-value" id="upperBeatValue">2.0 Hz</div>
                            <div style="margin-top: 8px;">
                                <label style="font-size: 0.8em;">ð Amplitude fâ</label>
                                <input type="range" class="slider" id="upperBeatAmpSlider" 
                                       min="0" max="100" step="1" value="30">
                                <div class="slider-value" id="upperBeatAmpValue">30%</div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="harmonicControls" style="display: none;">
                        <div class="control-item-full">
                            <label>ð¼ Harmonische Anzahl</label>
                            <input type="range" class="slider" id="harmonicCountSlider" 
                                   min="2" max="8" step="1" value="4">
                            <div class="slider-value" id="harmonicCountValue">4</div>
                        </div>
                        
                        <div class="control-item-full">
                            <label>ð Harmonik-IntensitÃ¤t</label>
                            <input type="range" class="slider" id="harmonicIntensitySlider" 
                                   min="0.1" max="1.0" step="0.1" value="0.5">
                            <div class="slider-value" id="harmonicIntensityValue">0.5</div>
                        </div>
                    </div>
                </div>
                
                <div class="action-buttons">
                    <button class="btn btn-success" id="generateBtn">ðµ Signal erzeugen</button>
                    <button class="btn btn-primary" id="exportBtn">ð¾ WAV Export</button>
                    <button class="btn btn-warning" id="continuousBtn">ð Kontinuierlich</button>
                    <button class="btn btn-danger" id="stopContinuousBtn" style="display: none;">â¹ï¸ Stoppen</button>
                </div>
                
                <div class="signal-info-panel" id="signalInfo">
                    <div class="info-row">
                        <span>ðï¸ Signal-Typ:</span>
                        <span class="info-value" id="signalType">Bereit</span>
                    </div>
                    <div class="info-row">
                        <span>ðµ Frequenzen:</span>
                        <span class="info-value" id="signalFreqs">--- Hz</span>
                    </div>
                    <div class="info-row">
                        <span>ð¯ Grundfrequenz:</span>
                        <span class="info-value" id="detectedFundamental">--- Hz</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3 class="section-title">ð¤ Mikrofon-Eingabe</h3>
                
                <div class="mic-level-display">
                    <label>ð Live-Eingangspegel</label>
                    <div class="mic-level-bar">
                        <div class="mic-level-indicator" id="micLevelIndicator"></div>
                    </div>
                    <div id="micLevelText">0%</div>
                    <div id="clippingWarning" style="color: #ff4757; font-weight: bold; display: none;">â ï¸ CLIPPING ERKANNT!</div>
                </div>
                
                <div class="control-item-full">
                    <label>ð Mikrofon-Empfindlichkeit</label>
                    <input type="range" class="slider" id="micSensitivitySlider" 
                           min="0.1" max="3.0" step="0.1" value="1.3">
                    <div class="slider-value" id="micSensitivityValue">1.3x</div>
                </div>
                
                <div class="control-item-full">
                    <label>ð Noise Gate</label>
                    <input type="range" class="slider" id="noiseGateSlider" 
                           min="0.0" max="0.3" step="0.01" value="0.02">
                    <div class="slider-value" id="noiseGateValue">0.02</div>
                </div>
                
                <div class="mic-controls">
                    <button class="btn btn-success" id="micStartBtn">ð¤ Mikrofon aktivieren</button>
                    <button class="btn btn-danger" id="micStopBtn" style="display: none;">â¹ï¸ Mikrofon stoppen</button>
                    
                    <div class="action-buttons">
                        <button class="btn btn-primary" id="micCaptureBtn" disabled>ð¹ 3s Aufnahme</button>
                        <button class="btn btn-warning" id="liveAnalysisBtn" disabled>ð´ Live-Analyse</button>
                    </div>
                    
                    <button class="btn btn-danger" id="stopLiveBtn" style="display: none;">â¹ï¸ Live-Analyse stoppen</button>
                </div>
                
                <div class="signal-info-panel" id="micInfo">
                    <div class="info-row">
                        <span>ð Status:</span>
                        <span class="info-value" id="micStatus">Inaktiv</span>
                    </div>
                    <div class="info-row">
                        <span>ð Sample-Rate:</span>
                        <span class="info-value" id="micSampleRate">--- Hz</span>
                    </div>
                    <div class="info-row">
                        <span>ð Peak-Level:</span>
                        <span class="info-value" id="micPeakLevel">--- dB</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3 class="section-title">ð Datei-Import</h3>
                
                <div class="action-buttons">
                    <button class="btn btn-primary" id="loadWavBtn">ð WAV-Datei laden</button>
                    <button class="btn btn-info" id="loadDemoBtn">ðµ Demo-Signal laden</button>
                </div>
                
                <div class="signal-info-panel" id="fileInfo">
                    <div class="info-row">
                        <span>ð Datei:</span>
                        <span class="info-value" id="fileName">Keine geladen</span>
                    </div>
                    <div class="info-row">
                        <span>ð§ Format:</span>
                        <span class="info-value" id="fileFormat">---</span>
                    </div>
                    <div class="info-row">
                        <span>ð GrÃ¶Ãe:</span>
                        <span class="info-value" id="fileSize">--- KB</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3 class="section-title">âï¸ Î¾-FFT Engine Settings</h3>
                
                <div class="control-item-full">
                    <label>ð Î¾-Parameter</label>
                    <input type="range" class="slider" id="xiValueSlider" 
                           min="0.001" max="0.1" step="0.001" value="0.01">
                    <div class="slider-value" id="xiValueDisplay">0.01</div>
                </div>
                
                <div class="control-item-full">
                    <label>ð¯ Schwellwert</label>
                    <input type="range" class="slider" id="thresholdSlider" 
                           min="0.001" max="0.1" step="0.001" value="0.005">
                    <div class="slider-value" id="thresholdDisplay">0.005</div>
                </div>
                
                <div class="action-buttons">
                    <button class="btn btn-primary" id="applySettingsBtn">ð Einstellungen anwenden</button>
                    <button class="btn btn-warning" id="resetSettingsBtn">âº ZurÃ¼cksetzen</button>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="wavFileInput" accept=".wav,.mp3" style="display: none;">

    <script>
        // ===== IMPROVED Î¾-HARMONIC ANALYZER v2.0 =====
        
        /**
         * Î¾-Harmonic Analyzer fÃ¼r prÃ¤zise PeriodizitÃ¤ts- und Harmonik-Analyse
         * Verwendet Autokorrelation und Î¾-Mathematik (KEINE FFT!)
         */
        class XiHarmonicAnalyzer {
            constructor(options = {}) {
                this.config = {
                    sampleRate: options.sampleRate || 44100,
                    xiValue: options.xiValue || 0.01,
                    threshold: options.threshold || 0.005,
                    profile: options.profile || 'balanced',
                    maxPeriods: this.getMaxPeriodsForProfile(options.profile || 'balanced')
                };
                
                this.cache = new Map();
                this.isInitialized = false;
                
                console.log(`ðµ Î¾-Harmonic Analyzer initialisiert (Profil: ${this.config.profile})`);
            }
            
            getMaxPeriodsForProfile(profile) {
                const profiles = {
                    'realtime': 15,
                    'balanced': 30,
                    'quality': 50,
                    'research': 100
                };
                return profiles[profile] || 30;
            }
            
            async initialize() {
                // Simuliere kurze Initialisierung
                await new Promise(resolve => setTimeout(resolve, 100));
                this.isInitialized = true;
                return true;
            }
            
            async analyze(signal, options = {}) {
                if (!this.isInitialized) {
                    await this.initialize();
                }
                
                const startTime = performance.now();
                
                // Cache-Check
                const cacheKey = this.generateCacheKey(signal);
                if (this.cache.has(cacheKey)) {
                    const cached = this.cache.get(cacheKey);
                    return { ...cached, fromCache: true, analysisTime: 1.0 };
                }
                
                // Signal-Eigenschaften analysieren
                const characteristics = this.analyzeSignalCharacteristics(signal);
                
                // Strategie bestimmen
                const strategy = this.selectStrategy(characteristics);
                
                // Periodensuche mit Autokorrelation
                const periods = this.findPeriodsWithAutocorrelation(signal);
                
                // Î¾-Harmonik-Analyse
                const xiRatios = this.calculateXiHarmonicRatios(periods);
                
                // Peaks erstellen
                const peaks = periods.map(period => ({
                    frequency: this.config.sampleRate / period.period,
                    magnitude: period.magnitude,
                    xiScore: period.xiScore,
                    harmonicQuality: period.harmonicQuality || 0
                }));
                
                const analysisTime = performance.now() - startTime;
                
                const result = {
                    peaks: peaks,
                    xiRatios: xiRatios,
                    strategy: strategy,
                    characteristics: characteristics,
                    analysisTime: analysisTime,
                    fromCache: false,
                    analysisMethod: 'autocorrelation_xi'
                };
                
                // Cache-Speicherung (begrenzt)
                if (this.cache.size < 20) {
                    this.cache.set(cacheKey, result);
                }
                
                return result;
            }
            
            analyzeSignalCharacteristics(signal) {
                const N = signal.length;
                const mean = signal.reduce((sum, val) => sum + val, 0) / N;
                const rms = Math.sqrt(signal.reduce((sum, val) => sum + val * val, 0) / N);
                
                // Bessere Charakteristika-Analyse
                const variance = signal.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / N;
                const dynamicRange = this.calculateDynamicRange(signal);
                const periodicity = this.estimatePeriodicity(signal);
                
                return {
                    length: N,
                    mean: mean,
                    rms: rms,
                    variance: variance,
                    dynamicRange: dynamicRange,
                    harmonicContent: Math.min(0.9, periodicity * 1.2),
                    stationarity: Math.max(0.3, 1.0 - variance),
                    noiseLevel: Math.min(0.4, variance * 2),
                    periodicity: periodicity
                };
            }
            
            calculateDynamicRange(signal) {
                const sorted = Array.from(signal).map(Math.abs).sort((a, b) => b - a);
                const top10Percent = Math.floor(sorted.length * 0.1);
                const bottom10Percent = Math.floor(sorted.length * 0.9);
                
                const highLevel = sorted[top10Percent] || 0;
                const lowLevel = sorted[bottom10Percent] || 0.001;
                
                return Math.min(10, highLevel / lowLevel);
            }
            
            estimatePeriodicity(signal) {
                // Schnelle PeriodizitÃ¤ts-SchÃ¤tzung
                let maxCorr = 0;
                const testPeriods = [20, 40, 80, 100, 160];
                
                for (const period of testPeriods) {
                    if (signal.length > period * 2) {
                        const corr = this.quickPeriodicity(signal, period);
                        maxCorr = Math.max(maxCorr, corr);
                    }
                }
                
                return maxCorr;
            }
            
            quickPeriodicity(signal, period) {
                let correlation = 0;
                let count = 0;
                
                for (let i = 0; i < signal.length - period; i += Math.max(1, Math.floor(period / 4))) {
                    correlation += signal[i] * signal[i + period];
                    count++;
                }
                
                return count > 0 ? Math.abs(correlation / count) : 0;
            }
            
            selectStrategy(characteristics) {
                if (characteristics.harmonicContent > 0.7) {
                    return { 
                        algorithm: 'harmonic_focused', 
                        optimizations: ['harmonic_prefilter', 'xi_weighting'],
                        description: 'Harmonik-fokussierte Analyse'
                    };
                } else if (characteristics.noiseLevel > 0.25) {
                    return { 
                        algorithm: 'noise_robust', 
                        optimizations: ['noise_reduction', 'adaptive_threshold'],
                        description: 'Rausch-robuste Analyse'
                    };
                } else if (characteristics.periodicity > 0.6) {
                    return { 
                        algorithm: 'periodicity_enhanced', 
                        optimizations: ['period_refinement', 'autocorr_boost'],
                        description: 'PeriodizitÃ¤ts-verstÃ¤rkte Analyse'
                    };
                } else {
                    return { 
                        algorithm: 'adaptive_autocorrelation', 
                        optimizations: ['standard_xi'],
                        description: 'Adaptive Autokorrelations-Analyse'
                    };
                }
            }
            
            findPeriodsWithAutocorrelation(signal) {
                const periods = [];
                const maxPeriod = Math.min(this.config.maxPeriods, signal.length / 3);
                
                for (let period = 4; period <= maxPeriod && periods.length < 20; period++) {
                    const periodicity = this.calculateAutocorrelationPeriodicity(signal, period);
                    
                    if (periodicity > this.config.threshold) {
                        const xiScore = this.evaluateXiHarmonicScore(period);
                        const harmonicQuality = this.assessHarmonicQuality(signal, period);
                        const magnitude = periodicity * xiScore * (1 + harmonicQuality);
                        
                        periods.push({
                            period: period,
                            periodicity: periodicity,
                            xiScore: xiScore,
                            harmonicQuality: harmonicQuality,
                            magnitude: magnitude,
                            frequency: this.config.sampleRate / period
                        });
                    }
                }
                
                return periods.sort((a, b) => b.magnitude - a.magnitude);
            }
            
            calculateAutocorrelationPeriodicity(signal, period) {
                if (signal.length < 2 * period) return 0;
                
                let correlation = 0;
                let norm1 = 0;
                let norm2 = 0;
                let count = 0;
                
                const step = Math.max(1, Math.floor(period / 4));
                const maxOffset = signal.length - period;
                
                for (let start = 0; start < maxOffset; start += step) {
                    const end = Math.min(start + period, maxOffset);
                    
                    for (let i = start; i < end; i++) {
                        const val1 = signal[i];
                        const val2 = signal[i + period];
                        
                        correlation += val1 * val2;
                        norm1 += val1 * val1;
                        norm2 += val2 * val2;
                        count++;
                    }
                }
                
                if (count === 0 || norm1 === 0 || norm2 === 0) return 0;
                
                const normalizedCorr = correlation / Math.sqrt(norm1 * norm2);
                return Math.max(0, normalizedCorr);
            }
            
            assessHarmonicQuality(signal, period) {
                // Bewerte die harmonische QualitÃ¤t dieser Periode
                const fundamentalFreq = this.config.sampleRate / period;
                let harmonicScore = 0;
                let harmonicCount = 0;
                
                // Teste Harmonische 2-6
                for (let h = 2; h <= 6; h++) {
                    const harmonicPeriod = Math.floor(period / h);
                    if (harmonicPeriod >= 4) {
                        const harmonicStrength = this.calculateAutocorrelationPeriodicity(signal, harmonicPeriod);
                        if (harmonicStrength > this.config.threshold * 0.5) {
                            harmonicScore += harmonicStrength / h;
                            harmonicCount++;
                        }
                    }
                }
                
                return harmonicCount > 0 ? harmonicScore / harmonicCount : 0;
            }
            
            evaluateXiHarmonicScore(period) {
                // Î¾-Bewertung fÃ¼r harmonische Analyse
                const omega = 2 * Math.PI / period;
                const targetOmega = 2 * Math.PI / 50; // Referenz-Periode
                const diff = Math.abs(omega - targetOmega);
                return Math.exp(-diff * diff / (2 * this.config.xiValue));
            }
            
            calculateXiHarmonicRatios(periods) {
                const ratios = [];
                
                for (let i = 0; i < Math.min(periods.length, 10); i++) {
                    for (let j = i + 1; j < Math.min(periods.length, 10); j++) {
                        const freq1 = periods[i].frequency;
                        const freq2 = periods[j].frequency;
                        
                        const freqHigh = Math.max(freq1, freq2);
                        const freqLow = Math.min(freq1, freq2);
                        const ratio = freqHigh / freqLow;
                        
                        if (ratio >= 1.01 && ratio <= 8.0) {
                            const harmonicInterval = this.classifyHarmonicInterval(ratio);
                            const significance = periods[i].magnitude * periods[j].magnitude;
                            
                            ratios.push({
                                freqHigh: freqHigh,
                                freqLow: freqLow,
                                xiRatio: ratio,
                                significance: significance,
                                harmonicInterval: harmonicInterval,
                                isHarmonic: harmonicInterval !== 'Komplex'
                            });
                        }
                    }
                }
                
                return ratios.sort((a, b) => b.significance - a.significance).slice(0, 10);
            }
            
            classifyHarmonicInterval(ratio) {
                const cents = 1200 * Math.log2(ratio);
                const intervals = [
                    {name: 'Unison', cents: 0, tolerance: 20},
                    {name: 'Oktave', cents: 1200, tolerance: 30},
                    {name: 'Quinte', cents: 702, tolerance: 25},
                    {name: 'Quarte', cents: 498, tolerance: 25},
                    {name: 'GroÃe Terz', cents: 386, tolerance: 30},
                    {name: 'Kleine Terz', cents: 316, tolerance: 30},
                    {name: 'Ganzton', cents: 204, tolerance: 35},
                    {name: 'Kleine Septime', cents: 996, tolerance: 40},
                    {name: 'GroÃe Sexte', cents: 884, tolerance: 35}
                ];
                
                for (const interval of intervals) {
                    if (Math.abs(cents - interval.cents) <= interval.tolerance) {
                        return interval.name;
                    }
                }
                
                return 'Komplex';
            }
            
            generateCacheKey(signal) {
                // Vereinfachter Hash aus ersten Samples
                let hash = 0;
                const sampleStep = Math.max(1, Math.floor(signal.length / 50));
                for (let i = 0; i < signal.length; i += sampleStep) {
                    hash = ((hash << 5) - hash + Math.floor(signal[i] * 1000)) & 0xffffffff;
                }
                return hash.toString(36);
            }
        }

        // ===== FFT SPECTRUM ANALYZER =====
        
        /**
         * Erweiterte FFT-Implementierung fÃ¼r Spektrum-Analyse
         */
        class FFTSpectrumAnalyzer {
            constructor(options = {}) {
                this.config = {
                    sampleRate: options.sampleRate || 44100,
                    fftSize: options.fftSize || 4096,
                    windowFunction: options.windowFunction || 'hanning',
                    averagingFrames: options.averagingFrames || 3
                };
                
                this.magnitudeHistory = [];
                this.phaseHistory = [];
                this.waterfallData = [];
                this.waterfallMaxLines = 100;
                
                // Precompute window function
                this.windowCoeffs = this.computeWindowFunction(this.config.fftSize, this.config.windowFunction);
                
                console.log(`ð FFT Spektrum-Analyzer initialisiert (FFT-GrÃ¶Ãe: ${this.config.fftSize})`);
            }
            
            computeWindowFunction(size, type) {
                const window = new Float32Array(size);
                
                switch(type) {
                    case 'hanning':
                        for (let i = 0; i < size; i++) {
                            window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
                        }
                        break;
                    case 'hamming':
                        for (let i = 0; i < size; i++) {
                            window[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (size - 1));
                        }
                        break;
                    case 'blackman':
                        for (let i = 0; i < size; i++) {
                            const a0 = 0.42, a1 = 0.5, a2 = 0.08;
                            window[i] = a0 - a1 * Math.cos(2 * Math.PI * i / (size - 1)) + 
                                       a2 * Math.cos(4 * Math.PI * i / (size - 1));
                        }
                        break;
                    case 'rectangular':
                    default:
                        window.fill(1.0);
                        break;
                }
                
                return window;
            }
            
            analyze(signal, options = {}) {
                const fftSize = this.config.fftSize;
                const signalLength = Math.min(signal.length, fftSize);
                
                // Prepare padded signal
                const paddedSignal = new Float32Array(fftSize);
                paddedSignal.set(signal.subarray(0, signalLength));
                
                // Apply window function
                for (let i = 0; i < signalLength; i++) {
                    paddedSignal[i] *= this.windowCoeffs[i];
                }
                
                // Perform FFT
                const fftResult = this.fft(paddedSignal);
                
                // Calculate magnitude and phase
                const magnitude = new Float32Array(fftSize / 2);
                const phase = new Float32Array(fftSize / 2);
                
                for (let i = 0; i < fftSize / 2; i++) {
                    const real = fftResult.real[i];
                    const imag = fftResult.imag[i];
                    magnitude[i] = Math.sqrt(real * real + imag * imag);
                    phase[i] = Math.atan2(imag, real);
                }
                
                // Apply averaging
                if (this.config.averagingFrames > 1) {
                    this.magnitudeHistory.push(magnitude);
                    if (this.magnitudeHistory.length > this.config.averagingFrames) {
                        this.magnitudeHistory.shift();
                    }
                    
                    // Average magnitudes
                    const averaged = new Float32Array(fftSize / 2);
                    for (let i = 0; i < fftSize / 2; i++) {
                        let sum = 0;
                        for (const hist of this.magnitudeHistory) {
                            sum += hist[i];
                        }
                        averaged[i] = sum / this.magnitudeHistory.length;
                    }
                    
                    return {
                        magnitude: averaged,
                        phase: phase,
                        frequencies: this.getFrequencyArray(),
                        fftSize: fftSize,
                        sampleRate: this.config.sampleRate
                    };
                }
                
                return {
                    magnitude: magnitude,
                    phase: phase,
                    frequencies: this.getFrequencyArray(),
                    fftSize: fftSize,
                    sampleRate: this.config.sampleRate
                };
            }
            
            // Cooley-Tukey FFT implementation
            fft(signal) {
                const N = signal.length;
                
                if (N <= 1) {
                    return {
                        real: new Float32Array(signal),
                        imag: new Float32Array(N)
                    };
                }
                
                // Bit-reversal permutation
                const real = new Float32Array(N);
                const imag = new Float32Array(N);
                
                for (let i = 0; i < N; i++) {
                    const j = this.reverseBits(i, Math.log2(N));
                    real[j] = signal[i];
                    imag[j] = 0;
                }
                
                // Cooley-Tukey FFT
                for (let len = 2; len <= N; len <<= 1) {
                    const halfLen = len >> 1;
                    const angleStep = -2 * Math.PI / len;
                    
                    for (let i = 0; i < N; i += len) {
                        for (let j = 0; j < halfLen; j++) {
                            const angle = angleStep * j;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            
                            const u_real = real[i + j];
                            const u_imag = imag[i + j];
                            const v_real = real[i + j + halfLen] * cos - imag[i + j + halfLen] * sin;
                            const v_imag = real[i + j + halfLen] * sin + imag[i + j + halfLen] * cos;
                            
                            real[i + j] = u_real + v_real;
                            imag[i + j] = u_imag + v_imag;
                            real[i + j + halfLen] = u_real - v_real;
                            imag[i + j + halfLen] = u_imag - v_imag;
                        }
                    }
                }
                
                return { real, imag };
            }
            
            reverseBits(num, bits) {
                let result = 0;
                for (let i = 0; i < bits; i++) {
                    result = (result << 1) | (num & 1);
                    num >>= 1;
                }
                return result;
            }
            
            getFrequencyArray() {
                const freqs = new Float32Array(this.config.fftSize / 2);
                const freqStep = this.config.sampleRate / this.config.fftSize;
                
                for (let i = 0; i < freqs.length; i++) {
                    freqs[i] = i * freqStep;
                }
                
                return freqs;
            }
            
            updateWaterfall(magnitude) {
                this.waterfallData.push(new Float32Array(magnitude));
                if (this.waterfallData.length > this.waterfallMaxLines) {
                    this.waterfallData.shift();
                }
            }
            
            getWaterfallData() {
                return this.waterfallData;
            }
            
            updateConfig(newConfig) {
                const oldFftSize = this.config.fftSize;
                Object.assign(this.config, newConfig);
                
                // Recalculate window if FFT size or function changed
                if (this.config.fftSize !== oldFftSize || 
                    newConfig.windowFunction !== undefined) {
                    this.windowCoeffs = this.computeWindowFunction(
                        this.config.fftSize, 
                        this.config.windowFunction
                    );
                    
                    // Clear history if FFT size changed
                    if (this.config.fftSize !== oldFftSize) {
                        this.magnitudeHistory = [];
                        this.waterfallData = [];
                    }
                }
            }
        }

        // ===== GLOBAL VARIABLES =====
        let audioContext = null;
        let currentSignal = null;
        let signalMetadata = null;
        let oscilloscopeCanvas = null;
        let oscilloscopeCtx = null;
        let spectrumCanvas = null;
        let spectrumCtx = null;
        let lastDetectedFundamental = null;
        let xiHarmonicAnalyzer = null;
        let fftSpectrumAnalyzer = null;
        let currentXiResult = null;
        let currentSpectrumResult = null;
        
        // Visualization parameters
        let timeRangeMs = 100;
        let amplificationFactor = 1.0;
        let freqRangeHz = 2000;
        let dbRange = 80;
        let isContinuousMode = false;
        let continuousInterval = null;
        let spectrumMode = 'fft'; // 'fft', 'xi', 'waterfall'
        
        // Microphone variables
        let micStream = null;
        let micAnalyzer = null;
        let micDataArray = null;
        let micTimeDataArray = null;
        let micLevelUpdateInterval = null;
        let isRecordingMic = false;
        let liveAnalysisInterval = null;
        let isLiveAnalysisRunning = false;
        let micSensitivity = 1.3;
        let noiseGateThreshold = 0.02;
        let isClipping = false;
        
        // Performance monitoring
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let currentFps = 0;
        let lastDrawTime = 0;
        const DRAW_THROTTLE_MS = 33; // ~30 FPS Maximum
        
        // Animation
        let animationId = null;
        
        // Constants
        const SAMPLE_RATE = 44100;
        const SIGNAL_DURATION = 3.0;
        const LOG_MAX_LINES = 50;
        
        // Demo signals for testing
        const DEMO_SIGNALS = {
            'chord_a_major': {
                name: 'A-Dur Akkord',
                frequencies: [440, 554.37, 659.25], // A4, C#5, E5
                amplitudes: [0.6, 0.4, 0.4]
            },
            'harmonic_series': {
                name: 'Harmonische Reihe',
                fundamental: 220,
                harmonics: [1, 2, 3, 4, 5, 6],
                amplitudes: [1.0, 0.5, 0.33, 0.25, 0.2, 0.17]
            }
        };
        
        // ===== INITIALIZATION =====
        async function initializeSystem() {
            try {
                logMessage('ð Î¾-Oszilloskop mit Spektrum-Analyzer wird initialisiert...');
                
                // Initialize Î¾-Harmonic Analyzer
                try {
                    xiHarmonicAnalyzer = new XiHarmonicAnalyzer({
                        profile: 'balanced',
                        sampleRate: SAMPLE_RATE,
                        xiValue: 0.01,
                        threshold: 0.005
                    });
                    
                    await xiHarmonicAnalyzer.initialize();
                    logMessage('â Î¾-Harmonic Analyzer v2.0 erfolgreich initialisiert');
                } catch (xiError) {
                    logMessage(`â ï¸ Î¾-Harmonic Analyzer Fehler: ${xiError.message}`);
                }
                
                // Initialize FFT Spectrum Analyzer
                try {
                    fftSpectrumAnalyzer = new FFTSpectrumAnalyzer({
                        sampleRate: SAMPLE_RATE,
                        fftSize: 4096,
                        windowFunction: 'hanning',
                        averagingFrames: 3
                    });
                    logMessage('â FFT Spektrum-Analyzer initialisiert');
                } catch (fftError) {
                    logMessage(`â ï¸ FFT Spektrum-Analyzer Fehler: ${fftError.message}`);
                }
                
                // Initialize canvases
                oscilloscopeCanvas = document.getElementById('oscilloscopeCanvas');
                oscilloscopeCtx = oscilloscopeCanvas.getContext('2d');
                spectrumCanvas = document.getElementById('spectrumCanvas');
                spectrumCtx = spectrumCanvas.getContext('2d');
                
                // Initialize audio context
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    logMessage('â Audio Context initialisiert');
                } catch (audioError) {
                    logMessage(`â ï¸ Audio Context Fehler: ${audioError.message}`);
                }
                
                // Setup canvas resizing
                resizeCanvases();
                window.addEventListener('resize', resizeCanvases);
                
                // Setup all event handlers
                setupEventHandlers();
                
                // Initialize performance monitoring
                startPerformanceMonitoring();
                
                // Initial drawings
                drawOscilloscope(null);
                drawSpectrum(null);
                
                updateStatus('â Î¾-Oszilloskop mit Spektrum-Analyzer bereit', 'success');
                logMessage('ð¯ System mit Î¾-FFT Engine v2.0 und Spektrum-Analyzer bereit');
                
            } catch (error) {
                logMessage(`â Initialisierung fehlgeschlagen: ${error.message}`);
                updateStatus('â Initialisierung fehlgeschlagen', 'error');
            }
        }
        
        function resizeCanvases() {
            try {
                // Oscilloscope canvas
                const oscContainer = oscilloscopeCanvas.parentElement;
                const oscRect = oscContainer.getBoundingClientRect();
                oscilloscopeCanvas.width = oscRect.width - 4;
                oscilloscopeCanvas.height = oscRect.height - 4;
                
                // Spectrum canvas
                const specContainer = spectrumCanvas.parentElement;
                const specRect = specContainer.getBoundingClientRect();
                spectrumCanvas.width = specRect.width - 4;
                spectrumCanvas.height = specRect.height - 4;
                
                if (currentSignal) {
                    drawOscilloscope(currentSignal);
                    if (currentSpectrumResult) {
                        drawSpectrum(currentSpectrumResult);
                    }
                }
            } catch (error) {
                logMessage(`â ï¸ Canvas Resize Fehler: ${error.message}`);
            }
        }
        
        // ===== PERFORMANCE MONITORING =====
        function startPerformanceMonitoring() {
            setInterval(updatePerformanceMetrics, 1000);
            logMessage('ð Performance-Monitoring gestartet');
        }
        
        function updatePerformanceMetrics() {
            const now = Date.now();
            
            // Update FPS
            if (now - lastFpsUpdate >= 1000) {
                currentFps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = now;
                
                // Update FPS display
                const fpsEl = document.getElementById('fpsIndicator');
                if (fpsEl) {
                    fpsEl.textContent = `FPS: ${currentFps}`;
                }
            }
        }
        
        function updateEngineStatus() {
            if (!xiHarmonicAnalyzer) return;
            
            const config = xiHarmonicAnalyzer.config;
            
            document.getElementById('currentProfile').textContent = config.profile.toUpperCase();
            document.getElementById('cacheHits').textContent = xiHarmonicAnalyzer.cache.size || '0';
            document.getElementById('spectrumMode').textContent = spectrumMode.toUpperCase();
            
            if (fftSpectrumAnalyzer) {
                document.getElementById('fftSize').textContent = fftSpectrumAnalyzer.config.fftSize.toString();
            }
        }
        
        // ===== EVENT HANDLERS =====
        function setupEventHandlers() {
            // Profile selector
            document.querySelectorAll('[data-profile]').forEach(btn => {
                btn.addEventListener('click', function() {
                    setXiHarmonicProfile(this.dataset.profile);
                });
            });
            
            // Spectrum mode buttons
            document.querySelectorAll('[data-spectrum]').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('[data-spectrum]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    spectrumMode = this.dataset.spectrum;
                    updateEngineStatus();
                    if (currentSignal) {
                        performSpectrumAnalysis(currentSignal);
                    }
                    logMessage(`ð Spektrum-Modus: ${spectrumMode.toUpperCase()}`);
                });
            });
            
            // Mode buttons
            document.querySelectorAll('[data-mode]').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    switchGeneratorMode();
                });
            });
            
            // Symmetry buttons
            document.querySelectorAll('[data-symmetry]').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('[data-symmetry]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    updateSymmetryMode();
                });
            });
            
            setupFrequencyControls();
            setupVisualizationControls();
            setupSpectrumControls();
            setupActionButtons();
            setupMicrophoneControls();
            setupFileControls();
            setupXiHarmonicControls();
            
            logMessage('â Event-Handler eingerichtet');
        }
        
        function setupSpectrumControls() {
            // Frequency range control
            document.getElementById('freqRangeSlider').addEventListener('input', function() {
                freqRangeHz = parseInt(this.value);
                document.getElementById('freqRangeValue').textContent = `${freqRangeHz} Hz`;
                if (currentSpectrumResult) {
                    drawSpectrum(currentSpectrumResult);
                }
            });
            
            // dB range control
            document.getElementById('dbRangeSlider').addEventListener('input', function() {
                dbRange = parseInt(this.value);
                document.getElementById('dbRangeValue').textContent = `${dbRange} dB`;
                if (currentSpectrumResult) {
                    drawSpectrum(currentSpectrumResult);
                }
            });
            
            // FFT size control
            document.getElementById('fftSizeSlider').addEventListener('input', function() {
                const power = parseInt(this.value);
                const fftSize = Math.pow(2, power);
                document.getElementById('fftSizeValue').textContent = fftSize.toString();
                
                if (fftSpectrumAnalyzer) {
                    fftSpectrumAnalyzer.updateConfig({ fftSize: fftSize });
                    updateEngineStatus();
                    logMessage(`ð FFT-GrÃ¶Ãe geÃ¤ndert: ${fftSize}`);
                    
                    if (currentSignal) {
                        performSpectrumAnalysis(currentSignal);
                    }
                }
            });
            
            // Window function
            document.getElementById('windowFunction').addEventListener('change', function() {
                if (fftSpectrumAnalyzer) {
                    fftSpectrumAnalyzer.updateConfig({ windowFunction: this.value });
                    logMessage(`ðª Fenster-Funktion: ${this.value}`);
                    
                    if (currentSignal) {
                        performSpectrumAnalysis(currentSignal);
                    }
                }
            });
            
            // Averaging
            document.getElementById('averagingSlider').addEventListener('input', function() {
                const frames = parseInt(this.value);
                document.getElementById('averagingValue').textContent = `${frames} Frames`;
                
                if (fftSpectrumAnalyzer) {
                    fftSpectrumAnalyzer.updateConfig({ averagingFrames: frames });
                    logMessage(`ð Averaging: ${frames} Frames`);
                }
            });
            
            // Spectrum display mode
            document.getElementById('spectrumDisplay').addEventListener('change', function() {
                if (currentSpectrumResult) {
                    drawSpectrum(currentSpectrumResult);
                }
            });
        }
        
        function setupFrequencyControls() {
            // Base frequency slider
            document.getElementById('baseFreqSlider').addEventListener('input', function() {
                const freq = parseInt(this.value);
                document.getElementById('baseFreqDisplay').textContent = `${freq} Hz`;
                document.getElementById('baseFreqValue').textContent = `${freq} Hz`;
                updateFrequenciesFromBase();
            });
            
            document.getElementById('baseAmpSlider').addEventListener('input', function() {
                document.getElementById('baseAmpValue').textContent = `${this.value}%`;
            });
            
            // Frequency mode controls
            ['lowerFreq', 'upperFreq', 'lowerAmp', 'upperAmp'].forEach(id => {
                const element = document.getElementById(`${id}Slider`);
                if (element) {
                    element.addEventListener('input', function() {
                        const suffix = id.includes('Freq') ? ' Hz' : '%';
                        document.getElementById(`${id}Value`).textContent = `${this.value}${suffix}`;
                    });
                }
            });
            
            // Beat mode controls
            ['lowerBeat', 'upperBeat', 'lowerBeatAmp', 'upperBeatAmp'].forEach(id => {
                const element = document.getElementById(`${id}Slider`);
                if (element) {
                    element.addEventListener('input', function() {
                        const suffix = id.includes('Amp') ? '%' : ' Hz';
                        const value = id.includes('Beat') && !id.includes('Amp') ? 
                                     parseFloat(this.value).toFixed(1) : this.value;
                        document.getElementById(`${id}Value`).textContent = `${value}${suffix}`;
                        
                        if (id.includes('Beat') && !id.includes('Amp')) {
                            updateFrequenciesFromBeats();
                        }
                        
                        if (getSymmetryMode() === 'symmetric' && id.includes('lowerBeatAmp')) {
                            document.getElementById('upperBeatAmpSlider').value = this.value;
                            document.getElementById('upperBeatAmpValue').textContent = `${this.value}%`;
                        }
                    });
                }
            });
            
            // Harmonic mode controls
            document.getElementById('harmonicCountSlider').addEventListener('input', function() {
                document.getElementById('harmonicCountValue').textContent = this.value;
            });
            
            document.getElementById('harmonicIntensitySlider').addEventListener('input', function() {
                document.getElementById('harmonicIntensityValue').textContent = this.value;
            });
        }
        
        function setupVisualizationControls() {
            // Time range control
            document.getElementById('timeRangeSlider').addEventListener('input', function() {
                timeRangeMs = parseInt(this.value);
                document.getElementById('timeRangeValue').textContent = `${timeRangeMs} ms`;
                if (currentSignal) {
                    drawOscilloscope(currentSignal);
                }
            });
            
            // Amplitude control
            document.getElementById('amplitudeSlider').addEventListener('input', function() {
                amplificationFactor = parseFloat(this.value);
                document.getElementById('amplitudeValue').textContent = `${amplificationFactor.toFixed(1)}x`;
                if (currentSignal) {
                    drawOscilloscope(currentSignal);
                }
            });
        }
        
        function setupXiHarmonicControls() {
            // Î¾-Value control
            document.getElementById('xiValueSlider').addEventListener('input', function() {
                const value = parseFloat(this.value);
                document.getElementById('xiValueDisplay').textContent = value.toFixed(3);
            });
            
            // Threshold control
            document.getElementById('thresholdSlider').addEventListener('input', function() {
                const value = parseFloat(this.value);
                document.getElementById('thresholdDisplay').textContent = value.toFixed(3);
            });
            
            // Apply settings button
            document.getElementById('applySettingsBtn').addEventListener('click', applyXiHarmonicSettings);
            
            // Reset settings button
            document.getElementById('resetSettingsBtn').addEventListener('click', resetXiHarmonicSettings);
        }
        
        function setupActionButtons() {
            // Generator buttons
            document.getElementById('generateBtn').addEventListener('click', generateSignal);
            document.getElementById('exportBtn').addEventListener('click', exportSignalAsWav);
            document.getElementById('continuousBtn').addEventListener('click', startContinuousMode);
            document.getElementById('stopContinuousBtn').addEventListener('click', stopContinuousMode);
            
            // Utility buttons
            document.getElementById('saveLogBtn').addEventListener('click', saveLog);
        }
        
        function setupMicrophoneControls() {
            document.getElementById('micStartBtn').addEventListener('click', startMicrophone);
            document.getElementById('micStopBtn').addEventListener('click', stopMicrophone);
            document.getElementById('micCaptureBtn').addEventListener('click', captureMicrophoneSignal);
            document.getElementById('liveAnalysisBtn').addEventListener('click', startLiveAnalysis);
            document.getElementById('stopLiveBtn').addEventListener('click', stopLiveAnalysis);
            
            document.getElementById('micSensitivitySlider').addEventListener('input', function() {
                micSensitivity = parseFloat(this.value);
                document.getElementById('micSensitivityValue').textContent = `${micSensitivity.toFixed(1)}x`;
                logMessage(`ð Mikrofon-Empfindlichkeit: ${micSensitivity.toFixed(1)}x`);
            });
            
            document.getElementById('noiseGateSlider').addEventListener('input', function() {
                noiseGateThreshold = parseFloat(this.value);
                document.getElementById('noiseGateValue').textContent = noiseGateThreshold.toFixed(2);
                logMessage(`ð Noise Gate: ${noiseGateThreshold.toFixed(2)}`);
            });
        }
        
        function setupFileControls() {
            document.getElementById('loadWavBtn').addEventListener('click', function() {
                document.getElementById('wavFileInput').click();
            });
            
            document.getElementById('loadDemoBtn').addEventListener('click', loadDemoSignal);
            
            document.getElementById('wavFileInput').addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (file) loadWavFile(file);
                event.target.value = '';
            });
        }
        
        // ===== SPECTRUM ANALYSIS =====
        async function performSpectrumAnalysis(signal) {
            if (!signal || signal.length === 0) return;
            
            try {
                let result = null;
                
                switch(spectrumMode) {
                    case 'fft':
                        if (fftSpectrumAnalyzer) {
                            result = fftSpectrumAnalyzer.analyze(signal);
                            result.type = 'fft';
                            result.peaks = findSpectrumPeaks(result.magnitude, result.frequencies);
                        }
                        break;
                        
                    case 'xi':
                        if (xiHarmonicAnalyzer) {
                            const xiResult = await xiHarmonicAnalyzer.analyze(signal);
                            result = convertXiToSpectrum(xiResult);
                            result.type = 'xi';
                        }
                        break;
                        
                    case 'waterfall':
                        if (fftSpectrumAnalyzer) {
                            const fftResult = fftSpectrumAnalyzer.analyze(signal);
                            fftSpectrumAnalyzer.updateWaterfall(fftResult.magnitude);
                            result = {
                                ...fftResult,
                                type: 'waterfall',
                                waterfallData: fftSpectrumAnalyzer.getWaterfallData(),
                                peaks: findSpectrumPeaks(fftResult.magnitude, fftResult.frequencies)
                            };
                        }
                        break;
                }
                
                if (result) {
                    currentSpectrumResult = result;
                    drawSpectrum(result);
                    updateSpectrumInfo(result);
                }
                
            } catch (error) {
                logMessage(`â Spektrum-Analyse Fehler: ${error.message}`);
            }
        }
        
        function convertXiToSpectrum(xiResult) {
            // Convert Î¾-Harmonic analysis to spectrum-like format
            const maxFreq = Math.min(freqRangeHz, SAMPLE_RATE / 2);
            const binCount = 512;
            const magnitude = new Float32Array(binCount);
            const frequencies = new Float32Array(binCount);
            
            // Create frequency array
            for (let i = 0; i < binCount; i++) {
                frequencies[i] = (i / binCount) * maxFreq;
            }
            
            // Map Î¾-peaks to spectrum bins
            if (xiResult.peaks) {
                for (const peak of xiResult.peaks) {
                    const freq = peak.frequency;
                    if (freq <= maxFreq) {
                        const binIndex = Math.floor((freq / maxFreq) * binCount);
                        if (binIndex < binCount) {
                            magnitude[binIndex] = Math.max(magnitude[binIndex], peak.magnitude);
                            
                            // Add some spread for visualization
                            for (let spread = 1; spread <= 3; spread++) {
                                const spreadMag = peak.magnitude * Math.exp(-spread * spread * 0.1);
                                if (binIndex - spread >= 0) {
                                    magnitude[binIndex - spread] = Math.max(magnitude[binIndex - spread], spreadMag);
                                }
                                if (binIndex + spread < binCount) {
                                    magnitude[binIndex + spread] = Math.max(magnitude[binIndex + spread], spreadMag);
                                }
                            }
                        }
                    }
                }
            }
            
            return {
                magnitude: magnitude,
                frequencies: frequencies,
                peaks: xiResult.peaks || [],
                fftSize: binCount * 2,
                sampleRate: SAMPLE_RATE
            };
        }
        
        function findSpectrumPeaks(magnitude, frequencies, minPeakHeight = 0.01) {
            const peaks = [];
            
            for (let i = 1; i < magnitude.length - 1; i++) {
                if (magnitude[i] > magnitude[i-1] && 
                    magnitude[i] > magnitude[i+1] && 
                    magnitude[i] > minPeakHeight) {
                    
                    peaks.push({
                        frequency: frequencies[i],
                        magnitude: magnitude[i],
                        bin: i
                    });
                }
            }
            
            // Sort by magnitude and return top peaks
            peaks.sort((a, b) => b.magnitude - a.magnitude);
            return peaks.slice(0, 20);
        }
        
        function updateSpectrumInfo(result) {
            const peakCount = result.peaks ? result.peaks.length : 0;
            const mode = result.type ? result.type.toUpperCase() : 'UNKNOWN';
            
            document.getElementById('spectrumInfo').textContent = `Modus: ${mode} | ${peakCount} Peaks`;
        }
        
        // ===== Î¾-HARMONIC ANALYZER FUNCTIONS =====
        async function setXiHarmonicProfile(profile) {
            if (!xiHarmonicAnalyzer) return;
            
            try {
                // Create new analyzer with new profile
                xiHarmonicAnalyzer = new XiHarmonicAnalyzer({
                    profile: profile,
                    sampleRate: SAMPLE_RATE,
                    xiValue: parseFloat(document.getElementById('xiValueSlider').value),
                    threshold: parseFloat(document.getElementById('thresholdSlider').value)
                });
                
                await xiHarmonicAnalyzer.initialize();
                
                // Update UI
                document.querySelectorAll('[data-profile]').forEach(btn => btn.classList.remove('active'));
                document.querySelector(`[data-profile="${profile}"]`).classList.add('active');
                
                updateEngineStatus();
                logMessage(`ð¯ Î¾-Harmonic Analyzer Profil gewechselt: ${profile.toUpperCase()}`);
                
                // Re-analyze current signal if available
                if (currentSignal) {
                    await performXiHarmonicAnalysis(currentSignal);
                }
                
            } catch (error) {
                logMessage(`â Profil-Wechsel Fehler: ${error.message}`);
            }
        }
        
        function applyXiHarmonicSettings() {
            const xiValue = parseFloat(document.getElementById('xiValueSlider').value);
            const threshold = parseFloat(document.getElementById('thresholdSlider').value);
            
            if (xiHarmonicAnalyzer) {
                xiHarmonicAnalyzer.config.xiValue = xiValue;
                xiHarmonicAnalyzer.config.threshold = threshold;
                logMessage(`ð§ Î¾-Harmonic Analyzer Einstellungen: Î¾=${xiValue.toFixed(3)}, Schwelle=${threshold.toFixed(3)}`);
                
                // Re-analyze current signal
                if (currentSignal) {
                    performXiHarmonicAnalysis(currentSignal);
                }
            }
        }
        
        function resetXiHarmonicSettings() {
            document.getElementById('xiValueSlider').value = 0.01;
            document.getElementById('xiValueDisplay').textContent = '0.010';
            document.getElementById('thresholdSlider').value = 0.005;
            document.getElementById('thresholdDisplay').textContent = '0.005';
            
            applyXiHarmonicSettings();
            logMessage('âº Î¾-Harmonic Analyzer Einstellungen zurÃ¼ckgesetzt');
        }
        
        async function performXiHarmonicAnalysis(signal) {
            if (!xiHarmonicAnalyzer || !signal || signal.length === 0) return;
            
            try {
                logMessage('ðµ Starte Î¾-Harmonic Analyzer...');
                
                // IMPROVED: Pre-analyze signal for better frequency detection
                const fundamentalFreq = detectSignalFundamental(signal);
                
                const result = await xiHarmonicAnalyzer.analyze(signal, {
                    normalize: true
                });
                
                currentXiResult = result;
                updateXiAnalysisPanel(result);
                
                // IMPROVED: Use both Î¾-Harmonic result and direct detection
                let detectedFreq = fundamentalFreq;
                
                if (result.peaks && result.peaks.length > 0) {
                    const xiFreq = result.peaks[0].frequency;
                    
                    // Cross-validate frequencies
                    if (fundamentalFreq > 0 && xiFreq > 0) {
                        // Use the frequency that makes more sense
                        if (Math.abs(xiFreq - fundamentalFreq) < 20) {
                            detectedFreq = (xiFreq + fundamentalFreq) / 2; // Average
                        } else {
                            // Check which one has better harmonic series
                            const fundamentalScore = evaluateHarmonicSeries(signal, fundamentalFreq);
                            const xiScore = evaluateHarmonicSeries(signal, xiFreq);
                            detectedFreq = fundamentalScore > xiScore ? fundamentalFreq : xiFreq;
                        }
                    } else if (xiFreq > 0) {
                        detectedFreq = xiFreq;
                    }
                }
                
                // Update frequency indicator
                if (detectedFreq > 0) {
                    lastDetectedFundamental = detectedFreq;
                    document.getElementById('frequencyIndicator').textContent = `fâ: ${detectedFreq.toFixed(1)} Hz`;
                } else {
                    document.getElementById('frequencyIndicator').textContent = 'fâ: --- Hz';
                }
                
                logMessage(`â Î¾-Harmonic Analyse: ${result.peaks.length} Peaks, Fundamental: ${detectedFreq.toFixed(1)}Hz, Methode: ${result.analysisMethod}`);
                
            } catch (error) {
                logMessage(`â Î¾-Harmonic Analyse Fehler: ${error.message}`);
            }
        }
        
        // IMPROVED: Direct signal fundamental detection for generated/file signals
        function detectSignalFundamental(signal) {
            const sampleRate = SAMPLE_RATE;
            const minFreq = 80;
            const maxFreq = 2000;
            
            // Use autocorrelation for time domain signals
            const minPeriod = Math.floor(sampleRate / maxFreq);
            const maxPeriod = Math.floor(sampleRate / minFreq);
            
            let bestPeriod = 0;
            let maxCorrelation = 0;
            
            // Test different periods
            for (let period = minPeriod; period <= maxPeriod; period++) {
                let correlation = 0;
                let norm1 = 0;
                let norm2 = 0;
                let count = 0;
                
                // Use multiple segments for better accuracy
                const segmentLength = Math.min(period * 2, signal.length - period);
                const numSegments = Math.min(3, Math.floor((signal.length - period) / segmentLength));
                
                for (let seg = 0; seg < numSegments; seg++) {
                    const start = seg * Math.floor(segmentLength / 2);
                    const end = Math.min(start + segmentLength, signal.length - period);
                    
                    for (let i = start; i < end; i++) {
                        const val1 = signal[i];
                        const val2 = signal[i + period];
                        
                        correlation += val1 * val2;
                        norm1 += val1 * val1;
                        norm2 += val2 * val2;
                        count++;
                    }
                }
                
                if (count > 0 && norm1 > 0 && norm2 > 0) {
                    const normalizedCorr = correlation / Math.sqrt(norm1 * norm2);
                    
                    if (normalizedCorr > maxCorrelation) {
                        maxCorrelation = normalizedCorr;
                        bestPeriod = period;
                    }
                }
            }
            
            // Return frequency if correlation is strong enough
            if (maxCorrelation > 0.4 && bestPeriod > 0) {
                return sampleRate / bestPeriod;
            }
            
            return 0;
        }
        
        // Helper function to evaluate harmonic series strength
        function evaluateHarmonicSeries(signal, fundamentalFreq) {
            if (fundamentalFreq <= 0) return 0;
            
            const sampleRate = SAMPLE_RATE;
            let score = 0;
            
            // Test harmonics 1-6
            for (let h = 1; h <= 6; h++) {
                const harmonicFreq = fundamentalFreq * h;
                const period = sampleRate / harmonicFreq;
                
                if (period < 4 || period > signal.length / 3) continue;
                
                // Simple periodicity test
                let correlation = 0;
                let count = 0;
                
                for (let i = 0; i < signal.length - period; i += Math.max(1, Math.floor(period / 4))) {
                    if (i + period < signal.length) {
                        correlation += signal[i] * signal[i + Math.floor(period)];
                        count++;
                    }
                }
                
                if (count > 0) {
                    const harmonicStrength = Math.abs(correlation / count);
                    score += harmonicStrength / h; // Weight lower harmonics more
                }
            }
            
            return score;
        }
        
        function updateXiAnalysisPanel(result) {
            try {
                if (!result) {
                    document.getElementById('detectedPeriods').textContent = '---';
                    document.getElementById('dominantFrequency').textContent = '---';
                    document.getElementById('xiRatiosCount').textContent = '---';
                    document.getElementById('analysisTime').textContent = '---';
                    document.getElementById('engineStrategy').textContent = '---';
                    return;
                }
                
                document.getElementById('detectedPeriods').textContent = result.peaks ? result.peaks.length : 0;
                
                if (result.peaks && result.peaks.length > 0) {
                    document.getElementById('dominantFrequency').textContent = `${result.peaks[0].frequency.toFixed(1)} Hz`;
                } else {
                    document.getElementById('dominantFrequency').textContent = '--- Hz';
                }
                
                document.getElementById('xiRatiosCount').textContent = result.xiRatios ? result.xiRatios.length : 0;
                
                if (result.analysisTime) {
                    document.getElementById('analysisTime').textContent = `${result.analysisTime.toFixed(1)} ms`;
                }
                
                if (result.strategy) {
                    document.getElementById('engineStrategy').textContent = result.strategy.algorithm || 'Standard';
                }
                
                // Update signal info
                updateSignalInfo();
                
            } catch (error) {
                logMessage(`â ï¸ Î¾-Analyse Panel Update Fehler: ${error.message}`);
            }
        }
        
        // ===== GENERATOR FUNCTIONS =====
        function getGeneratorMode() {
            const activeBtn = document.querySelector('[data-mode].active');
            return activeBtn ? activeBtn.dataset.mode : 'frequency';
        }
        
        function getSymmetryMode() {
            const activeBtn = document.querySelector('[data-symmetry].active');
            return activeBtn ? activeBtn.dataset.symmetry : 'symmetric';
        }
        
        function switchGeneratorMode() {
            const mode = getGeneratorMode();
            const frequencyControls = document.getElementById('frequencyControls');
            const beatControls = document.getElementById('beatControls');
            const harmonicControls = document.getElementById('harmonicControls');
            const symmetrySelector = document.getElementById('symmetrySelector');
            
            // Hide all controls first
            frequencyControls.style.display = 'none';
            beatControls.style.display = 'none';
            harmonicControls.style.display = 'none';
            symmetrySelector.style.display = 'none';
            
            switch(mode) {
                case 'frequency':
                    frequencyControls.style.display = 'block';
                    logMessage('ðï¸ Wechsel zu Frequenz-Modus');
                    break;
                case 'beat':
                    beatControls.style.display = 'block';
                    symmetrySelector.style.display = 'flex';
                    initializeBeatMode();
                    logMessage('ðï¸ Wechsel zu Differenzton-Modus');
                    break;
                case 'harmonic':
                    harmonicControls.style.display = 'block';
                    logMessage('ðï¸ Wechsel zu Harmonik-Modus');
                    break;
            }
        }
        
        function initializeBeatMode() {
            const baseFreq = parseInt(document.getElementById('baseFreqSlider').value);
            const lowerFreq = parseInt(document.getElementById('lowerFreqSlider').value);
            const upperFreq = parseInt(document.getElementById('upperFreqSlider').value);
            
            const lowerBeat = Math.abs(baseFreq - lowerFreq);
            const upperBeat = Math.abs(upperFreq - baseFreq);
            
            document.getElementById('lowerBeatSlider').value = lowerBeat.toFixed(1);
            document.getElementById('lowerBeatValue').textContent = `${lowerBeat.toFixed(1)} Hz`;
            
            document.getElementById('upperBeatSlider').value = upperBeat.toFixed(1);
            document.getElementById('upperBeatValue').textContent = `${upperBeat.toFixed(1)} Hz`;
            
            logMessage(`ð Differenzton-Werte: ${lowerBeat.toFixed(1)}Hz, ${upperBeat.toFixed(1)}Hz`);
        }
        
        function updateSymmetryMode() {
            const symmetry = getSymmetryMode();
            
            if (symmetry === 'symmetric') {
                const lowerBeat = parseFloat(document.getElementById('lowerBeatSlider').value);
                document.getElementById('upperBeatSlider').value = lowerBeat.toFixed(1);
                document.getElementById('upperBeatValue').textContent = `${lowerBeat.toFixed(1)} Hz`;
                
                const lowerAmp = document.getElementById('lowerBeatAmpSlider').value;
                document.getElementById('upperBeatAmpSlider').value = lowerAmp;
                document.getElementById('upperBeatAmpValue').textContent = `${lowerAmp}%`;
                
                updateFrequenciesFromBeats();
                logMessage('ð Symmetrischer Modus aktiviert');
            } else {
                logMessage('ð Asymmetrischer Modus aktiviert');
            }
        }
        
        function updateFrequenciesFromBase() {
            const mode = getGeneratorMode();
            if (mode === 'beat') {
                updateFrequenciesFromBeats();
            }
        }
        
        function updateFrequenciesFromBeats() {
            const mode = getGeneratorMode();
            if (mode !== 'beat') return;
            
            const baseFreq = parseInt(document.getElementById('baseFreqSlider').value);
            const lowerBeat = parseFloat(document.getElementById('lowerBeatSlider').value);
            const upperBeat = parseFloat(document.getElementById('upperBeatSlider').value);
            
            const lowerFreq = baseFreq - lowerBeat;
            const upperFreq = baseFreq + upperBeat;
            
            document.getElementById('lowerFreqSlider').value = lowerFreq;
            document.getElementById('upperFreqSlider').value = upperFreq;
            
            logMessage(`ð Frequenzen: fáµ¤=${lowerFreq.toFixed(1)}Hz, fâ=${baseFreq}Hz, fâ=${upperFreq.toFixed(1)}Hz`);
        }
        
        // ===== SIGNAL GENERATION =====
        async function generateSignal() {
            try {
                logMessage('ðµ Starte Signal-Generierung...');
                
                const mode = getGeneratorMode();
                let signal;
                
                switch(mode) {
                    case 'frequency':
                        signal = generateFrequencyModeSignal();
                        break;
                    case 'beat':
                        signal = generateBeatModeSignal();
                        break;
                    case 'harmonic':
                        signal = generateHarmonicModeSignal();
                        break;
                    default:
                        throw new Error(`Unbekannter Modus: ${mode}`);
                }
                
                if (!signal) {
                    throw new Error('Signal-Generierung fehlgeschlagen');
                }
                
                // Normalization
                const normalizedSignal = normalizeSignal(signal);
                
                currentSignal = normalizedSignal;
                signalMetadata = {
                    type: 'generated',
                    mode: mode,
                    duration: SIGNAL_DURATION,
                    sampleRate: SAMPLE_RATE,
                    generatedAt: new Date().toISOString()
                };
                
                updateSignalInfo();
                drawOscilloscope(normalizedSignal);
                
                // Perform analyses
                await performXiHarmonicAnalysis(normalizedSignal);
                await performSpectrumAnalysis(normalizedSignal);
                
                updateStatus(`â ${mode}-Signal erfolgreich generiert`, 'success');
                logMessage('â Signal-Generierung abgeschlossen');
                
            } catch (error) {
                logMessage(`â Signal-Generierung fehlgeschlagen: ${error.message}`);
                updateStatus('â Signal-Generierung fehlgeschlagen', 'error');
            }
        }
        
        function generateFrequencyModeSignal() {
            const baseFreq = parseInt(document.getElementById('baseFreqSlider').value);
            const lowerFreq = parseInt(document.getElementById('lowerFreqSlider').value);
            const upperFreq = parseInt(document.getElementById('upperFreqSlider').value);
            
            const baseAmp = parseInt(document.getElementById('baseAmpSlider').value) / 100;
            const lowerAmp = parseInt(document.getElementById('lowerAmpSlider').value) / 100;
            const upperAmp = parseInt(document.getElementById('upperAmpSlider').value) / 100;
            
            logMessage(`ð Frequenz-Modus: ${baseFreq}Hz + ${lowerFreq}Hz + ${upperFreq}Hz`);
            
            return generateMultiFrequencySignal([
                {freq: baseFreq, amp: baseAmp},
                {freq: lowerFreq, amp: lowerAmp},
                {freq: upperFreq, amp: upperAmp}
            ]);
        }
        
        function generateBeatModeSignal() {
            const baseFreq = parseInt(document.getElementById('baseFreqSlider').value);
            const lowerBeat = parseFloat(document.getElementById('lowerBeatSlider').value);
            const upperBeat = parseFloat(document.getElementById('upperBeatSlider').value);
            
            const baseAmp = parseInt(document.getElementById('baseAmpSlider').value) / 100;
            const lowerAmp = parseInt(document.getElementById('lowerBeatAmpSlider').value) / 100;
            const upperAmp = parseInt(document.getElementById('upperBeatAmpSlider').value) / 100;
            
            const lowerFreq = baseFreq - lowerBeat;
            const upperFreq = baseFreq + upperBeat;
            
            logMessage(`ð Differenzton-Modus: ${baseFreq}Hz Â±${lowerBeat.toFixed(1)}Hz/Â±${upperBeat.toFixed(1)}Hz`);
            
            return generateMultiFrequencySignal([
                {freq: baseFreq, amp: baseAmp},
                {freq: lowerFreq, amp: lowerAmp},
                {freq: upperFreq, amp: upperAmp}
            ]);
        }
        
        function generateHarmonicModeSignal() {
            const baseFreq = parseInt(document.getElementById('baseFreqSlider').value);
            const harmonicCount = parseInt(document.getElementById('harmonicCountSlider').value);
            const intensity = parseFloat(document.getElementById('harmonicIntensitySlider').value);
            const baseAmp = parseInt(document.getElementById('baseAmpSlider').value) / 100;
            
            const frequencies = [];
            for (let i = 1; i <= harmonicCount; i++) {
                frequencies.push({
                    freq: baseFreq * i,
                    amp: baseAmp * Math.pow(intensity, i - 1)
                });
            }
            
            logMessage(`ð Harmonik-Modus: ${harmonicCount} Harmonische von ${baseFreq}Hz`);
            
            return generateMultiFrequencySignal(frequencies);
        }
        
        function generateMultiFrequencySignal(frequencies) {
            const samples = Math.floor(SIGNAL_DURATION * SAMPLE_RATE);
            const signal = new Float32Array(samples);
            
            for (let i = 0; i < samples; i++) {
                const t = i / SAMPLE_RATE;
                let sample = 0;
                
                frequencies.forEach(({freq, amp}) => {
                    if (freq > 0 && amp > 0) {
                        sample += amp * Math.sin(2 * Math.PI * freq * t);
                    }
                });
                
                signal[i] = sample;
            }
            
            return signal;
        }
        
        function normalizeSignal(signal) {
            logMessage('ð§ Signal-Normalisierung...');
            
            // Calculate signal statistics
            let maxAmp = 0;
            let rms = 0;
            for (let i = 0; i < signal.length; i++) {
                const abs = Math.abs(signal[i]);
                maxAmp = Math.max(maxAmp, abs);
                rms += signal[i] * signal[i];
            }
            rms = Math.sqrt(rms / signal.length);
            
            // IMPROVED: Better normalization strategy
            const normalizedSignal = new Float32Array(signal.length);
            
            // Determine normalization approach based on signal characteristics
            let targetLevel = 0.7; // More conservative default
            let normalizationFactor = 1.0;
            
            if (maxAmp > 0) {
                // Use RMS-based normalization for more natural levels
                const targetRms = 0.2; // Target RMS level
                if (rms > 0) {
                    normalizationFactor = Math.min(targetRms / rms, targetLevel / maxAmp);
                } else {
                    normalizationFactor = targetLevel / maxAmp;
                }
                
                // Limit maximum amplification to prevent noise boost
                normalizationFactor = Math.min(normalizationFactor, 2.0);
            }
            
            for (let i = 0; i < signal.length; i++) {
                let sample = signal[i] * normalizationFactor;
                
                // IMPROVED: Gentler soft limiting
                if (Math.abs(sample) > 0.8) {
                    sample = Math.sign(sample) * (0.8 + 0.2 * Math.tanh((Math.abs(sample) - 0.8) * 5));
                }
                
                normalizedSignal[i] = sample;
            }
            
            // Calculate final levels for logging
            let finalRms = 0;
            let finalMax = 0;
            for (let i = 0; i < normalizedSignal.length; i++) {
                const abs = Math.abs(normalizedSignal[i]);
                finalMax = Math.max(finalMax, abs);
                finalRms += normalizedSignal[i] * normalizedSignal[i];
            }
            finalRms = Math.sqrt(finalRms / normalizedSignal.length);
            
            logMessage(`ð Normalisierung: ${normalizationFactor.toFixed(3)}x, RMS: ${(rms*100).toFixed(1)}%â${(finalRms*100).toFixed(1)}%, Peak: ${(maxAmp*100).toFixed(1)}%â${(finalMax*100).toFixed(1)}%`);
            return normalizedSignal;
        }
        
        // ===== MICROPHONE FUNCTIONS =====
        async function startMicrophone() {
            try {
                updateStatus('ð¤ Mikrofon wird gestartet...', 'running');
                logMessage('ð¤ Starte Mikrofon...');
                
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                const constraints = { 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: SAMPLE_RATE,
                        latency: 0.01
                    }
                };
                
                micStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                const source = audioContext.createMediaStreamSource(micStream);
                micAnalyzer = audioContext.createAnalyser();
                micAnalyzer.fftSize = 8192;
                micAnalyzer.smoothingTimeConstant = 0.1;
                source.connect(micAnalyzer);
                
                micDataArray = new Uint8Array(micAnalyzer.frequencyBinCount);
                micTimeDataArray = new Float32Array(micAnalyzer.fftSize);
                isRecordingMic = true;
                
                // UI updates
                document.getElementById('micStartBtn').style.display = 'none';
                document.getElementById('micStopBtn').style.display = 'block';
                document.getElementById('micCaptureBtn').disabled = false;
                document.getElementById('liveAnalysisBtn').disabled = false;
                
                updateMicInfo('Aktiv', audioContext.sampleRate, 0);
                startMicLevelMonitoring();
                
                updateStatus('â Mikrofon aktiv', 'success');
                logMessage('â Mikrofon erfolgreich gestartet');
                
            } catch (error) {
                logMessage(`â Mikrofon-Fehler: ${error.message}`);
                updateStatus(`â Mikrofon-Fehler: ${error.message}`, 'error');
            }
        }
        
        function stopMicrophone() {
            isRecordingMic = false;
            
            stopLiveAnalysis();
            
            if (micLevelUpdateInterval) {
                clearInterval(micLevelUpdateInterval);
                micLevelUpdateInterval = null;
            }
            
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
                micStream = null;
            }
            
            isClipping = false;
            
            // UI updates
            document.getElementById('micStartBtn').style.display = 'block';
            document.getElementById('micStopBtn').style.display = 'none';
            document.getElementById('micCaptureBtn').disabled = true;
            document.getElementById('liveAnalysisBtn').disabled = true;
            
            updateMicLevel(0);
            updateMicInfo('Inaktiv', '---', '---');
            document.getElementById('frequencyIndicator').textContent = 'fâ: --- Hz';
            
            const clippingWarning = document.getElementById('clippingWarning');
            if (clippingWarning) clippingWarning.style.display = 'none';
            
            updateStatus('â¹ï¸ Mikrofon gestoppt', 'info');
            logMessage('â¹ï¸ Mikrofon gestoppt');
        }
        
        function startMicLevelMonitoring() {
            micLevelUpdateInterval = setInterval(() => {
                if (!isRecordingMic || !micAnalyzer || !micDataArray) return;
                
                micAnalyzer.getByteFrequencyData(micDataArray);
                micAnalyzer.getFloatTimeDomainData(micTimeDataArray);
                
                // Level calculation
                let sum = 0;
                let maxSample = 0;
                let clippedSamples = 0;
                let timeRms = 0;
                
                // Check for clipping and calculate time domain RMS
                for (let i = 0; i < micTimeDataArray.length; i++) {
                    const sample = Math.abs(micTimeDataArray[i]);
                    maxSample = Math.max(maxSample, sample);
                    timeRms += sample * sample;
                    if (sample > 0.95) clippedSamples++;
                }
                timeRms = Math.sqrt(timeRms / micTimeDataArray.length);
                
                // Calculate frequency domain RMS
                for (let i = 0; i < micDataArray.length; i++) {
                    sum += micDataArray[i] * micDataArray[i];
                }
                
                const rmsFreq = Math.sqrt(sum / micDataArray.length);
                const levelPercent = Math.round((rmsFreq / 255) * 100);
                const levelDb = rmsFreq > 0 ? (20 * Math.log10(rmsFreq / 255)).toFixed(1) : -60;
                
                updateMicLevel(levelPercent);
                updateMicInfo('Aktiv', audioContext.sampleRate, levelDb);
                
                // Clipping detection
                const clippingRatio = clippedSamples / micTimeDataArray.length;
                isClipping = clippingRatio > 0.01;
                
                const clippingWarning = document.getElementById('clippingWarning');
                if (clippingWarning) {
                    clippingWarning.style.display = isClipping ? 'block' : 'none';
                }
                
                // IMPROVED: Better frequency detection with multiple methods
                if (timeRms > noiseGateThreshold && !isClipping) {
                    const detectedFreq = detectFundamentalFrequency(micDataArray, micTimeDataArray);
                    
                    if (detectedFreq > 0) {
                        lastDetectedFundamental = detectedFreq;
                        document.getElementById('frequencyIndicator').textContent = `fâ: ${detectedFreq.toFixed(1)} Hz`;
                    } else {
                        document.getElementById('frequencyIndicator').textContent = 'fâ: [Suche...]';
                    }
                } else if (timeRms <= noiseGateThreshold) {
                    document.getElementById('frequencyIndicator').textContent = 'fâ: [Noise Gate]';
                } else {
                    document.getElementById('frequencyIndicator').textContent = 'fâ: [Clipping]';
                }
                
            }, 50); // 20 FPS
        }
        
        // IMPROVED: Better fundamental frequency detection
        function detectFundamentalFrequency(freqData, timeData) {
            // Method 1: Peak detection in frequency domain with harmonic analysis
            let peakFreq = 0;
            let maxMagnitude = 0;
            const minFreq = 80;  // Hz
            const maxFreq = 2000; // Hz
            
            const freqResolution = audioContext.sampleRate / (2 * freqData.length);
            const minBin = Math.floor(minFreq / freqResolution);
            const maxBin = Math.floor(maxFreq / freqResolution);
            
            // Find frequency domain peaks
            const peaks = [];
            for (let i = minBin; i < maxBin - 2; i++) {
                if (freqData[i] > freqData[i-1] && freqData[i] > freqData[i+1] && freqData[i] > 30) {
                    const freq = i * freqResolution;
                    const magnitude = freqData[i];
                    peaks.push({ freq, magnitude });
                }
            }
            
            // Sort peaks by magnitude
            peaks.sort((a, b) => b.magnitude - a.magnitude);
            
            // Method 2: Autocorrelation for fundamental detection
            const autocorrFreq = autocorrelationFundamental(timeData);
            
            // Method 3: Find best fundamental candidate
            let bestFundamental = 0;
            let bestScore = 0;
            
            // Test top frequency peaks
            for (let i = 0; i < Math.min(5, peaks.length); i++) {
                const testFreq = peaks[i].freq;
                const score = evaluateFundamentalCandidate(testFreq, peaks, autocorrFreq);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestFundamental = testFreq;
                }
            }
            
            // Also test autocorrelation result
            if (autocorrFreq > 0) {
                const autocorrScore = evaluateFundamentalCandidate(autocorrFreq, peaks, autocorrFreq);
                if (autocorrScore > bestScore) {
                    bestScore = autocorrScore;
                    bestFundamental = autocorrFreq;
                }
            }
            
            return bestScore > 0.3 ? bestFundamental : 0;
        }
        
        function autocorrelationFundamental(timeData) {
            const sampleRate = audioContext.sampleRate;
            const minPeriod = Math.floor(sampleRate / 2000); // 2000 Hz max
            const maxPeriod = Math.floor(sampleRate / 80);   // 80 Hz min
            
            let bestPeriod = 0;
            let maxCorrelation = 0;
            
            for (let period = minPeriod; period <= maxPeriod; period++) {
                let correlation = 0;
                let norm1 = 0;
                let norm2 = 0;
                
                const testLength = Math.min(period * 3, timeData.length - period);
                
                for (let i = 0; i < testLength; i++) {
                    const val1 = timeData[i];
                    const val2 = timeData[i + period];
                    
                    correlation += val1 * val2;
                    norm1 += val1 * val1;
                    norm2 += val2 * val2;
                }
                
                const normalizedCorr = correlation / Math.sqrt(norm1 * norm2 + 1e-10);
                
                if (normalizedCorr > maxCorrelation) {
                    maxCorrelation = normalizedCorr;
                    bestPeriod = period;
                }
            }
            
            return maxCorrelation > 0.3 ? sampleRate / bestPeriod : 0;
        }
        
        function evaluateFundamentalCandidate(testFreq, peaks, autocorrFreq) {
            let score = 0;
            
            // Score based on peak magnitude
            const peak = peaks.find(p => Math.abs(p.freq - testFreq) < 10);
            if (peak) {
                score += peak.magnitude / 255 * 0.5;
            }
            
            // Score based on harmonic series presence
            let harmonicScore = 0;
            for (let h = 2; h <= 6; h++) {
                const harmonicFreq = testFreq * h;
                const harmonic = peaks.find(p => Math.abs(p.freq - harmonicFreq) < 20);
                if (harmonic) {
                    harmonicScore += harmonic.magnitude / 255 / h;
                }
            }
            score += harmonicScore * 0.3;
            
            // Score based on autocorrelation agreement
            if (autocorrFreq > 0 && Math.abs(testFreq - autocorrFreq) < 20) {
                score += 0.2;
            }
            
            return score;
        }
        
        async function captureMicrophoneSignal() {
            if (!isRecordingMic || !micStream) {
                updateStatus('â ï¸ Bitte zuerst Mikrofon aktivieren', 'warning');
                return;
            }
            
            try {
                updateStatus('ð¹ 3s Aufnahme lÃ¤uft...', 'running');
                logMessage('ð¹ Starte 3-Sekunden-Aufnahme...');
                
                const mediaRecorder = new MediaRecorder(micStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                const audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    try {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        const arrayBuffer = await audioBlob.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        
                        let processedSignal = new Float32Array(audioBuffer.getChannelData(0));
                        
                        // Apply sensitivity scaling
                        for (let i = 0; i < processedSignal.length; i++) {
                            processedSignal[i] *= micSensitivity;
                        }
                        
                        if (processedSignal.length > SAMPLE_RATE * 3) {
                            processedSignal = processedSignal.slice(0, SAMPLE_RATE * 3);
                        }
                        
                        currentSignal = processedSignal;
                        signalMetadata = {
                            type: 'microphone',
                            duration: audioBuffer.duration,
                            sampleRate: audioBuffer.sampleRate,
                            channels: audioBuffer.numberOfChannels,
                            capturedAt: new Date().toISOString()
                        };
                        
                        updateSignalInfo();
                        drawOscilloscope(currentSignal);
                        
                        // Perform analyses
                        await performXiHarmonicAnalysis(currentSignal);
                        await performSpectrumAnalysis(currentSignal);
                        
                        updateStatus('â Mikrofon-Aufnahme abgeschlossen', 'success');
                        logMessage(`â Aufnahme: ${audioBuffer.duration.toFixed(1)}s erfolgreich`);
                        
                    } catch (error) {
                        logMessage(`â Aufnahme-Verarbeitung: ${error.message}`);
                        updateStatus('â Verarbeitung fehlgeschlagen', 'error');
                    }
                };
                
                mediaRecorder.start();
                setTimeout(() => mediaRecorder.stop(), 3000);
                
            } catch (error) {
                logMessage(`â Aufnahme-Fehler: ${error.message}`);
                updateStatus('â Aufnahme fehlgeschlagen', 'error');
            }
        }
        
        // ===== LIVE ANALYSIS =====
        function startLiveAnalysis() {
            if (!isRecordingMic || !micAnalyzer) {
                updateStatus('â ï¸ Bitte zuerst Mikrofon aktivieren', 'warning');
                return;
            }
            
            if (isLiveAnalysisRunning) return;
            
            isLiveAnalysisRunning = true;
            document.getElementById('liveAnalysisBtn').style.display = 'none';
            document.getElementById('stopLiveBtn').style.display = 'block';
            
            updateStatus('ð´ Live-Analyse aktiv', 'running');
            logMessage('ð´ Live-Analyse gestartet');
            
            startLiveVisualization();
        }
        
        function stopLiveAnalysis() {
            if (!isLiveAnalysisRunning) return;
            
            isLiveAnalysisRunning = false;
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            document.getElementById('liveAnalysisBtn').style.display = 'block';
            document.getElementById('stopLiveBtn').style.display = 'none';
            
            currentSignal = null;
            signalMetadata = null;
            currentXiResult = null;
            currentSpectrumResult = null;
            updateSignalInfo();
            updateXiAnalysisPanel(null);
            drawOscilloscope(null);
            drawSpectrum(null);
            
            updateStatus('â¹ï¸ Live-Analyse gestoppt', 'info');
            logMessage('â¹ï¸ Live-Analyse gestoppt');
        }
        
        function startLiveVisualization() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            if (isLiveAnalysisRunning) {
                animateLiveVisualization();
            }
        }
        
        async function animateLiveVisualization() {
            if (!isLiveAnalysisRunning || !micAnalyzer || !micTimeDataArray) {
                return;
            }
            
            try {
                micAnalyzer.getFloatTimeDomainData(micTimeDataArray);
                
                // Process signal
                const processedSignal = liveProcessing(micTimeDataArray);
                
                drawOscilloscope(processedSignal);
                
                // Perform analyses every few frames
                if (frameCount % 10 === 0) { // Every 10 frames
                    await performXiHarmonicAnalysis(processedSignal);
                }
                
                if (frameCount % 5 === 0) { // Every 5 frames for spectrum
                    await performSpectrumAnalysis(processedSignal);
                }
                
                animationId = requestAnimationFrame(animateLiveVisualization);
            } catch (error) {
                logMessage(`â ï¸ Live-Visualisierung Fehler: ${error.message}`);
                stopLiveAnalysis();
            }
        }
        
        function liveProcessing(rawSignal) {
            const filtered = new Float32Array(rawSignal.length);
            
            // Apply sensitivity scaling
            for (let i = 0; i < rawSignal.length; i++) {
                filtered[i] = rawSignal[i] * micSensitivity;
            }
            
            // Calculate signal level
            let signalLevel = 0;
            for (let i = 0; i < filtered.length; i++) {
                signalLevel += Math.abs(filtered[i]);
            }
            signalLevel /= filtered.length;
            
            // Apply noise gate
            if (signalLevel < noiseGateThreshold) {
                filtered.fill(0);
                return filtered;
            }
            
            // Simple smoothing filter
            const processedSignal = new Float32Array(filtered.length);
            let prev1 = 0, prev2 = 0;
            
            for (let i = 0; i < filtered.length; i++) {
                const input = filtered[i];
                const output = 0.25 * input + 0.5 * prev1 + 0.25 * prev2;
                processedSignal[i] = output;
                prev2 = prev1;
                prev1 = input;
            }
            
            // Soft limiting
            for (let i = 0; i < processedSignal.length; i++) {
                const sample = processedSignal[i];
                if (Math.abs(sample) > 0.9) {
                    processedSignal[i] = Math.sign(sample) * Math.tanh(Math.abs(sample) / 0.9) * 0.9;
                }
            }
            
            return processedSignal;
        }
        
        // ===== CONTINUOUS MODE =====
        function startContinuousMode() {
            if (isContinuousMode) return;
            
            isContinuousMode = true;
            document.getElementById('continuousBtn').style.display = 'none';
            document.getElementById('stopContinuousBtn').style.display = 'block';
            
            continuousInterval = setInterval(async () => {
                await generateSignal();
            }, 100);
            
            logMessage('ð Kontinuierlicher Modus gestartet');
            updateStatus('ð Kontinuierlicher Modus aktiv', 'running');
        }
        
        function stopContinuousMode() {
            if (!isContinuousMode) return;
            
            isContinuousMode = false;
            
            if (continuousInterval) {
                clearInterval(continuousInterval);
                continuousInterval = null;
            }
            
            document.getElementById('continuousBtn').style.display = 'block';
            document.getElementById('stopContinuousBtn').style.display = 'none';
            
            logMessage('â¹ï¸ Kontinuierlicher Modus gestoppt');
            updateStatus('â¹ï¸ Kontinuierlicher Modus gestoppt', 'info');
        }
        
        // ===== FILE FUNCTIONS =====
        function loadDemoSignal() {
            try {
                logMessage('ðµ Lade Demo-Signal...');
                
                // Generate A-Major chord demo signal
                const demo = DEMO_SIGNALS.chord_a_major;
                const frequencies = [];
                
                demo.frequencies.forEach((freq, idx) => {
                    frequencies.push({
                        freq: freq,
                        amp: demo.amplitudes[idx] * 0.7
                    });
                });
                
                const demoSignal = generateMultiFrequencySignal(frequencies);
                const normalizedSignal = normalizeSignal(demoSignal);
                
                currentSignal = normalizedSignal;
                signalMetadata = {
                    type: 'demo',
                    name: demo.name,
                    frequencies: demo.frequencies,
                    duration: SIGNAL_DURATION,
                    sampleRate: SAMPLE_RATE
                };
                
                updateSignalInfo();
                updateFileInfo(demo.name, 'Demo-Signal', 'Intern');
                drawOscilloscope(currentSignal);
                
                // Perform analyses
                performXiHarmonicAnalysis(currentSignal);
                performSpectrumAnalysis(currentSignal);
                
                updateStatus(`â Demo-Signal geladen: ${demo.name}`, 'success');
                logMessage(`â Demo-Signal geladen: ${demo.name}`);
                
            } catch (error) {
                logMessage(`â Demo-Signal Fehler: ${error.message}`);
                updateStatus('â Demo-Signal Fehler', 'error');
            }
        }
        
        function loadWavFile(file) {
            if (!file.name.toLowerCase().match(/\.(wav|mp3)$/)) {
                updateStatus('â ï¸ Bitte eine .wav oder .mp3 Datei auswÃ¤hlen', 'warning');
                return;
            }
            
            updateStatus('ð WAV wird geladen...', 'running');
            logMessage(`ð Lade WAV-Datei: ${file.name}`);
            
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const arrayBuffer = event.target.result;
                    
                    if (file.name.toLowerCase().endsWith('.wav')) {
                        processWavFile(arrayBuffer, file);
                    } else {
                        logMessage('â ï¸ MP3-UnterstÃ¼tzung vereinfacht');
                        updateStatus('â ï¸ Bitte WAV-Datei verwenden', 'warning');
                    }
                    
                } catch (error) {
                    logMessage(`â WAV-Fehler: ${error.message}`);
                    updateStatus(`â Datei-Fehler: ${error.message}`, 'error');
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        function processWavFile(arrayBuffer, file) {
            const dataView = new DataView(arrayBuffer);
            
            // WAV header validation
            const riffHeader = String.fromCharCode(
                dataView.getUint8(0), dataView.getUint8(1), 
                dataView.getUint8(2), dataView.getUint8(3)
            );
            
            if (riffHeader !== 'RIFF') {
                throw new Error('UngÃ¼ltige WAV-Datei');
            }
            
            // Audio parameter extraction
            const numChannels = dataView.getUint16(22, true);
            const sampleRate = dataView.getUint32(24, true);
            const bitsPerSample = dataView.getUint16(34, true);
            
            logMessage(`ð WAV-Info: ${numChannels}ch, ${sampleRate}Hz, ${bitsPerSample}bit`);
            
            if (bitsPerSample !== 16 && bitsPerSample !== 24 && bitsPerSample !== 32) {
                throw new Error('UnterstÃ¼tzt 16-bit, 24-bit und 32-bit WAV');
            }
            
            // Audio data extraction
            const dataOffset = 44;
            const bytesPerSample = bitsPerSample / 8;
            const numSamples = Math.floor((arrayBuffer.byteLength - dataOffset) / (numChannels * bytesPerSample));
            const signal = new Float32Array(numSamples);
            
            // IMPROVED: Better sample extraction with proper scaling
            for (let i = 0; i < numSamples; i++) {
                const sampleOffset = dataOffset + i * numChannels * bytesPerSample;
                let sample;
                
                if (bitsPerSample === 16) {
                    sample = dataView.getInt16(sampleOffset, true) / 32768.0;
                } else if (bitsPerSample === 24) {
                    const byte1 = dataView.getUint8(sampleOffset);
                    const byte2 = dataView.getUint8(sampleOffset + 1);
                    const byte3 = dataView.getUint8(sampleOffset + 2);
                    const sample24 = (byte3 << 16) | (byte2 << 8) | byte1;
                    sample = (sample24 > 8388607 ? sample24 - 16777216 : sample24) / 8388608.0;
                } else if (bitsPerSample === 32) {
                    sample = dataView.getFloat32(sampleOffset, true);
                }
                
                // Stereo to mono conversion
                if (numChannels === 2) {
                    let rightSample;
                    const rightOffset = sampleOffset + bytesPerSample;
                    
                    if (bitsPerSample === 16) {
                        rightSample = dataView.getInt16(rightOffset, true) / 32768.0;
                    } else if (bitsPerSample === 24) {
                        const byte1 = dataView.getUint8(rightOffset);
                        const byte2 = dataView.getUint8(rightOffset + 1);
                        const byte3 = dataView.getUint8(rightOffset + 2);
                        const rightSample24 = (byte3 << 16) | (byte2 << 8) | byte1;
                        rightSample = (rightSample24 > 8388607 ? rightSample24 - 16777216 : rightSample24) / 8388608.0;
                    } else if (bitsPerSample === 32) {
                        rightSample = dataView.getFloat32(rightOffset, true);
                    }
                    
                    sample = (sample + rightSample) / 2;
                }
                
                signal[i] = sample;
            }
            
            // IMPROVED: Check signal levels and warn if too hot
            let maxLevel = 0;
            let rmsLevel = 0;
            for (let i = 0; i < signal.length; i++) {
                const abs = Math.abs(signal[i]);
                maxLevel = Math.max(maxLevel, abs);
                rmsLevel += signal[i] * signal[i];
            }
            rmsLevel = Math.sqrt(rmsLevel / signal.length);
            
            // Log signal levels for debugging
            logMessage(`ð WAV-Pegel: Peak=${(maxLevel*100).toFixed(1)}%, RMS=${(rmsLevel*100).toFixed(1)}%`);
            
            // Warn if signal is very hot
            if (maxLevel > 0.95) {
                logMessage('â ï¸ Signal ist sehr laut - mÃ¶glicherweise geclippt');
                updateStatus('â ï¸ Signal sehr laut - Frequenzerkennung kann beeintrÃ¤chtigt sein', 'warning');
            }
            
            // Resampling if needed
            let finalSignal = signal;
            if (sampleRate !== SAMPLE_RATE) {
                finalSignal = resampleSignal(signal, sampleRate, SAMPLE_RATE);
                logMessage(`ð Resampling: ${sampleRate}Hz â ${SAMPLE_RATE}Hz`);
            }
            
            // IMPROVED: Apply gentle level normalization only if needed
            if (maxLevel > 0.8 || rmsLevel > 0.3) {
                logMessage('ð§ Datei-Signal wird sanft normalisiert...');
                finalSignal = normalizeSignal(finalSignal);
            }
            
            currentSignal = finalSignal;
            signalMetadata = {
                type: 'wav_file',
                filename: file.name,
                originalSampleRate: sampleRate,
                originalChannels: numChannels,
                originalBitDepth: bitsPerSample,
                originalPeakLevel: maxLevel,
                originalRmsLevel: rmsLevel,
                duration: finalSignal.length / SAMPLE_RATE,
                sampleRate: SAMPLE_RATE,
                fileSize: file.size
            };
            
            updateSignalInfo();
            updateFileInfo(
                file.name, 
                `${numChannels}ch/${sampleRate}Hz/${bitsPerSample}bit`, 
                file.size
            );
            drawOscilloscope(currentSignal);
            
            // Perform analyses
            performXiHarmonicAnalysis(currentSignal);
            performSpectrumAnalysis(currentSignal);
            
            updateStatus(`â ${file.name} geladen`, 'success');
            logMessage(`â WAV-Datei erfolgreich geladen: ${file.name}`);
        }
        
        function resampleSignal(inputSignal, fromRate, toRate) {
            if (fromRate === toRate) return inputSignal;
            
            const ratio = fromRate / toRate;
            const outputLength = Math.floor(inputSignal.length / ratio);
            const outputSignal = new Float32Array(outputLength);
            
            // Linear interpolation
            for (let i = 0; i < outputLength; i++) {
                const srcIndex = i * ratio;
                const srcIndexFloor = Math.floor(srcIndex);
                const fraction = srcIndex - srcIndexFloor;
                
                if (srcIndexFloor + 1 < inputSignal.length) {
                    outputSignal[i] = inputSignal[srcIndexFloor] * (1 - fraction) + 
                                     inputSignal[srcIndexFloor + 1] * fraction;
                } else {
                    outputSignal[i] = inputSignal[srcIndexFloor];
                }
            }
            
            return outputSignal;
        }
        
        // ===== VISUALIZATION =====
        function drawOscilloscope(signal) {
            const canvas = oscilloscopeCanvas;
            const ctx = oscilloscopeCtx;
            
            if (!canvas || !ctx) return;
            
            // Performance throttling
            const now = Date.now();
            if (now - lastDrawTime < DRAW_THROTTLE_MS) {
                return; // Skip this frame
            }
            lastDrawTime = now;
            
            frameCount++; // Performance monitoring
            
            const width = canvas.width;
            const height = canvas.height;
            
            // Background
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#000000');
            gradient.addColorStop(0.5, '#0a0a0a');
            gradient.addColorStop(1, '#000000');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            drawGrid(ctx, width, height, '#333333');
            
            if (!signal || signal.length === 0) {
                ctx.fillStyle = '#667eea';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Î¾-Oszilloskop mit Spektrum-Analyzer bereit', width / 2, height / 2 - 10);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#888888';
                ctx.fillText('Î¾-FFT Engine v2.0 â¢ Performance-Optimiert â¢ Adaptive Algorithmen', width / 2, height / 2 + 15);
                return;
            }
            
            const margin = 40;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;
            
            const samplesForTimeRange = Math.floor((timeRangeMs / 1000) * SAMPLE_RATE);
            const maxSamples = Math.min(signal.length, samplesForTimeRange);
            
            // Waveform rendering
            ctx.strokeStyle = '#00ff41';
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowColor = '#00ff41';
            ctx.shadowBlur = 3;
            
            ctx.beginPath();
            
            let hasStarted = false;
            const step = Math.max(1, Math.floor(maxSamples / (plotWidth * 2)));
            
            for (let i = 0; i < maxSamples; i += step) {
                const x = margin + (i / maxSamples) * plotWidth;
                let amplitude = signal[i] || 0;
                
                // Amplitude processing
                amplitude = Math.max(-1, Math.min(1, amplitude * amplificationFactor));
                if (Math.abs(amplitude) > 0.95) {
                    amplitude = Math.sign(amplitude) * Math.tanh(Math.abs(amplitude) * 0.95);
                }
                
                const y = margin + plotHeight / 2 - (amplitude * plotHeight / 2 * 0.9);
                
                if (!hasStarted) {
                    ctx.moveTo(x, y);
                    hasStarted = true;
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Zero line
            ctx.strokeStyle = '#444444';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(margin, height / 2);
            ctx.lineTo(width - margin, height / 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            drawOscilloscopeLabels(ctx, width, height, margin, timeRangeMs);
        }
        
        function drawSpectrum(result) {
            const canvas = spectrumCanvas;
            const ctx = spectrumCtx;
            
            if (!canvas || !ctx) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            // Background with spectrum-specific gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#001122');
            gradient.addColorStop(0.5, '#112233');
            gradient.addColorStop(1, '#001122');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            drawSpectrumGrid(ctx, width, height);
            
            if (!result || !result.magnitude) {
                ctx.fillStyle = '#00ff88';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Spektrum-Analyzer bereit', width / 2, height / 2 - 10);
                ctx.font = '12px Arial';
                ctx.fillStyle = '#66ccaa';
                ctx.fillText(`Modus: ${spectrumMode.toUpperCase()} | FFT-GrÃ¶Ãe: ${fftSpectrumAnalyzer ? fftSpectrumAnalyzer.config.fftSize : 'N/A'}`, width / 2, height / 2 + 15);
                return;
            }
            
            const margin = 40;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;
            
            if (result.type === 'waterfall' && result.waterfallData) {
                drawWaterfall(ctx, result.waterfallData, margin, plotWidth, plotHeight);
            } else {
                drawSpectrumLine(ctx, result, margin, plotWidth, plotHeight);
            }
            
            drawSpectrumLabels(ctx, width, height, margin);
        }
        
        function drawSpectrumLine(ctx, result, margin, plotWidth, plotHeight) {
            const magnitude = result.magnitude;
            const frequencies = result.frequencies;
            
            if (!magnitude || !frequencies) return;
            
            // Filter data to frequency range
            const maxFreqIndex = frequencies.findIndex(f => f > freqRangeHz);
            const endIndex = maxFreqIndex > 0 ? maxFreqIndex : frequencies.length;
            
            // Convert to display mode
            const displayMode = document.getElementById('spectrumDisplay').value;
            const displayData = convertMagnitudeForDisplay(magnitude.slice(0, endIndex), displayMode);
            
            // Draw spectrum line
            ctx.strokeStyle = result.type === 'xi' ? '#ff6600' : '#00ff88';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowColor = result.type === 'xi' ? '#ff6600' : '#00ff88';
            ctx.shadowBlur = 2;
            
            ctx.beginPath();
            
            let hasStarted = false;
            for (let i = 0; i < displayData.length; i++) {
                const freq = frequencies[i];
                const mag = displayData[i];
                
                if (freq <= freqRangeHz) {
                    const x = margin + (freq / freqRangeHz) * plotWidth;
                    let y;
                    
                    if (displayMode === 'db') {
                        // dB scale: -120 to 0 dB
                        const dbValue = 20 * Math.log10(Math.max(mag, 1e-6));
                        const normalizedDb = Math.max(0, (dbValue + dbRange) / dbRange);
                        y = margin + plotHeight * (1 - normalizedDb);
                    } else {
                        // Linear scale
                        const normalizedMag = Math.min(1, mag);
                        y = margin + plotHeight * (1 - normalizedMag);
                    }
                    
                    if (!hasStarted) {
                        ctx.moveTo(x, y);
                        hasStarted = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            }
            
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Draw peaks
            if (result.peaks && result.peaks.length > 0) {
                drawSpectrumPeaks(ctx, result.peaks, margin, plotWidth, plotHeight, displayMode);
            }
        }
        
        function drawWaterfall(ctx, waterfallData, margin, plotWidth, plotHeight) {
            if (!waterfallData || waterfallData.length === 0) return;
            
            const lineHeight = plotHeight / waterfallData.length;
            
            for (let lineIndex = 0; lineIndex < waterfallData.length; lineIndex++) {
                const magnitude = waterfallData[lineIndex];
                const y = margin + lineIndex * lineHeight;
                
                // Filter to frequency range
                const maxFreqIndex = Math.floor(magnitude.length * freqRangeHz / (SAMPLE_RATE / 2));
                
                for (let i = 0; i < maxFreqIndex; i++) {
                    const x = margin + (i / maxFreqIndex) * plotWidth;
                    const mag = magnitude[i];
                    
                    // Color mapping based on magnitude
                    const intensity = Math.min(1, mag * 10);
                    const hue = 240 - intensity * 120; // Blue to red
                    const saturation = 100;
                    const lightness = intensity * 50;
                    
                    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    ctx.fillRect(x, y, Math.max(1, plotWidth / maxFreqIndex), lineHeight + 1);
                }
            }
        }
        
        function drawSpectrumPeaks(ctx, peaks, margin, plotWidth, plotHeight, displayMode) {
            ctx.fillStyle = '#ffff00';
            ctx.font = '10px Arial';
            
            for (let i = 0; i < Math.min(peaks.length, 10); i++) {
                const peak = peaks[i];
                const freq = peak.frequency;
                
                if (freq <= freqRangeHz) {
                    const x = margin + (freq / freqRangeHz) * plotWidth;
                    let y;
                    
                    if (displayMode === 'db') {
                        const dbValue = 20 * Math.log10(Math.max(peak.magnitude, 1e-6));
                        const normalizedDb = Math.max(0, (dbValue + dbRange) / dbRange);
                        y = margin + plotHeight * (1 - normalizedDb);
                    } else {
                        const normalizedMag = Math.min(1, peak.magnitude);
                        y = margin + plotHeight * (1 - normalizedMag);
                    }
                    
                    // Peak marker
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Frequency label
                    if (i < 5) { // Only label top 5 peaks
                        ctx.fillText(`${freq.toFixed(1)}Hz`, x - 20, y - 8);
                    }
                }
            }
        }
        
        function convertMagnitudeForDisplay(magnitude, mode) {
            const result = new Float32Array(magnitude.length);
            
            switch(mode) {
                case 'magnitude':
                    return magnitude;
                    
                case 'power':
                    for (let i = 0; i < magnitude.length; i++) {
                        result[i] = magnitude[i] * magnitude[i];
                    }
                    break;
                    
                case 'db':
                    return magnitude; // dB conversion handled in drawing
                    
                case 'log':
                    for (let i = 0; i < magnitude.length; i++) {
                        result[i] = Math.log10(Math.max(magnitude[i], 1e-6));
                    }
                    break;
                    
                default:
                    return magnitude;
            }
            
            return result;
        }
        
        function drawGrid(ctx, width, height, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 0.5;
            ctx.globalAlpha = 0.25;
            
            const gridSpacingX = width / 20;
            const gridSpacingY = height / 12;
            
            for (let x = gridSpacingX; x < width; x += gridSpacingX) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            for (let y = gridSpacingY; y < height; y += gridSpacingY) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Center lines
            ctx.strokeStyle = color.replace('#333333', '#666666');
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.7;
            
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
            
            ctx.globalAlpha = 1.0;
        }
        
        function drawSpectrumGrid(ctx, width, height) {
            ctx.strokeStyle = '#004444';
            ctx.lineWidth = 0.5;
            ctx.globalAlpha = 0.3;
            
            const gridSpacingX = width / 10; // 10 frequency divisions
            const gridSpacingY = height / 8;  // 8 amplitude divisions
            
            for (let x = gridSpacingX; x < width; x += gridSpacingX) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            for (let y = gridSpacingY; y < height; y += gridSpacingY) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        function drawOscilloscopeLabels(ctx, width, height, margin, timeRangeMs) {
            ctx.fillStyle = '#ffffff';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            
            // Time labels
            const timeSteps = 10;
            for (let i = 0; i <= timeSteps; i++) {
                const x = margin + (i / timeSteps) * (width - 2 * margin);
                const timeMs = (i / timeSteps) * timeRangeMs;
                ctx.fillText(`${timeMs.toFixed(1)}ms`, x, height - 8);
            }
            
            // Amplitude labels
            ctx.textAlign = 'left';
            ctx.fillStyle = '#cccccc';
            ctx.fillText('+1.0', 8, margin + 5);
            ctx.fillText('0.0', 8, height / 2 + 5);
            ctx.fillText('-1.0', 8, height - margin + 5);
            
            // Profile indicator
            ctx.fillStyle = '#00ffff';
            ctx.font = '10px Arial';
            if (xiHarmonicAnalyzer) {
                ctx.fillText(`Î¾-Harmonic: ${xiHarmonicAnalyzer.config.profile.toUpperCase()}`, 8, margin + 20);
            }
            
            // Axis labels
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#00ff41';
            ctx.fillText(`Zeit (${timeRangeMs} ms â¢ ${amplificationFactor.toFixed(1)}x â¢ FPS: ${currentFps})`, width / 2, height - 25);
        }
        
        function drawSpectrumLabels(ctx, width, height, margin) {
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            // Frequency labels
            const freqSteps = 5;
            for (let i = 0; i <= freqSteps; i++) {
                const x = margin + (i / freqSteps) * (width - 2 * margin);
                const freq = (i / freqSteps) * freqRangeHz;
                ctx.fillText(`${freq.toFixed(0)}Hz`, x, height - 8);
            }
            
            // Amplitude labels (dB scale)
            const displayMode = document.getElementById('spectrumDisplay').value;
            ctx.textAlign = 'left';
            ctx.fillStyle = '#aaccaa';
            
            if (displayMode === 'db') {
                ctx.fillText('0 dB', 8, margin + 5);
                ctx.fillText(`-${Math.floor(dbRange/2)} dB`, 8, height / 2 + 5);
                ctx.fillText(`-${dbRange} dB`, 8, height - margin + 5);
            } else {
                ctx.fillText('1.0', 8, margin + 5);
                ctx.fillText('0.5', 8, height / 2 + 5);
                ctx.fillText('0.0', 8, height - margin + 5);
            }
            
            // Axis labels
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#00ff88';
            ctx.fillText(`Frequenz (0-${freqRangeHz}Hz â¢ ${spectrumMode.toUpperCase()} â¢ ${displayMode.toUpperCase()})`, width / 2, height - 25);
        }
        
        // ===== UI UPDATES =====
        function updateSignalInfo() {
            try {
                if (!signalMetadata) {
                    document.getElementById('signalType').textContent = 'Bereit';
                    document.getElementById('signalFreqs').textContent = '--- Hz';
                    document.getElementById('detectedFundamental').textContent = '--- Hz';
                    return;
                }
                
                const meta = signalMetadata;
                let typeText = '';
                let freqText = '';
                
                switch(meta.type) {
                    case 'generated':
                        typeText = `${meta.mode} Signal`;
                        freqText = 'Generiert';
                        break;
                    case 'microphone':
                        typeText = 'Mikrofon';
                        freqText = `${meta.sampleRate}Hz`;
                        break;
                    case 'wav_file':
                        typeText = 'WAV-Datei';
                        freqText = `${meta.originalSampleRate}Hz â ${meta.sampleRate}Hz`;
                        break;
                    case 'demo':
                        typeText = `Demo: ${meta.name}`;
                        freqText = meta.frequencies.map(f => f.toFixed(0)).join(', ') + ' Hz';
                        break;
                    default:
                        typeText = 'Signal';
                        freqText = '--- Hz';
                }
                
                document.getElementById('signalType').textContent = typeText;
                document.getElementById('signalFreqs').textContent = freqText;
                
                if (lastDetectedFundamental) {
                    document.getElementById('detectedFundamental').textContent = `${lastDetectedFundamental.toFixed(1)} Hz`;
                    document.getElementById('frequencyIndicator').textContent = `fâ: ${lastDetectedFundamental.toFixed(1)} Hz`;
                } else {
                    document.getElementById('detectedFundamental').textContent = '--- Hz';
                }
                
            } catch (error) {
                logMessage(`â ï¸ Signal-Info Update Fehler: ${error.message}`);
            }
        }
        
        function updateMicLevel(percent) {
            try {
                const indicator = document.getElementById('micLevelIndicator');
                const text = document.getElementById('micLevelText');
                
                if (indicator) {
                    indicator.style.width = `${percent}%`;
                    if (percent > 85) {
                        indicator.style.background = 'linear-gradient(90deg, #ff4757 0%, #ff3742 100%)';
                    } else if (percent > 70) {
                        indicator.style.background = 'linear-gradient(90deg, #ffa500 0%, #ff6348 100%)';
                    } else if (percent > 50) {
                        indicator.style.background = 'linear-gradient(90deg, #32cd32 0%, #ffa500 50%, #2ed573 100%)';
                    } else {
                        indicator.style.background = 'linear-gradient(90deg, #32cd32 0%, #2ed573 100%)';
                    }
                }
                if (text) text.textContent = `${percent}%`;
            } catch (error) {
                // Ignore UI update errors
            }
        }
        
        function updateMicInfo(status, sampleRate, peakLevel) {
            try {
                const statusEl = document.getElementById('micStatus');
                const rateEl = document.getElementById('micSampleRate');
                const levelEl = document.getElementById('micPeakLevel');
                
                if (statusEl) statusEl.textContent = status;
                if (rateEl) {
                    const rateText = typeof sampleRate === 'number' ? `${sampleRate} Hz` : sampleRate;
                    rateEl.textContent = rateText;
                }
                if (levelEl) {
                    levelEl.textContent = typeof peakLevel === 'number' ? `${peakLevel} dB` : peakLevel;
                }
            } catch (error) {
                // Ignore UI update errors
            }
        }
        
        function updateFileInfo(filename, format, size) {
            try {
                const nameEl = document.getElementById('fileName');
                const formatEl = document.getElementById('fileFormat');
                const sizeEl = document.getElementById('fileSize');
                
                if (nameEl) nameEl.textContent = filename || 'Keine geladen';
                if (formatEl) formatEl.textContent = format || '---';
                if (sizeEl) {
                    if (typeof size === 'number') {
                        sizeEl.textContent = `${(size/1024).toFixed(1)} KB`;
                    } else {
                        sizeEl.textContent = size || '--- KB';
                    }
                }
            } catch (error) {
                // Ignore UI update errors
            }
        }
        
        // ===== EXPORT FUNCTIONS =====
        function exportSignalAsWav() {
            if (!currentSignal || currentSignal.length === 0) {
                updateStatus('â ï¸ Kein Signal zum Exportieren', 'warning');
                return;
            }
            
            try {
                updateStatus('ð¾ WAV wird erstellt...', 'running');
                
                const header = createWavHeader(SAMPLE_RATE, 1, currentSignal.length, 16);
                const pcmData = floatTo16BitPCM(currentSignal);
                const pcmBytes = new Uint8Array(pcmData.buffer);
                
                const wavData = new Uint8Array(header.length + pcmBytes.length);
                wavData.set(header, 0);
                wavData.set(pcmBytes, header.length);
                
                let filename = 'xi_oszilloskop_signal';
                if (signalMetadata) {
                    const timestamp = new Date().toISOString().slice(0,19).replace(/[:.]/g, '-');
                    filename = `xi_${signalMetadata.type}_${timestamp}`;
                }
                filename += '.wav';
                
                const blob = new Blob([wavData], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                updateStatus(`â ${filename} gespeichert`, 'success');
                logMessage(`ð¾ WAV exportiert: ${filename}`);
                
            } catch (error) {
                logMessage(`â Export-Fehler: ${error.message}`);
                updateStatus('â Export fehlgeschlagen', 'error');
            }
        }
        
        function createWavHeader(sampleRate, numChannels, numSamples, bitsPerSample = 16) {
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            const dataSize = numSamples * numChannels * bitsPerSample / 8;
            const fileSize = 36 + dataSize;
            
            const buffer = new ArrayBuffer(44);
            const view = new DataView(buffer);
            
            view.setUint32(0, 0x52494646, false); // "RIFF"
            view.setUint32(4, fileSize, true);
            view.setUint32(8, 0x57415645, false); // "WAVE"
            view.setUint32(12, 0x666d7420, false); // "fmt "
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM format
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            view.setUint32(36, 0x64617461, false); // "data"
            view.setUint32(40, dataSize, true);
            
            return new Uint8Array(buffer);
        }
        
        function floatTo16BitPCM(floatArray) {
            const pcmArray = new Int16Array(floatArray.length);
            for (let i = 0; i < floatArray.length; i++) {
                const clamped = Math.max(-1, Math.min(1, floatArray[i]));
                const scaled = clamped * 32767;
                
                // Triangular dithering
                const dither = (Math.random() + Math.random() - 1) * 0.5;
                pcmArray[i] = Math.round(scaled + dither);
            }
            return pcmArray;
        }
        
        function saveLog() {
            try {
                const logContainer = document.getElementById('logContainer');
                if (!logContainer) return;
                
                const timestamp = new Date().toISOString().slice(0,19).replace(/[:.]/g, '-');
                const header = `Î¾-OSZILLOSKOP mit SPEKTRUM-ANALYZER LOG\nGeneriert: ${new Date().toLocaleString()}\nVersion: Î¾-Harmonic Analyzer v2.0 + FFT Spektrum\n${'='.repeat(70)}\n\n`;
                
                const logText = logContainer.textContent || '';
                
                let systemInfo = '\nSYSTEM INFO:\n';
                systemInfo += `- Audio Context: ${audioContext ? audioContext.state : 'Nicht verfÃ¼gbar'}\n`;
                systemInfo += `- Sample Rate: ${SAMPLE_RATE} Hz\n`;
                systemInfo += `- Aktuelles Signal: ${signalMetadata ? signalMetadata.type : 'Keines'}\n`;
                systemInfo += `- Letzte Grundfrequenz: ${lastDetectedFundamental ? lastDetectedFundamental.toFixed(1) + ' Hz' : 'Keine'}\n`;
                systemInfo += `- Performance: ${currentFps} FPS\n`;
                systemInfo += `- Spektrum-Modus: ${spectrumMode.toUpperCase()}\n`;
                
                if (xiHarmonicAnalyzer) {
                    const config = xiHarmonicAnalyzer.config;
                    systemInfo += `\nÎ¾-HARMONIC ANALYZER INFO:\n`;
                    systemInfo += `- Profil: ${config.profile}\n`;
                    systemInfo += `- Î¾-Parameter: ${config.xiValue}\n`;
                    systemInfo += `- Schwellwert: ${config.threshold}\n`;
                    systemInfo += `- Cache-GrÃ¶Ãe: ${xiHarmonicAnalyzer.cache.size}\n`;
                    systemInfo += `- Methode: Autokorrelation + Î¾-Bewertung\n`;
                }
                
                if (fftSpectrumAnalyzer) {
                    const config = fftSpectrumAnalyzer.config;
                    systemInfo += `\nFFT SPEKTRUM-ANALYZER INFO:\n`;
                    systemInfo += `- FFT-GrÃ¶Ãe: ${config.fftSize}\n`;
                    systemInfo += `- Fenster-Funktion: ${config.windowFunction}\n`;
                    systemInfo += `- Averaging: ${config.averagingFrames} Frames\n`;
                    systemInfo += `- Frequenz-Bereich: 0-${freqRangeHz} Hz\n`;
                    systemInfo += `- dB-Bereich: ${dbRange} dB\n`;
                }
                
                if (currentXiResult) {
                    systemInfo += `\nLETZTE Î¾-HARMONIC ANALYSE:\n`;
                    systemInfo += `- Peaks: ${currentXiResult.peaks ? currentXiResult.peaks.length : 0}\n`;
                    systemInfo += `- Î¾-Ratios: ${currentXiResult.xiRatios ? currentXiResult.xiRatios.length : 0}\n`;
                    if (currentXiResult.analysisTime) {
                        systemInfo += `- Analyse-Zeit: ${currentXiResult.analysisTime.toFixed(1)}ms\n`;
                    }
                    if (currentXiResult.strategy) {
                        systemInfo += `- Strategie: ${currentXiResult.strategy.algorithm}\n`;
                        systemInfo += `- Beschreibung: ${currentXiResult.strategy.description || 'Standard'}\n`;
                    }
                }
                
                if (currentSpectrumResult) {
                    systemInfo += `\nLETZTE SPEKTRUM-ANALYSE:\n`;
                    systemInfo += `- Typ: ${currentSpectrumResult.type ? currentSpectrumResult.type.toUpperCase() : 'UNKNOWN'}\n`;
                    systemInfo += `- Peaks: ${currentSpectrumResult.peaks ? currentSpectrumResult.peaks.length : 0}\n`;
                    if (currentSpectrumResult.fftSize) {
                        systemInfo += `- FFT-GrÃ¶Ãe: ${currentSpectrumResult.fftSize}\n`;
                    }
                }
                
                // Microphone info
                if (isRecordingMic) {
                    systemInfo += `\nMIKROFON INFO:\n`;
                    systemInfo += `- Mikrofon aktiv: Empfindlichkeit=${micSensitivity.toFixed(1)}x\n`;
                    systemInfo += `- Noise Gate: ${noiseGateThreshold.toFixed(2)}\n`;
                    systemInfo += `- Clipping erkannt: ${isClipping ? 'JA' : 'NEIN'}\n`;
                    systemInfo += `- Live-Analyse: ${isLiveAnalysisRunning ? 'AKTIV' : 'INAKTIV'}\n`;
                }
                
                const fullContent = header + logText + systemInfo + `\n\n${'='.repeat(70)}\nÎ¾-Harmonic Analyzer + Spektrum Log Ende`;
                
                const blob = new Blob([fullContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `xi-oszilloskop-spektrum_${timestamp}.txt`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                updateStatus(`â Log gespeichert`, 'success');
                logMessage(`ð¾ Log-Datei gespeichert`);
                
            } catch (error) {
                logMessage(`â Log-Speichern Fehler: ${error.message}`);
            }
        }
        
        function logMessage(message) {
            try {
                const logContainer = document.getElementById('logContainer');
                if (logContainer) {
                    const timestamp = new Date().toLocaleTimeString();
                    const lines = logContainer.innerHTML.split('<br>');
                    
                    if (lines.length > LOG_MAX_LINES) {
                        lines.splice(0, lines.length - LOG_MAX_LINES);
                        logContainer.innerHTML = lines.join('<br>');
                    }
                    
                    logContainer.innerHTML += `<br>[${timestamp}] ${message}`;
                    logContainer.scrollTop = logContainer.scrollHeight;
                }
                console.log(`[Î¾-Oszilloskop Spektrum] ${message}`);
            } catch (error) {
                console.log(`[Î¾-Oszilloskop Spektrum] ${message}`);
            }
        }
        
        function updateStatus(message, type = 'info') {
            try {
                const statusDisplay = document.getElementById('statusDisplay');
                if (statusDisplay) {
                    statusDisplay.textContent = message;
                    
                    const colors = {
                        success: 'linear-gradient(135deg, #2ed573 0%, #17a2b8 100%)',
                        error: 'linear-gradient(135deg, #ff4757 0%, #ff3742 100%)',
                        running: 'linear-gradient(135deg, #ffa502 0%, #ff6348 100%)',
                        warning: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                        info: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'
                    };
                    
                    statusDisplay.style.background = colors[type] || colors.info;
                    
                    statusDisplay.style.transform = 'scale(1.02)';
                    setTimeout(() => {
                        statusDisplay.style.transform = 'scale(1.0)';
                    }, 200);
                }
            } catch (error) {
                console.error('Status update error:', error);
            }
        }
        
        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(initializeSystem, 100);
        });
        
        // Error handling
        window.addEventListener('error', function(event) {
            logMessage(`â System Error: ${event.message}`);
            updateStatus('â System Error - siehe Log', 'error');
        });
        
        // Performance monitoring
        window.addEventListener('beforeunload', function() {
            if (isRecordingMic) {
                stopMicrophone();
            }
            if (isContinuousMode) {
                stopContinuousMode();
            }
        });
        
        console.log('ð¬ Î¾-Oszilloskop mit Spektrum-Analyzer geladen - Version 2.0');
        console.log('â¨ Features: Î¾-Harmonic Analyzer v2.0 â¢ Autokorrelations-basiert â¢ Harmonik-Analyse â¢ FFT-Spektrum â¢ Real-time Processing');
    </script>
</body>
</html>
                        