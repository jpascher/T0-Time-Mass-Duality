<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Œæ-Oszilloskop mit Spektrum-Analyzer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
      color: white;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 15px rgba(102,126,234,0.3);
      position: relative;
      overflow: hidden;
    }
    
    .header::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      animation: shimmer 3s infinite;
    }
    
    @keyframes shimmer {
      0% { left: -100%; }
      100% { left: 100%; }
    }
    
    .header h1 {
      font-size: 2.4em;
      margin-bottom: 8px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      position: relative;
      z-index: 1;
    }
    
    .header p {
      position: relative;
      z-index: 1;
      opacity: 0.9;
    }
    
    .main-container {
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 20px;
      padding: 20px;
      max-width: 1900px;
      margin: 0 auto;
      min-height: calc(100vh - 140px);
    }
    
    .display-section {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .oscilloscope-section {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      flex: 1;
    }
    
    .spectrum-section {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      flex: 1;
    }
    
    .controls-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      overflow-y: auto;
      max-height: calc(100vh - 160px);
    }
    
    .control-group {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
    }
    
    .control-group:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
      border-color: rgba(102,126,234,0.3);
    }
    
    .canvas-container {
      position: relative;
      flex: 1;
      background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);
      border-radius: 15px;
      border: 2px solid #667eea;
      margin-bottom: 15px;
      overflow: hidden;
      min-height: 300px;
      box-shadow: 0 0 20px rgba(102,126,234,0.3);
    }
    
    .spectrum-container {
      position: relative;
      flex: 1;
      background: linear-gradient(135deg, #001122 0%, #112233 100%);
      border-radius: 15px;
      border: 2px solid #00ff88;
      overflow: hidden;
      min-height: 300px;
      box-shadow: 0 0 20px rgba(0,255,136,0.3);
    }
    
    .canvas-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding: 5px 0;
    }
    
    .canvas-title {
      color: #00ff41;
      font-size: 1.2em;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(0,255,65,0.5);
    }
    
    .spectrum-title {
      color: #00ff88;
      font-size: 1.2em;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(0,255,136,0.5);
    }
    
    .canvas-controls {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .control-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .control-item label {
      color: #ffd700;
      font-size: 0.85em;
      white-space: nowrap;
      text-shadow: 0 0 5px rgba(255,215,0,0.3);
    }
    
    .slider {
      width: 100px;
      height: 6px;
      border-radius: 3px;
      background: rgba(255,255,255,0.2);
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    
    .slider:hover {
      background: rgba(255,255,255,0.3);
    }
    
    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3), 0 0 10px rgba(102,126,234,0.4);
      transition: all 0.3s ease;
    }
    
    .slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4), 0 0 15px rgba(102,126,234,0.6);
    }
    
    .value-display {
      color: #32cd32;
      font-weight: bold;
      min-width: 70px;
      font-size: 0.85em;
      text-shadow: 0 0 5px rgba(50,205,50,0.3);
    }
    
    .btn {
      padding: 10px 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      font-size: 0.85em;
      transition: all 0.3s ease;
      color: white;
      position: relative;
      overflow: hidden;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }
    
    .btn:hover::before {
      left: 100%;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    .btn-success { background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%); }
    .btn-warning { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .btn-danger { background: linear-gradient(135deg, #ff4757 0%, #ff3742 100%); }
    .btn-info { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .section-title {
      color: #667eea;
      font-size: 1.3em;
      font-weight: bold;
      margin-bottom: 15px;
      text-align: center;
      text-shadow: 0 0 10px rgba(102,126,234,0.5);
    }
    
    .mode-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
    }
    
    .mode-btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 8px;
      background: rgba(255,255,255,0.1);
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
      font-size: 0.85em;
      position: relative;
    }
    
    .mode-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      box-shadow: 0 4px 15px rgba(102,126,234,0.3);
      transform: translateY(-1px);
    }
    
    .mode-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
      background: rgba(255,255,255,0.15);
    }
    
    .mode-btn.active:hover {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    
    .spectrum-mode-btn {
      background: rgba(0,255,136,0.1);
      border: 1px solid rgba(0,255,136,0.3);
    }
    
    .spectrum-mode-btn.active {
      background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
      color: #000;
    }
    
    .generator-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 15px;
    }
    
    .freq-control {
      grid-column: span 2;
      text-align: center;
      padding: 15px;
      background: rgba(102,126,234,0.15);
      border-radius: 10px;
      border: 1px solid rgba(102,126,234,0.3);
      box-shadow: 0 4px 12px rgba(102,126,234,0.1);
    }
    
    .freq-display {
      font-size: 1.8em;
      font-weight: bold;
      color: #667eea;
      margin: 10px 0;
      text-shadow: 0 0 10px rgba(102,126,234,0.5);
    }
    
    .slider-container {
      margin-top: 10px;
    }
    
    .slider-value {
      text-align: center;
      font-size: 0.85em;
      color: #32cd32;
      font-weight: bold;
      margin-top: 6px;
      text-shadow: 0 0 5px rgba(50,205,50,0.3);
    }
    
    .action-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 15px;
    }
    
    .log-container {
      background: rgba(0,0,0,0.7);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      padding: 12px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      overflow-y: auto;
      color: #32cd32;
      height: 160px;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .status-display {
      background: linear-gradient(135deg, #2ed573 0%, #17a2b8 100%);
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      font-weight: bold;
      margin-bottom: 20px;
      font-size: 1em;
      box-shadow: 0 4px 15px rgba(46,213,115,0.3);
      transition: all 0.3s ease;
      position: relative;
    }
    
    .status-display .fps-indicator {
      position: absolute;
      top: 5px;
      right: 10px;
      font-size: 0.7em;
      opacity: 0.8;
      color: #ffffff;
    }
    
    .control-item-full {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
    }
    
    .control-item-full label {
      font-weight: bold;
      color: #ffd700;
      font-size: 0.9em;
      text-shadow: 0 0 5px rgba(255,215,0,0.3);
    }
    
    .control-item-full .slider {
      width: 100%;
    }
    
    .signal-info-panel {
      background: rgba(255,215,0,0.1);
      border: 1px solid rgba(255,215,0,0.3);
      border-radius: 10px;
      padding: 15px;
      margin-top: 15px;
      box-shadow: 0 4px 12px rgba(255,215,0,0.1);
    }
    
    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      font-size: 0.9em;
    }
    
    .info-row:last-child {
      border-bottom: none;
    }
    
    .info-value {
      color: #ffd700;
      font-weight: bold;
      text-shadow: 0 0 5px rgba(255,215,0,0.3);
    }

    .mic-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .mic-level-display {
      background: rgba(0,0,0,0.4);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .mic-level-bar {
      width: 100%;
      height: 10px;
      background: rgba(255,255,255,0.2);
      border-radius: 5px;
      overflow: hidden;
      margin: 8px 0;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .mic-level-indicator {
      height: 100%;
      background: linear-gradient(90deg, #32cd32 0%, #ffa500 70%, #ff4757 100%);
      width: 0%;
      transition: width 0.1s ease;
      border-radius: 5px;
      box-shadow: 0 0 8px rgba(50,205,50,0.5);
    }
    
    .frequency-indicator {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 8px 12px;
      border-radius: 8px;
      border: 2px solid rgba(0,255,65,0.4);
      color: #00ff41;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      text-shadow: 0 0 8px rgba(0,255,65,0.6);
      backdrop-filter: blur(5px);
    }

    .spectrum-info {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      padding: 8px 12px;
      border-radius: 8px;
      border: 2px solid rgba(0,255,136,0.4);
      color: #00ff88;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      text-shadow: 0 0 8px rgba(0,255,136,0.6);
      backdrop-filter: blur(5px);
      font-size: 0.9em;
    }

    .xi-analysis-panel {
      background: rgba(50,205,50,0.1);
      border: 1px solid rgba(50,205,50,0.3);
      border-radius: 10px;
      padding: 12px;
      margin-top: 10px;
      font-size: 0.85em;
    }
    
    .xi-analysis-panel h4 {
      color: #32cd32;
      margin-bottom: 8px;
      text-shadow: 0 0 5px rgba(50,205,50,0.5);
    }

    .profile-selector {
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 15px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .profile-btn {
      width: 100%;
      padding: 8px;
      margin: 2px 0;
      border: none;
      border-radius: 6px;
      background: rgba(255,255,255,0.1);
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.8em;
    }

    .profile-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .performance-panel {
      background: rgba(0,255,255,0.1);
      border: 1px solid rgba(0,255,255,0.3);
      border-radius: 10px;
      padding: 12px;
      margin-top: 10px;
    }

    .performance-panel h4 {
      color: #00ffff;
      margin-bottom: 8px;
      text-shadow: 0 0 5px rgba(0,255,255,0.5);
    }

    .spectrum-controls {
      background: rgba(0,255,136,0.1);
      border: 1px solid rgba(0,255,136,0.3);
      border-radius: 10px;
      padding: 15px;
      margin-top: 15px;
    }

    .spectrum-controls h4 {
      color: #00ff88;
      margin-bottom: 12px;
      text-shadow: 0 0 5px rgba(0,255,136,0.5);
    }
    
    @media (max-width: 1200px) {
      .main-container {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .display-section {
        grid-template-columns: 1fr;
      }
      
      .generator-controls {
        grid-template-columns: 1fr;
      }
      
      .freq-control {
        grid-column: span 1;
      }
      
      .canvas-controls {
        flex-wrap: wrap;
        gap: 10px;
      }
    }
    
    @media (max-width: 768px) {
      .header h1 {
        font-size: 1.8em;
      }
      
      .main-container {
        padding: 10px;
      }
      
      .action-buttons {
        grid-template-columns: 1fr;
      }
      
      .mode-selector {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üî¨ Œæ-Oszilloskop mit Spektrum-Analyzer</h1>
    <p>Œæ-Harmonic Analyzer v2.0 ‚Ä¢ Autokorrelations-basiert ‚Ä¢ Harmonik-Analyse ‚Ä¢ FFT-Spektrum ‚Ä¢ Real-time</p>
  </div>

  <div class="status-display" id="statusDisplay">
    üîÑ Œæ-Oszilloskop mit Spektrum-Analyzer wird initialisiert...
    <div class="fps-indicator" id="fpsIndicator">FPS: --</div>
  </div>

  <div class="main-container">
    <div class="display-section">
      <div class="oscilloscope-section">
        <div class="canvas-header">
          <h3 class="canvas-title">üìä Oszilloskop</h3>
          <div class="canvas-controls">
            <div class="control-item">
              <label>Zeitbereich:</label>
              <input type="range" class="slider" id="timeRangeSlider" 
                  min="10" max="1000" step="10" value="100">
              <span id="timeRangeValue" class="value-display">100 ms</span>
            </div>
            <div class="control-item">
              <label>Amplitude:</label>
              <input type="range" class="slider" id="amplitudeSlider" 
                  min="0.1" max="3.0" step="0.1" value="1.0">
              <span id="amplitudeValue" class="value-display">1.0x</span>
            </div>
          </div>
        </div>
        
        <div class="canvas-container">
          <canvas id="oscilloscopeCanvas"></canvas>
          <div class="frequency-indicator" id="frequencyIndicator">f‚ÇÄ: --- Hz</div>
        </div>
      </div>

      <div class="spectrum-section">
        <div class="canvas-header">
          <h3 class="spectrum-title">üåä Spektrum-Analyzer</h3>
          <div class="canvas-controls">
            <div class="mode-selector">
              <button class="mode-btn spectrum-mode-btn active" id="fftModeBtn" data-spectrum="fft">FFT</button>
              <button class="mode-btn spectrum-mode-btn" id="xiModeBtn" data-spectrum="xi">Œæ-Harmonic</button>
              <button class="mode-btn spectrum-mode-btn" id="waterfallModeBtn" data-spectrum="waterfall">Waterfall</button>
            </div>
            <div class="control-item">
              <label>Freq-Range:</label>
              <input type="range" class="slider" id="freqRangeSlider" 
                  min="100" max="8000" step="100" value="2000">
              <span id="freqRangeValue" class="value-display">2000 Hz</span>
            </div>
            <div class="control-item">
              <label>dB-Range:</label>
              <input type="range" class="slider" id="dbRangeSlider" 
                  min="40" max="120" step="10" value="80">
              <span id="dbRangeValue" class="value-display">80 dB</span>
            </div>
          </div>
        </div>
        
        <div class="spectrum-container">
          <canvas id="spectrumCanvas"></canvas>
          <div class="spectrum-info" id="spectrumInfo">Modus: FFT | 0 Peaks</div>
        </div>
      </div>
      
      <div class="xi-analysis-panel" id="xiAnalysisPanel">
        <h4>üéµ Œæ-Harmonic Analyzer</h4>
        <div class="info-row">
          <span>Erkannte Perioden:</span>
          <span class="info-value" id="detectedPeriods">---</span>
        </div>
        <div class="info-row">
          <span>Dominante Frequenz:</span>
          <span class="info-value" id="dominantFrequency">---</span>
        </div>
        <div class="info-row">
          <span>Œæ-Ratios gefunden:</span>
          <span class="info-value" id="xiRatiosCount">---</span>
        </div>
        <div class="info-row">
          <span>Analyse-Zeit:</span>
          <span class="info-value" id="analysisTime">---</span>
        </div>
        <div class="info-row">
          <span>Strategie:</span>
          <span class="info-value" id="engineStrategy">---</span>
        </div>
      </div>

      <div class="performance-panel" id="performancePanel">
        <h4>‚ö° Analyzer Performance</h4>
        <div class="info-row">
          <span>Profil:</span>
          <span class="info-value" id="currentProfile">---</span>
        </div>
        <div class="info-row">
          <span>Cache Hits:</span>
          <span class="info-value" id="cacheHits">---</span>
        </div>
        <div class="info-row">
          <span>FFT-Gr√∂√üe:</span>
          <span class="info-value" id="fftSize">---</span>
        </div>
        <div class="info-row">
          <span>Spektrum-Modus:</span>
          <span class="info-value" id="spectrumMode">FFT</span>
        </div>
      </div>
      
      <div>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <h3 style="color: #32cd32; font-size: 1.1em; margin: 0;">Œæ-Harmonic Analyzer Log</h3>
          <button class="btn btn-success" id="saveLogBtn" style="padding: 8px 12px; font-size: 0.8em;">üíæ Log speichern</button>
        </div>
        
        <div class="log-container" id="logContainer">
          === Œæ-OSZILLOSKOP mit SPEKTRUM-ANALYZER ===<br>
          System bereit f√ºr Autokorrelations-basierte Harmonik-Analyse...<br>
        </div>
      </div>
    </div>

    <div class="controls-panel">
      <div class="control-group">
        <h3 class="section-title">üéØ Œæ-Harmonic Profile</h3>
        
        <div class="profile-selector">
          <button class="profile-btn active" id="realtimeProfile" data-profile="realtime">‚ö° Real-time</button>
          <button class="profile-btn" id="balancedProfile" data-profile="balanced">‚öñÔ∏è Balanced</button>
          <button class="profile-btn" id="qualityProfile" data-profile="quality">üéØ Quality</button>
          <button class="profile-btn" id="researchProfile" data-profile="research">üî¨ Research</button>
        </div>
      </div>

      <div class="control-group">
        <h3 class="section-title">üåä Spektrum Einstellungen</h3>
        
        <div class="spectrum-controls">
          <h4>FFT Konfiguration</h4>
          <div class="control-item-full">
            <label>üîç FFT-Gr√∂√üe</label>
            <input type="range" class="slider" id="fftSizeSlider" 
                min="10" max="14" step="1" value="12">
            <div class="slider-value" id="fftSizeValue">4096</div>
          </div>
          
          <div class="control-item-full">
            <label>ü™ü Fenster-Funktion</label>
            <select id="windowFunction" style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3);">
              <option value="hanning">Hanning</option>
              <option value="hamming">Hamming</option>
              <option value="blackman">Blackman</option>
              <option value="rectangular">Rechteck</option>
            </select>
          </div>
          
          <div class="control-item-full">
            <label>üìà Averaging</label>
            <input type="range" class="slider" id="averagingSlider" 
                min="1" max="10" step="1" value="3">
            <div class="slider-value" id="averagingValue">3 Frames</div>
          </div>
          
          <div class="control-item-full">
            <label>üé® Darstellung</label>
            <select id="spectrumDisplay" style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3);">
              <option value="magnitude">Magnitude</option>
              <option value="power">Power</option>
              <option value="db">dB Scale</option>
              <option value="log">Log Scale</option>
            </select>
          </div>
        </div>
      </div>

      <div class="control-group">
        <h3 class="section-title">üéõÔ∏è Signal-Generator</h3>
        
        <div class="mode-selector">
          <button class="mode-btn active" id="frequencyModeBtn" data-mode="frequency">Frequenz-Modus</button>
          <button class="mode-btn" id="beatModeBtn" data-mode="beat">Differenzton-Modus</button>
          <button class="mode-btn" id="harmonicModeBtn" data-mode="harmonic">Harmonik-Modus</button>
        </div>
        
        <div class="mode-selector" id="symmetrySelector" style="display: none;">
          <button class="mode-btn active" id="symmetricBtn" data-symmetry="symmetric">Symmetrisch</button>
          <button class="mode-btn" id="asymmetricBtn" data-symmetry="asymmetric">Asymmetrisch</button>
        </div>
        
        <div class="freq-control">
          <label>üéµ Grundfrequenz f‚ÇÄ</label>
          <div class="freq-display" id="baseFreqDisplay">440 Hz</div>
          <div class="slider-container">
            <input type="range" class="slider" id="baseFreqSlider" 
                min="80" max="2000" step="1" value="440" style="width: 100%;">
            <div class="slider-value" id="baseFreqValue">440 Hz</div>
          </div>
          <div class="control-item-full" style="margin-top: 10px;">
            <label>üîä Amplitude f‚ÇÄ</label>
            <input type="range" class="slider" id="baseAmpSlider" 
                min="0" max="100" step="1" value="60">
            <div class="slider-value" id="baseAmpValue">60%</div>
          </div>
        </div>
        
        <div class="generator-controls">
          <div id="frequencyControls">
            <div class="control-item-full">
              <label>üîΩ Untere Frequenz f·µ§</label>
              <input type="range" class="slider" id="lowerFreqSlider" 
                  min="80" max="2000" step="1" value="438">
              <div class="slider-value" id="lowerFreqValue">438 Hz</div>
              <div style="margin-top: 8px;">
                <label style="font-size: 0.8em;">üîä Amplitude f·µ§</label>
                <input type="range" class="slider" id="lowerAmpSlider" 
                    min="0" max="100" step="1" value="30">
                <div class="slider-value" id="lowerAmpValue">30%</div>
              </div>
            </div>
            
            <div class="control-item-full">
              <label>üîº Obere Frequenz f‚Çí</label>
              <input type="range" class="slider" id="upperFreqSlider" 
                  min="80" max="2000" step="1" value="442">
              <div class="slider-value" id="upperFreqValue">442 Hz</div>
              <div style="margin-top: 8px;">
                <label style="font-size: 0.8em;">üîä Amplitude f‚Çí</label>
                <input type="range" class="slider" id="upperAmpSlider" 
                    min="0" max="100" step="1" value="30">
                <div class="slider-value" id="upperAmpValue">30%</div>
              </div>
            </div>
          </div>
          
          <div id="beatControls" style="display: none;">
            <div class="control-item-full">
              <label>üìâ Differenzton f·µ§‚Üíf‚ÇÄ</label>
              <input type="range" class="slider" id="lowerBeatSlider" 
                  min="0.1" max="50" step="0.1" value="2.0">
              <div class="slider-value" id="lowerBeatValue">2.0 Hz</div>
              <div style="margin-top: 8px;">
                <label style="font-size: 0.8em;">üîä Amplitude f·µ§</label>
                <input type="range" class="slider" id="lowerBeatAmpSlider" 
                    min="0" max="100" step="1" value="30">
                <div class="slider-value" id="lowerBeatAmpValue">30%</div>
              </div>
            </div>
            
            <div class="control-item-full">
              <label>üìà Differenzton f‚ÇÄ‚Üíf‚Çí</label>
              <input type="range" class="slider" id="upperBeatSlider" 
                  min="0.1" max="50" step="0.1" value="2.0">
              <div class="slider-value" id="upperBeatValue">2.0 Hz</div>
              <div style="margin-top: 8px;">
                <label style="font-size: 0.8em;">üîä Amplitude f‚Çí</label>
                <input type="range" class="slider" id="upperBeatAmpSlider" 
                    min="0" max="100" step="1" value="30">
                <div class="slider-value" id="upperBeatAmpValue">30%</div>
              </div>
            </div>
          </div>
          
          <div id="harmonicControls" style="display: none;">
            <div class="control-item-full">
              <label>üéº Harmonische Anzahl</label>
              <input type="range" class="slider" id="harmonicCountSlider" 
                  min="2" max="8" step="1" value="4">
              <div class="slider-value" id="harmonicCountValue">4</div>
            </div>
            
            <div class="control-item-full">
              <label>üåä Harmonik-Intensit√§t</label>
              <input type="range" class="slider" id="harmonicIntensitySlider" 
                  min="0.1" max="1.0" step="0.1" value="0.5">
              <div class="slider-value" id="harmonicIntensityValue">0.5</div>
            </div>
          </div>
        </div>
        
        <div class="action-buttons">
          <button class="btn btn-success" id="generateBtn">üéµ Signal erzeugen</button>
          <button class="btn btn-primary" id="exportBtn">üíæ WAV Export</button>
          <button class="btn btn-warning" id="continuousBtn">üîÑ Kontinuierlich</button>
          <button class="btn btn-danger" id="stopContinuousBtn" style="display: none;">‚èπÔ∏è Stoppen</button>
        </div>
        
        <div class="signal-info-panel" id="signalInfo">
          <div class="info-row">
            <span>üéõÔ∏è Signal-Typ:</span>
            <span class="info-value" id="signalType">Bereit</span>
          </div>
          <div class="info-row">
            <span>üéµ Frequenzen:</span>
            <span class="info-value" id="signalFreqs">--- Hz</span>
          </div>
          <div class="info-row">
            <span>üéØ Grundfrequenz:</span>
            <span class="info-value" id="detectedFundamental">--- Hz</span>
          </div>
        </div>
      </div>

      <div class="control-group">
        <h3 class="section-title">üé§ Mikrofon-Eingabe</h3>
        
        <div class="mic-level-display">
          <label>üìä Live-Eingangspegel</label>
          <div class="mic-level-bar">
            <div class="mic-level-indicator" id="micLevelIndicator"></div>
          </div>
          <div id="micLevelText">0%</div>
          <div id="clippingWarning" style="color: #ff4757; font-weight: bold; display: none;">‚ö†Ô∏è CLIPPING ERKANNT!</div>
        </div>
        
        <div class="control-item-full">
          <label>üîä Mikrofon-Empfindlichkeit</label>
          <input type="range" class="slider" id="micSensitivitySlider" 
              min="0.1" max="3.0" step="0.1" value="1.3">
          <div class="slider-value" id="micSensitivityValue">1.3x</div>
        </div>
        
        <div class="control-item-full">
          <label>üìâ Noise Gate</label>
          <input type="range" class="slider" id="noiseGateSlider" 
              min="0.0" max="0.3" step="0.01" value="0.02">
          <div class="slider-value" id="noiseGateValue">0.02</div>
        </div>
        
        <div class="mic-controls">
          <button class="btn btn-success" id="micStartBtn">üé§ Mikrofon aktivieren</button>
          <button class="btn btn-danger" id="micStopBtn" style="display: none;">‚èπÔ∏è Mikrofon stoppen</button>
          
          <div class="action-buttons">
            <button class="btn btn-primary" id="micCaptureBtn" disabled>üìπ 3s Aufnahme</button>
            <button class="btn btn-warning" id="liveAnalysisBtn" disabled>üî¥ Live-Analyse</button>
          </div>
          
          <button class="btn btn-danger" id="stopLiveBtn" style="display: none;">‚èπÔ∏è Live-Analyse stoppen</button>
        </div>
        
        <div class="signal-info-panel" id="micInfo">
          <div class="info-row">
            <span>üìä Status:</span>
            <span class="info-value" id="micStatus">Inaktiv</span>
          </div>
          <div class="info-row">
            <span>üîä Sample-Rate:</span>
            <span class="info-value" id="micSampleRate">--- Hz</span>
          </div>
          <div class="info-row">
            <span>üìà Peak-Level:</span>
            <span class="info-value" id="micPeakLevel">--- dB</span>
          </div>
        </div>
      </div>

      <div class="control-group">
        <h3 class="section-title">üìÅ Datei-Import</h3>
        
        <div class="action-buttons">
          <button class="btn btn-primary" id="loadWavBtn">üìÅ WAV-Datei laden</button>
          <button class="btn btn-info" id="loadDemoBtn">üéµ Demo-Signal laden</button>
        </div>
        
        <div class="signal-info-panel" id="fileInfo">
          <div class="info-row">
            <span>üìÑ Datei:</span>
            <span class="info-value" id="fileName">Keine geladen</span>
          </div>
          <div class="info-row">
            <span>üîß Format:</span>
            <span class="info-value" id="fileFormat">---</span>
          </div>
          <div class="info-row">
            <span>üìè Gr√∂√üe:</span>
            <span class="info-value" id="fileSize">--- KB</span>
          </div>
        </div>
      </div>

      <div class="control-group">
        <h3 class="section-title">‚öôÔ∏è Œæ-FFT Engine Settings</h3>
        
        <div class="control-item-full">
          <label>üîç Œæ-Parameter</label>
          <input type="range" class="slider" id="xiValueSlider" 
              min="0.001" max="0.1" step="0.001" value="0.01">
          <div class="slider-value" id="xiValueDisplay">0.01</div>
        </div>
        
        <div class="control-item-full">
          <label>üéØ Schwellwert</label>
          <input type="range" class="slider" id="thresholdSlider" 
              min="0.001" max="0.1" step="0.001" value="0.005">
          <div class="slider-value" id="thresholdDisplay">0.005</div>
        </div>
        
        <div class="action-buttons">
          <button class="btn btn-primary" id="applySettingsBtn">üîÑ Einstellungen anwenden</button>
          <button class="btn btn-warning" id="resetSettingsBtn">‚Ü∫ Zur√ºcksetzen</button>
        </div>
      </div>
    </div>
  </div>

  <input type="file" id="wavFileInput" accept=".wav,.mp3" style="display: none;">

  <script>
    // ===== IMPROVED Œæ-HARMONIC ANALYZER v2.0 =====
    
    /**
     * Œæ-Harmonic Analyzer f√ºr pr√§zise Periodizit√§ts- und Harmonik-Analyse
     * Verwendet Autokorrelation und Œæ-Mathematik (KEINE FFT!)
     */
    class XiHarmonicAnalyzer {
      constructor(options = {}) {
        this.config = {
          sampleRate: options.sampleRate || 44100,
          xiValue: options.xiValue || 0.01,
          threshold: options.threshold || 0.005,
          profile: options.profile || 'balanced',
          maxPeriods: this.getMaxPeriodsForProfile(options.profile || 'balanced')
        };
        
        this.cache = new Map();
        this.isInitialized = false;
        
        console.log(`üéµ Œæ-Harmonic Analyzer initialisiert (Profil: ${this.config.profile})`);
      }
      
      getMaxPeriodsForProfile(profile) {
        const profiles = {
          'realtime': 15,
          'balanced': 30,
          'quality': 50,
          'research': 100
        };
        return profiles[profile] || 30;
      }
      
      async initialize() {
        // Simuliere kurze Initialisierung
        await new Promise(resolve => setTimeout(resolve, 100));
        this.isInitialized = true;
        return true;
      }
      
      async analyze(signal, options = {}) {
        if (!this.isInitialized) {
          await this.initialize();
        }
        
        const startTime = performance.now();
        
        // Cache-Check
        const cacheKey = this.generateCacheKey(signal);
        if (this.cache.has(cacheKey)) {
          const cached = this.cache.get(cacheKey);
          return { ...cached, fromCache: true, analysisTime: 1.0 };
        }
        
        // Signal-Eigenschaften analysieren
        const characteristics = this.analyzeSignalCharacteristics(signal);
        
        // Strategie bestimmen
        const strategy = this.selectStrategy(characteristics);
        
        // Periodensuche mit Autokorrelation
        const periods = this.findPeriodsWithAutocorrelation(signal);
        
        // Œæ-Harmonik-Analyse
        const xiRatios = this.calculateXiHarmonicRatios(periods);
        
        // Peaks erstellen
        const peaks = periods.map(period => ({
          frequency: this.config.sampleRate / period.period,
          magnitude: period.magnitude,
          xiScore: period.xiScore,
          harmonicQuality: period.harmonicQuality || 0
        }));
        
        const analysisTime = performance.now() - startTime;
        
        const result = {
          peaks: peaks,
          xiRatios: xiRatios,
          strategy: strategy,
          characteristics: characteristics,
          analysisTime: analysisTime,
          fromCache: false,
          analysisMethod: 'autocorrelation_xi'
        };
        
        // Cache-Speicherung (begrenzt)
        if (this.cache.size < 20) {
          this.cache.set(cacheKey, result);
        }
        
        return result;
      }
      
      analyzeSignalCharacteristics(signal) {
        const N = signal.length;
        const mean = signal.reduce((sum, val) => sum + val, 0) / N;
        const rms = Math.sqrt(signal.reduce((sum, val) => sum + val * val, 0) / N);
        
        // Bessere Charakteristika-Analyse
        const variance = signal.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / N;
        const dynamicRange = this.calculateDynamicRange(signal);
        const periodicity = this.estimatePeriodicity(signal);
        
        return {
          length: N,
          mean: mean,
          rms: rms,
          variance: variance,
          dynamicRange: dynamicRange,
          harmonicContent: Math.min(0.9, periodicity * 1.2),
          stationarity: Math.max(0.3, 1.0 - variance),
          noiseLevel: Math.min(0.4, variance * 2),
          periodicity: periodicity
        };
      }
      
      calculateDynamicRange(signal) {
        const sorted = Array.from(signal).map(Math.abs).sort((a, b) => b - a);
        const top10Percent = Math.floor(sorted.length * 0.1);
        const bottom10Percent = Math.floor(sorted.length * 0.9);
        
        const highLevel = sorted[top10Percent] || 0;
        const lowLevel = sorted[bottom10Percent] || 0.001;
        
        return Math.min(10, highLevel / lowLevel);
      }
      
      estimatePeriodicity(signal) {
        // Schnelle Periodizit√§ts-Sch√§tzung
        let maxCorr = 0;
        const testPeriods = [20, 40, 80, 100, 160];
        
        for (const period of testPeriods) {
          if (signal.length > period * 2) {
            const corr = this.quickPeriodicity(signal, period);
            maxCorr = Math.max(maxCorr, corr);
          }
        }
        
        return maxCorr;
      }
      
      quickPeriodicity(signal, period) {
        let correlation = 0;
        let count = 0;
        
        for (let i = 0; i < signal.length - period; i += Math.max(1, Math.floor(period / 4))) {
          correlation += signal[i] * signal[i + period];
          count++;
        }
        
        return count > 0 ? Math.abs(correlation / count) : 0;
      }
      
      selectStrategy(characteristics) {
        if (characteristics.harmonicContent > 0.7) {
          return { 
            algorithm: 'harmonic_focused', 
            optimizations: ['harmonic_prefilter', 'xi_weighting'],
            description: 'Harmonik-fokussierte Analyse'
          };
        } else if (characteristics.noiseLevel > 0.25) {
          return { 
            algorithm: 'noise_robust', 
            optimizations: ['noise_reduction', 'adaptive_threshold'],
            description: 'Rausch-robuste Analyse'
          };
        } else if (characteristics.periodicity > 0.6) {
          return { 
            algorithm: 'periodicity_enhanced', 
            optimizations: ['period_refinement', 'autocorr_boost'],
            description: 'Periodizit√§ts-verst√§rkte Analyse'
          };
        } else {
          return { 
            algorithm: 'adaptive_autocorrelation', 
            optimizations: ['standard_xi'],
            description: 'Adaptive Autokorrelations-Analyse'
          };
        }
      }
      
      findPeriodsWithAutocorrelation(signal) {
        const periods = [];
        const maxPeriod = Math.min(this.config.maxPeriods, signal.length / 3);
        
        for (let period = 4; period <= maxPeriod && periods.length < 20; period++) {
          const periodicity = this.calculateAutocorrelationPeriodicity(signal, period);
          
          if (periodicity > this.config.threshold) {
            const xiScore = this.evaluateXiHarmonicScore(period);
            const harmonicQuality = this.assessHarmonicQuality(signal, period);
            const magnitude = periodicity * xiScore * (1 + harmonicQuality);
            
            periods.push({
              period: period,
              periodicity: periodicity,
              xiScore: xiScore,
              harmonicQuality: harmonicQuality,
              magnitude: magnitude,
              frequency: this.config.sampleRate / period
            });
          }
        }
        
        return periods.sort((a, b) => b.magnitude - a.magnitude);
      }
      
      calculateAutocorrelationPeriodicity(signal, period) {
        if (signal.length < 2 * period) return 0;
        
        let correlation = 0;
        let norm1 = 0;
        let norm2 = 0;
        let count = 0;
        
        const step = Math.max(1, Math.floor(period / 4));
        const maxOffset = signal.length - period;
        
        for (let start = 0; start < maxOffset; start += step) {
          const end = Math.min(start + period, maxOffset);
          
          for (let i = start; i < end; i++) {
            const val1 = signal[i];
            const val2 = signal[i + period];
            
            correlation += val1 * val2;
            norm1 += val1 * val1;
            norm2 += val2 * val2;
            count++;
          }
        }
        
        if (count === 0 || norm1 === 0 || norm2 === 0) return 0;
        
        const normalizedCorr = correlation / Math.sqrt(norm1 * norm2);
        return Math.max(0, normalizedCorr);
      }
      
      assessHarmonicQuality(signal, period) {
        // Bewerte die harmonische Qualit√§t dieser Periode
        const fundamentalFreq = this.config.sampleRate / period;
        let harmonicScore = 0;
        let harmonicCount = 0;
        
        // Teste Harmonische 2-6
        for (let h = 2; h <= 6; h++) {
          const harmonicPeriod = Math.floor(period / h);
          if (harmonicPeriod >= 4) {
            const harmonicStrength = this.calculateAutocorrelationPeriodicity(signal, harmonicPeriod);
            if (harmonicStrength > this.config.threshold * 0.5) {
              harmonicScore += harmonicStrength / h;
              harmonicCount++;
            }
          }
        }
        
        return harmonicCount > 0 ? harmonicScore / harmonicCount : 0;
      }
      
      evaluateXiHarmonicScore(period) {
        // Œæ-Bewertung f√ºr harmonische Analyse
        const omega = 2 * Math.PI / period;
        const targetOmega = 2 * Math.PI / 50; // Referenz-Periode
        const diff = Math.abs(omega - targetOmega);
        return Math.exp(-diff * diff / (2 * this.config.xiValue));
      }
      
      calculateXiHarmonicRatios(periods) {
        const ratios = [];
        
        for (let i = 0; i < Math.min(periods.length, 10); i++) {
          for (let j = i + 1; j < Math.min(periods.length, 10); j++) {
            const freq1 = periods[i].frequency;
            const freq2 = periods[j].frequency;
            
            const freqHigh = Math.max(freq1, freq2);
            const freqLow = Math.min(freq1, freq2);
            const ratio = freqHigh / freqLow;
            
            if (ratio >= 1.01 && ratio <= 8.0) {
              const harmonicInterval = this.classifyHarmonicInterval(ratio);
              const significance = periods[i].magnitude * periods[j].magnitude;
              
              ratios.push({
                freqHigh: freqHigh,
                freqLow: freqLow,
                xiRatio: ratio,
                significance: significance,
                harmonicInterval: harmonicInterval,
                isHarmonic: harmonicInterval !== 'Komplex'
              });
            }
          }
        }
        
        return ratios.sort((a, b) => b.significance - a.significance).slice(0, 10);
      }
      
      classifyHarmonicInterval(ratio) {
        const cents = 1200 * Math.log2(ratio);
        const intervals = [
          {name: 'Unison', cents: 0, tolerance: 20},
          {name: 'Oktave', cents: 1200, tolerance: 30},
          {name: 'Quinte', cents: 702, tolerance: 25},
          {name: 'Quarte', cents: 498, tolerance: 25},
          {name: 'Gro√üe Terz', cents: 386, tolerance: 30},
          {name: 'Kleine Terz', cents: 316, tolerance: 30},
          {name: 'Ganzton', cents: 204, tolerance: 35},
          {name: 'Kleine Septime', cents: 996, tolerance: 40},
          {name: 'Gro√üe Sexte', cents: 884, tolerance: 35}
        ];
        
        for (const interval of intervals) {
          if (Math.abs(cents - interval.cents) <= interval.tolerance) {
            return interval.name;
          }
        }
        
        return 'Komplex';
      }
      
      generateCacheKey(signal) {
        // Vereinfachter Hash aus ersten Samples
        let hash = 0;
        const sampleStep = Math.max(1, Math.floor(signal.length / 50));
        for (let i = 0; i < signal.length; i += sampleStep) {
          hash = ((hash << 5) - hash + Math.floor(signal[i] * 1000)) & 0xffffffff;
        }
        return hash.toString(36);
      }
    }

    // ===== FFT SPECTRUM ANALYZER =====
    
    /**
     * Erweiterte FFT-Implementierung f√ºr Spektrum-Analyse
     */
    class FFTSpectrumAnalyzer {
      constructor(options = {}) {
        this.config = {
          sampleRate: options.sampleRate || 44100,
          fftSize: options.fftSize || 4096,
          windowFunction: options.windowFunction || 'hanning',
          averagingFrames: options.averagingFrames || 3
        };
        
        this.magnitudeHistory = [];
        this.phaseHistory = [];
        this.waterfallData = [];
        this.waterfallMaxLines = 100;
        
        // Precompute window function
        this.windowCoeffs = this.computeWindowFunction(this.config.fftSize, this.config.windowFunction);
        
        console.log(`üåä FFT Spektrum-Analyzer initialisiert (FFT-Gr√∂√üe: ${this.config.fftSize})`);
      }
      
      computeWindowFunction(size, type) {
        const window = new Float32Array(size);
        
        switch(type) {
          case 'hanning':
            for (let i = 0; i < size; i++) {
              window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
            }
            break;
          case 'hamming':
            for (let i = 0; i < size; i++) {
              window[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (size - 1));
            }
            break;
          case 'blackman':
            for (let i = 0; i < size; i++) {
              const a0 = 0.42, a1 = 0.5, a2 = 0.08;
              window[i] = a0 - a1 * Math.cos(2 * Math.PI * i / (size - 1)) + 
                    a2 * Math.cos(4 * Math.PI * i / (size - 1));
            }
            break;
          case 'rectangular':
          default:
            window.fill(1.0);
            break;
        }
        
        return window;
      }
      
      analyze(signal, options = {}) {
        const fftSize = this.config.fftSize;
        const signalLength = Math.min(signal.length, fftSize);
        
        // Prepare padded signal
        const paddedSignal = new Float32Array(fftSize);
        paddedSignal.set(signal.subarray(0, signalLength));
        
        // Apply window function
        for (let i = 0; i < signalLength; i++) {
          paddedSignal[i] *= this.windowCoeffs[i];
        }
        
        // Perform FFT
        const fftResult = this.fft(paddedSignal);
        
        // Calculate magnitude and phase
        const magnitude = new Float32Array(fftSize / 2);
        const phase = new Float32Array(fftSize / 2);
        
        for (let i = 0; i < fftSize / 2; i++) {
          const real = fftResult.real[i];
          const imag = fftResult.imag[i];
          magnitude[i] = Math.sqrt(real * real + imag * imag);
          phase[i] = Math.atan2(imag, real);
        }
        
        // Apply averaging
        if (this.config.averagingFrames > 1) {
          this.magnitudeHistory.push(magnitude);
          if (this.magnitudeHistory.length > this.config.averagingFrames) {
            this.magnitudeHistory.shift();
          }
          
          // Average magnitudes
          const averaged = new Float32Array(fftSize / 2);
          for (let i = 0; i < fftSize / 2; i++) {
            let sum = 0;
            for (const hist of this.magnitudeHistory) {
              sum += hist[i];
            }
            averaged[i] = sum / this.magnitudeHistory.length;
          }
          
          return {
            magnitude: averaged,
            phase: phase,
            frequencies: this.getFrequencyArray(),
            fftSize: fftSize,
            sampleRate: this.config.sampleRate
          };
        }
        
        return {
          magnitude: magnitude,
          phase: phase,
          frequencies: this.getFrequencyArray(),
          fftSize: fftSize,
          sampleRate: this.config.sampleRate
        };
      }
      
      // Cooley-Tukey FFT implementation
      fft(signal) {
        const N = signal.length;
        
        if (N <= 1) {
          return {
            real: new Float32Array(signal),
            imag: new Float32Array(N)
          };
        }
        
        // Bit-reversal permutation
        const real = new Float32Array(N);
        const imag = new Float32Array(N);
        
        for (let i = 0; i < N; i++) {
          const j = this.reverseBits(i, Math.log2(N));
          real[j] = signal[i];
          imag[j] = 0;
        }
        
        // Cooley-Tukey FFT
        for (let len = 2; len <= N; len <<= 1) {
          const halfLen = len >> 1;
          const angleStep = -2 * Math.PI / len;
          
          for (let i = 0; i < N; i += len) {
            for (let j = 0; j < halfLen; j++) {
              const angle = angleStep * j;
              const cos = Math.cos(angle);
              const sin = Math.sin(angle);
              
              const u_real = real[i + j];
              const u_imag = imag[i + j];
              const v_real = real[i + j + halfLen] * cos - imag[i + j + halfLen] * sin;
              const v_imag = real[i + j + halfLen] * sin + imag[i + j + halfLen] * cos;
              
              real[i + j] = u_real + v_real;
              imag[i + j] = u_imag + v_imag;
              real[i + j + halfLen] = u_real - v_real;
              imag[i + j + halfLen] = u_imag - v_imag;
            }
          }
        }
        
        return { real, imag };
      }
      
      reverseBits(num, bits) {
        let result = 0;
        for (let i = 0; i < bits; i++) {
          result = (result << 1) | (num & 1);
          num >>= 1;
        }
        return result;
      }
      
      getFrequencyArray() {
        const freqs = new Float32Array(this.config.fftSize / 2);
        const freqStep = this.config.sampleRate / this.config.fftSize;
        
        for (let i = 0; i < freqs.length; i++) {
          freqs[i] = i * freqStep;
        }
        
        return freqs;
      }
      
      updateWaterfall(magnitude) {
        this.waterfallData.push(new Float32Array(magnitude));
        if (this.waterfallData.length > this.waterfallMaxLines) {
          this.waterfallData.shift();
        }
      }
      
      getWaterfallData() {
        return this.waterfallData;
      }
      
      updateConfig(newConfig) {
        const oldFftSize = this.config.fftSize;
        Object.assign(this.config, newConfig);
        
        // Recalculate window if FFT size or function changed
        if (this.config.fftSize !== oldFftSize || 
          newConfig.windowFunction !== undefined) {
          this.windowCoeffs = this.computeWindowFunction(
            this.config.fftSize, 
            this.config.windowFunction
          );
          
          // Clear history if FFT size changed
          if (this.config.fftSize !== oldFftSize) {
            this.magnitudeHistory = [];
            this.waterfallData = [];
          }
        }
      }
    }

    // ===== GLOBAL VARIABLES =====
    let audioContext = null;
    let currentSignal = null;
    let signalMetadata = null;
    let oscilloscopeCanvas = null;
    let oscilloscopeCtx = null;
    let spectrumCanvas = null;
    let spectrumCtx = null;
    let lastDetectedFundamental = null;
    let xiHarmonicAnalyzer = null;
    let fftSpectrumAnalyzer = null;
    let currentXiResult = null;
    let currentSpectrumResult = null;
    
    // Visualization parameters
    let timeRangeMs = 100;
    let amplificationFactor = 1.0;
    let freqRangeHz = 2000;
    let dbRange = 80;
    let isContinuousMode = false;
    let continuousInterval = null;
    let spectrumMode = 'fft'; // 'fft', 'xi', 'waterfall'
    
    // Microphone variables
    let micStream = null;
    let micAnalyzer = null;
    let micDataArray = null;
    let micTimeDataArray = null;
    let micLevelUpdateInterval = null;
    let isRecordingMic = false;
    let liveAnalysisInterval = null;
    let isLiveAnalysisRunning = false;
    let micSensitivity = 1.3;
    let noiseGateThreshold = 0.02;
    let isClipping = false;
    
    // Performance monitoring
    let frameCount = 0;
    let lastFpsUpdate = Date.now();
    let currentFps = 0;
    let lastDrawTime = 0;
    const DRAW_THROTTLE_MS = 33; // ~30 FPS Maximum
    
    // Animation
    let animationId = null;
    
    // Constants
    const SAMPLE_RATE = 44100;
    const SIGNAL_DURATION = 3.0;
    const LOG_MAX_LINES = 50;
    
    // Demo signals for testing
    const DEMO_SIGNALS = {
      'chord_a_major': {
        name: 'A-Dur Akkord',
        frequencies: [440, 554.37, 659.25], // A4, C#5, E5
        amplitudes: [0.6, 0.4, 0.4]
      },
      'harmonic_series': {
        name: 'Harmonische Reihe',
        fundamental: 220,
        harmonics: [1, 2, 3, 4, 5, 6],
        amplitudes: [1.0, 0.5, 0.33, 0.25, 0.2, 0.17]
      }
    };
    
    // ===== INITIALIZATION =====
    async function initializeSystem() {
      try {
        logMessage('üöÄ Œæ-Oszilloskop mit Spektrum-Analyzer wird initialisiert...');
        
        // Initialize Œæ-Harmonic Analyzer
        try {
          xiHarmonicAnalyzer = new XiHarmonicAnalyzer({
            profile: 'balanced',
            sampleRate: SAMPLE_RATE,
            xiValue: 0.01,
            threshold: 0.005
          });
          
          await xiHarmonicAnalyzer.initialize();
          logMessage('‚úÖ Œæ-Harmonic Analyzer v2.0 erfolgreich initialisiert');
        } catch (xiError) {
          logMessage(`‚ö†Ô∏è Œæ-Harmonic Analyzer Fehler: ${xiError.message}`);
        }
        
        // Initialize FFT Spectrum Analyzer
        try {
          fftSpectrumAnalyzer = new FFTSpectrumAnalyzer({
            sampleRate: SAMPLE_RATE,
            fftSize: 4096,
            windowFunction: 'hanning',
            averagingFrames: 3
          });
          logMessage('‚úÖ FFT Spektrum-Analyzer initialisiert');
        } catch (fftError) {
          logMessage(`‚ö†Ô∏è FFT Spektrum-Analyzer Fehler: ${fftError.message}`);
        }
        
        // Initialize canvases
        oscilloscopeCanvas = document.getElementById('oscilloscopeCanvas');
        oscilloscopeCtx = oscilloscopeCanvas.getContext('2d');
        spectrumCanvas = document.getElementById('spectrumCanvas');
        spectrumCtx = spectrumCanvas.getContext('2d');
        
        // Initialize audio context
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          logMessage('‚úÖ Audio Context initialisiert');
        } catch (audioError) {
          logMessage(`‚ö†Ô∏è Audio Context Fehler: ${audioError.message}`);
        }
        
        // Setup canvas resizing
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);
        
        // Setup all event handlers
        setupEventHandlers();
        
        // Initialize performance monitoring
        startPerformanceMonitoring();
        
        // Initial drawings
        drawOscilloscope(null);
        drawSpectrum(null);
        
        updateStatus('‚úÖ Œæ-Oszilloskop mit Spektrum-Analyzer bereit', 'success');
        logMessage('üéØ System mit Œæ-FFT Engine v2.0 und Spektrum-Analyzer bereit');
        
      } catch (error) {
        logMessage(`‚ùå Initialisierung fehlgeschlagen: ${error.message}`);
        updateStatus('‚ùå Initialisierung fehlgeschlagen', 'error');
      }
    }
    
    function resizeCanvases() {
      try {
        // Oscilloscope canvas
        const oscContainer = oscilloscopeCanvas.parentElement;
        const oscRect = oscContainer.getBoundingClientRect();
        oscilloscopeCanvas.width = oscRect.width - 4;
        oscilloscopeCanvas.height = oscRect.height - 4;
        
        // Spectrum canvas
        const specContainer = spectrumCanvas.parentElement;
        const specRect = specContainer.getBoundingClientRect();
        spectrumCanvas.width = specRect.width - 4;
        spectrumCanvas.height = specRect.height - 4;
        
        if (currentSignal) {
          drawOscilloscope(currentSignal);
          if (currentSpectrumResult) {
            drawSpectrum(currentSpectrumResult);
          }
        }
      } catch (error) {
        logMessage(`‚ö†Ô∏è Canvas Resize Fehler: ${error.message}`);
      }
    }
    
    // ===== PERFORMANCE MONITORING =====
    function startPerformanceMonitoring() {
      setInterval(updatePerformanceMetrics, 1000);
      logMessage('üìä Performance-Monitoring gestartet');
    }
    
    function updatePerformanceMetrics() {
      const now = Date.now();
      
      // Update FPS
      if (now - lastFpsUpdate >= 1000) {
        currentFps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
        frameCount = 0;
        lastFpsUpdate = now;
        
        // Update FPS display
        const fpsEl = document.getElementById('fpsIndicator');
        if (fpsEl) {
          fpsEl.textContent = `FPS: ${currentFps}`;
        }
      }
    }
    
    function updateEngineStatus() {
      if (!xiHarmonicAnalyzer) return;
      
      const config = xiHarmonicAnalyzer.config;
      
      document.getElementById('currentProfile').textContent = config.profile.toUpperCase();
      document.getElementById('cacheHits').textContent = xiHarmonicAnalyzer.cache.size || '0';
      document.getElementById('spectrumMode').textContent = spectrumMode.toUpperCase();
      
      if (fftSpectrumAnalyzer) {
        document.getElementById('fftSize').textContent = fftSpectrumAnalyzer.config.fftSize.toString();
      }
    }
    
    // ===== EVENT HANDLERS =====
    function setupEventHandlers() {
      // Profile selector
      document.querySelectorAll('[data-profile]').forEach(btn => {
        btn.addEventListener('click', function() {
          setXiHarmonicProfile(this.dataset.profile);
        });
      });
      
      // Spectrum mode buttons
      document.querySelectorAll('[data-spectrum]').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('[data-spectrum]').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          spectrumMode = this.dataset.spectrum;
          updateEngineStatus();
          if (currentSignal) {
            performSpectrumAnalysis(currentSignal);
          }
          logMessage(`üåä Spektrum-Modus: ${spectrumMode.toUpperCase()}`);
        });
      });
      
      // Mode buttons
      document.querySelectorAll('[data-mode]').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          switchGeneratorMode();
        });
      });
      
      // Symmetry buttons
      document.querySelectorAll('[data-symmetry]').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('[data-symmetry]').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          updateSymmetryMode();
        });
      });
      
      setupFrequencyControls();
      setupVisualizationControls();
      setupSpectrumControls();
      setupActionButtons();
      setupMicrophoneControls();
      setupFileControls();
      setupXiHarmonicControls();
      
      logMessage('‚úÖ Event-Handler eingerichtet');
    }
    
    function setupSpectrumControls() {
      // Frequency range control
      document.getElementById('freqRangeSlider').addEventListener('input', function() {
        freqRangeHz = parseInt(this.value);
        document.getElementById('freqRangeValue').textContent = `${freqRangeHz} Hz`;
        if (currentSpectrumResult) {
          drawSpectrum(currentSpectrumResult);
        }
      });
      
      // dB range control
      document.getElementById('dbRangeSlider').addEventListener('input', function() {
        dbRange = parseInt(this.value);
        document.getElementById('dbRangeValue').textContent = `${dbRange} dB`;
        if (currentSpectrumResult) {
          drawSpectrum(currentSpectrumResult);
        }
      });
      
      // FFT size control
      document.getElementById('fftSizeSlider').addEventListener('input', function() {
        const power = parseInt(this.value);
        const fftSize = Math.pow(2, power);
        document.getElementById('fftSizeValue').textContent = fftSize.toString();
        
        if (fftSpectrumAnalyzer) {
          fftSpectrumAnalyzer.updateConfig({ fftSize: fftSize });
          updateEngineStatus();
          logMessage(`üîç FFT-Gr√∂√üe ge√§ndert: ${fftSize}`);
          
          if (currentSignal) {
            performSpectrumAnalysis(currentSignal);
          }
        }
      });
      
      // Window function
      document.getElementById('windowFunction').addEventListener('change', function() {
        if (fftSpectrumAnalyzer) {
          fftSpectrumAnalyzer.updateConfig({ windowFunction: this.value });
          logMessage(`ü™ü Fenster-Funktion: ${this.value}`);
          
          if (currentSignal) {
            performSpectrumAnalysis(currentSignal);
          }
        }
      });
      
      // Averaging
      document.getElementById('averagingSlider').addEventListener('input', function() {
        const frames = parseInt(this.value);
        document.getElementById('averagingValue').textContent = `${frames} Frames`;
        
        if (fftSpectrumAnalyzer) {
          fftSpectrumAnalyzer.updateConfig({ averagingFrames: frames });
          logMessage(`üìà Averaging: ${frames} Frames`);
        }
      });
      
      // Spectrum display mode
      document.getElementById('spectrumDisplay').addEventListener('change', function() {
        if (currentSpectrumResult) {
          drawSpectrum(currentSpectrumResult);
        }
      });
    }
    
    function setupFrequencyControls() {
      // Base frequency slider
      document.getElementById('baseFreqSlider').addEventListener('input', function() {
        const freq = parseInt(this.value);
        document.getElementById('baseFreqDisplay').textContent = `${freq} Hz`;
        document.getElementById('baseFreqValue').textContent = `${freq} Hz`;
        updateFrequenciesFromBase();
      });
      
      document.getElementById('baseAmpSlider').addEventListener('input', function() {
        document.getElementById('baseAmpValue').textContent = `${this.value}%`;
      });
      
      // Frequency mode controls
      ['lowerFreq', 'upperFreq', 'lowerAmp', 'upperAmp'].forEach(id => {
        const element = document.getElementById(`${id}Slider`);
        if (element) {
          element.addEventListener('input', function() {
            const suffix = id.includes('Freq') ? ' Hz' : '%';
            document.getElementById(`${id}Value`).textContent = `${this.value}${suffix}`;
          });
        }
      });
      
      // Beat mode controls
      ['lowerBeat', 'upperBeat', 'lowerBeatAmp', 'upperBeatAmp'].forEach(id => {
        const element = document.getElementById(`${id}Slider`);
        if (element) {
          element.addEventListener('input', function() {
            const suffix = id.includes('Amp') ? '%' : ' Hz';
            const value = id.includes('Beat') && !id.includes('Amp') ? 
                   parseFloat(this.value).toFixed(1) : this.value;
            document.getElementById(`${id}Value`).textContent = `${value}${suffix}`;
            
            if (id.includes('Beat') && !id.includes('Amp')) {
              updateFrequenciesFromBeats();
            }
            
            if (getSymmetryMode() === 'symmetric' && id.includes('lowerBeatAmp')) {
              document.getElementById('upperBeatAmpSlider').value = this.value;
              document.getElementById('upperBeatAmpValue').textContent = `${this.value}%`;
            }
          });
        }
      });
      
      // Harmonic mode controls
      document.getElementById('harmonicCountSlider').addEventListener('input', function() {
        document.getElementById('harmonicCountValue').textContent = this.value;
      });
      
      document.getElementById('harmonicIntensitySlider').addEventListener('input', function() {
        document.getElementById('harmonicIntensityValue').textContent = this.value;
      });
    }
    
    function setupVisualizationControls() {
      // Time range control
      document.getElementById('timeRangeSlider').addEventListener('input', function() {
        timeRangeMs = parseInt(this.value);
        document.getElementById('timeRangeValue').textContent = `${timeRangeMs} ms`;
        if (currentSignal) {
          drawOscilloscope(currentSignal);
        }
      });
      
      // Amplitude control
      document.getElementById('amplitudeSlider').addEventListener('input', function() {
        amplificationFactor = parseFloat(this.value);
        document.getElementById('amplitudeValue').textContent = `${amplificationFactor.toFixed(1)}x`;
        if (currentSignal) {
          drawOscilloscope(currentSignal);
        }
      });
    }
    
    function setupXiHarmonicControls() {
      // Œæ-Value control
      document.getElementById('xiValueSlider').addEventListener('input', function() {
        const value = parseFloat(this.value);
        document.getElementById('xiValueDisplay').textContent = value.toFixed(3);
      });
      
      // Threshold control
      document.getElementById('thresholdSlider').addEventListener('input', function() {
        const value = parseFloat(this.value);
        document.getElementById('thresholdDisplay').textContent = value.toFixed(3);
      });
      
      // Apply settings button
      document.getElementById('applySettingsBtn').addEventListener('click', applyXiHarmonicSettings);
      
      // Reset settings button
      document.getElementById('resetSettingsBtn').addEventListener('click', resetXiHarmonicSettings);
    }
    
    function setupActionButtons() {
      // Generator buttons
      document.getElementById('generateBtn').addEventListener('click', generateSignal);
      document.getElementById('exportBtn').addEventListener('click', exportSignalAsWav);
      document.getElementById('continuousBtn').addEventListener('click', startContinuousMode);
      document.getElementById('stopContinuousBtn').addEventListener('click', stopContinuousMode);
      
      // Utility buttons
      document.getElementById('saveLogBtn').addEventListener('click', saveLog);
    }
    
    function setupMicrophoneControls() {
      document.getElementById('micStartBtn').addEventListener('click', startMicrophone);
      document.getElementById('micStopBtn').addEventListener('click', stopMicrophone);
      document.getElementById('micCaptureBtn').addEventListener('click', captureMicrophoneSignal);
      document.getElementById('liveAnalysisBtn').addEventListener('click', startLiveAnalysis);
      document.getElementById('stopLiveBtn').addEventListener('click', stopLiveAnalysis);
      
      document.getElementById('micSensitivitySlider').addEventListener('input', function() {
        micSensitivity = parseFloat(this.value);
        document.getElementById('micSensitivityValue').textContent = `${micSensitivity.toFixed(1)}x`;
        logMessage(`üîä Mikrofon-Empfindlichkeit: ${micSensitivity.toFixed(1)}x`);
      });
      
      document.getElementById('noiseGateSlider').addEventListener('input', function() {
        noiseGateThreshold = parseFloat(this.value);
        document.getElementById('noiseGateValue').textContent = noiseGateThreshold.toFixed(2);
        logMessage(`üìâ Noise Gate: ${noiseGateThreshold.toFixed(2)}`);
      });
    }
    
    function setupFileControls() {
      document.getElementById('loadWavBtn').addEventListener('click', function() {
        document.getElementById('wavFileInput').click();
      });
      
      document.getElementById('loadDemoBtn').addEventListener('click', loadDemoSignal);
      
      document.getElementById('wavFileInput').addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) loadWavFile(file);
        event.target.value = '';
      });
    }
    
    // ===== SPECTRUM ANALYSIS =====
    async function performSpectrumAnalysis(signal) {
      if (!signal || signal.length === 0) return;
      
      try {
        let result = null;
        
        switch(spectrumMode) {
          case 'fft':
            if (fftSpectrumAnalyzer) {
              result = fftSpectrumAnalyzer.analyze(signal);
              result.type = 'fft';
              result.peaks = findSpectrumPeaks(result.magnitude, result.frequencies);
            }
            break;
            
          case 'xi':
            if (xiHarmonicAnalyzer) {
              const xiResult = await xiHarmonicAnalyzer.analyze(signal);
              result = convertXiToSpectrum(xiResult);
              result.type = 'xi';
            }
            break;
            
          case 'waterfall':
            if (fftSpectrumAnalyzer) {
              const fftResult = fftSpectrumAnalyzer.analyze(signal);
              fftSpectrumAnalyzer.updateWaterfall(fftResult.magnitude);
              result = {
                ...fftResult,
                type: 'waterfall',
                waterfallData: fftSpectrumAnalyzer.getWaterfallData(),
                peaks: findSpectrumPeaks(fftResult.magnitude, fftResult.frequencies)
              };
            }
            break;
        }
        
        if (result) {
          currentSpectrumResult = result;
          drawSpectrum(result);
          updateSpectrumInfo(result);
        }
        
      } catch (error) {
        logMessage(`‚ùå Spektrum-Analyse Fehler: ${error.message}`);
      }
    }
    
    function convertXiToSpectrum(xiResult) {
      // Convert Œæ-Harmonic analysis to spectrum-like format
      const maxFreq = Math.min(freqRangeHz, SAMPLE_RATE / 2);
      const binCount = 512;
      const magnitude = new Float32Array(binCount);
      const frequencies = new Float32Array(binCount);
      
      // Create frequency array
      for (let i = 0; i < binCount; i++) {
        frequencies[i] = (i / binCount) * maxFreq;
      }
      
      // Map Œæ-peaks to spectrum bins
      if (xiResult.peaks) {
        for (const peak of xiResult.peaks) {
          const freq = peak.frequency;
          if (freq <= maxFreq) {
            const binIndex = Math.floor((freq / maxFreq) * binCount);
            if (binIndex < binCount) {
              magnitude[binIndex] = Math.max(magnitude[binIndex], peak.magnitude);
              
              // Add some spread for visualization
              for (let spread = 1; spread <= 3; spread++) {
                const spreadMag = peak.magnitude * Math.exp(-spread * spread * 0.1);
                if (binIndex - spread >= 0) {
                  magnitude[binIndex - spread] = Math.max(magnitude[binIndex - spread], spreadMag);
                }
                if (binIndex + spread < binCount) {
                  magnitude[binIndex + spread] = Math.max(magnitude[binIndex + spread], spreadMag);
                }
              }
            }
          }
        }
      }
      
      return {
        magnitude: magnitude,
        frequencies: frequencies,
        peaks: xiResult.peaks || [],
        fftSize: binCount * 2,
        sampleRate: SAMPLE_RATE
      };
    }
    
    function findSpectrumPeaks(magnitude, frequencies, minPeakHeight = 0.01) {
      const peaks = [];
      
      for (let i = 1; i < magnitude.length - 1; i++) {
        if (magnitude[i] > magnitude[i-1] && 
          magnitude[i] > magnitude[i+1] && 
          magnitude[i] > minPeakHeight) {
          
          peaks.push({
            frequency: frequencies[i],
            magnitude: magnitude[i],
            bin: i
          });
        }
      }
      
      // Sort by magnitude and return top peaks
      peaks.sort((a, b) => b.magnitude - a.magnitude);
      return peaks.slice(0, 20);
    }
    
    function updateSpectrumInfo(result) {
      const peakCount = result.peaks ? result.peaks.length : 0;
      const mode = result.type ? result.type.toUpperCase() : 'UNKNOWN';
      
      document.getElementById('spectrumInfo').textContent = `Modus: ${mode} | ${peakCount} Peaks`;
    }
    
    // ===== Œæ-HARMONIC ANALYZER FUNCTIONS =====
    async function setXiHarmonicProfile(profile) {
      if (!xiHarmonicAnalyzer) return;
      
      try {
        // Create new analyzer with new profile
        xiHarmonicAnalyzer = new XiHarmonicAnalyzer({
          profile: profile,
          sampleRate: SAMPLE_RATE,
          xiValue: parseFloat(document.getElementById('xiValueSlider').value),
          threshold: parseFloat(document.getElementById('thresholdSlider').value)
        });
        
        await xiHarmonicAnalyzer.initialize();
        
        // Update UI
        document.querySelectorAll('[data-profile]').forEach(btn => btn.classList.remove('active'));
        document.querySelector(`[data-profile="${profile}"]`).classList.add('active');
        
        updateEngineStatus();
        logMessage(`üéØ Œæ-Harmonic Analyzer Profil gewechselt: ${profile.toUpperCase()}`);
        
        // Re-analyze current signal if available
        if (currentSignal) {
          await performXiHarmonicAnalysis(currentSignal);
        }
        
      } catch (error) {
        logMessage(`‚ùå Profil-Wechsel Fehler: ${error.message}`);
      }
    }
    
    function applyXiHarmonicSettings() {
      const xiValue = parseFloat(document.getElementById('xiValueSlider').value);
      const threshold = parseFloat(document.getElementById('thresholdSlider').value);
      
      if (xiHarmonicAnalyzer) {
        xiHarmonicAnalyzer.config.xiValue = xiValue;
        xiHarmonicAnalyzer.config.threshold = threshold;
        logMessage(`üîß Œæ-Harmonic Analyzer Einstellungen: Œæ=${xiValue.toFixed(3)}, Schwelle=${threshold.toFixed(3)}`);
        
        // Re-analyze current signal
        if (currentSignal) {
          performXiHarmonicAnalysis(currentSignal);
        }
      }
    }
    
    function resetXiHarmonicSettings() {
      document.getElementById('xiValueSlider').value = 0.01;
      document.getElementById('xiValueDisplay').textContent = '0.010';
      document.getElementById('thresholdSlider').value = 0.005;
      document.getElementById('thresholdDisplay').textContent = '0.005';
      
      applyXiHarmonicSettings();
      logMessage('‚Ü∫ Œæ-Harmonic Analyzer Einstellungen zur√ºckgesetzt');
    }
    
    async function performXiHarmonicAnalysis(signal) {
      if (!xiHarmonicAnalyzer || !signal || signal.length === 0) return;
      
      try {
        logMessage('üéµ Starte Œæ-Harmonic Analyzer...');
        
        // IMPROVED: Pre-analyze signal for better frequency detection
        const fundamentalFreq = detectSignalFundamental(signal);
        
        const result = await xiHarmonicAnalyzer.analyze(signal, {
          normalize: true
        });
        
        currentXiResult = result;
        updateXiAnalysisPanel(result);
        
        // IMPROVED: Use both Œæ-Harmonic result and direct detection
        let detectedFreq = fundamentalFreq;
        
        if (result.peaks && result.peaks.length > 0) {
          const xiFreq = result.peaks[0].frequency;
          
          // Cross-validate frequencies
          if (fundamentalFreq > 0 && xiFreq > 0) {
            // Use the frequency that makes more sense
            if (Math.abs(xiFreq - fundamentalFreq) < 20) {
              detectedFreq = (xiFreq + fundamentalFreq) / 2; // Average
            } else {
              // Check which one has better harmonic series
              const fundamentalScore = evaluateHarmonicSeries(signal, fundamentalFreq);
              const xiScore = evaluateHarmonicSeries(signal, xiFreq);
              detectedFreq = fundamentalScore > xiScore ? fundamentalFreq : xiFreq;
            }
          } else if (xiFreq > 0) {
            detectedFreq = xiFreq;
          }
        }
        
        // Update frequency indicator
        if (detectedFreq > 0) {
          lastDetectedFundamental = detectedFreq;
          document.getElementById('frequencyIndicator').textContent = `f‚ÇÄ: ${detectedFreq.toFixed(1)} Hz`;
        } else {
          document.getElementById('frequencyIndicator').textContent = 'f‚ÇÄ: --- Hz';
        }
        
        logMessage(`‚úÖ Œæ-Harmonic Analyse: ${result.peaks.length} Peaks, Fundamental: ${detectedFreq.toFixed(1)}Hz, Methode: ${result.analysisMethod}`);
        
      } catch (error) {
        logMessage(`‚ùå Œæ-Harmonic Analyse Fehler: ${error.message}`);
      }
    }
    
    // IMPROVED: Direct signal fundamental detection for generated/file signals
    function detectSignalFundamental(signal) {
      const sampleRate = SAMPLE_RATE;
      const minFreq = 80;
      const maxFreq = 2000;
      
      // Use autocorrelation for time domain signals
      const minPeriod = Math.floor(sampleRate / maxFreq);
      const maxPeriod = Math.floor(sampleRate / minFreq);
      
      let bestPeriod = 0;
      let maxCorrelation = 0;
      
      // Test different periods
      for (let period = minPeriod; period <= maxPeriod; period++) {
        let correlation = 0;
        let norm1 = 0;
        let norm2 = 0;
        let count = 0;
        
        // Use multiple segments for better accuracy
        const segmentLength = Math.min(period * 2, signal.length - period);
        const numSegments = Math.min(3, Math.floor((signal.length - period) / segmentLength));
        
        for (let seg = 0; seg < numSegments; seg++) {
          const start = seg * Math.floor(segmentLength / 2);
          const end = Math.min(start + segmentLength, signal.length - period);
          
          for (let i = start; i < end; i++) {
            const val1 = signal[i];
            const val2 = signal[i + period];
            
            correlation += val1 * val2;
            norm1 += val1 * val1;
            norm2 += val2 * val2;
            count++;
          }
        }
        
        if (count > 0 && norm1 > 0 && norm2 > 0) {
          const normalizedCorr = correlation / Math.sqrt(norm1 * norm2);
          
          if (normalizedCorr > maxCorrelation) {
            maxCorrelation = normalizedCorr;
            bestPeriod = period;
          }
        }
      }
      
      // Return frequency if correlation is strong enough
      if (maxCorrelation > 0.4 && bestPeriod > 0) {
        return sampleRate / bestPeriod;
      }
      
      return 0;
    }
    
    // Helper function to evaluate harmonic series strength
    function evaluateHarmonicSeries(signal, fundamentalFreq) {
      if (fundamentalFreq <= 0) return 0;
      
      const sampleRate = SAMPLE_RATE;
      let score = 0;
      
      // Test harmonics 1-6
      for (let h = 1; h <= 6; h++) {
        const harmonicFreq = fundamentalFreq * h;
        const period = sampleRate / harmonicFreq;
        
        if (period < 4 || period > signal.length / 3) continue;
        
        // Simple periodicity test
        let correlation = 0;
        let count = 0;
        
        for (let i = 0; i < signal.length - period; i += Math.max(1, Math.floor(period / 4))) {
          if (i + period < signal.length) {
            correlation += signal[i] * signal[i + Math.floor(period)];
            count++;
          }
        }
        
        if (count > 0) {
          const harmonicStrength = Math.abs(correlation / count);
          score += harmonicStrength / h; // Weight lower harmonics more
        }
      }
      
      return score;
    }
    
    function updateXiAnalysisPanel(result) {
      try {
        if (!result) {
          document.getElementById('detectedPeriods').textContent = '---';
          document.getElementById('dominantFrequency').textContent = '---';
          document.getElementById('xiRatiosCount').textContent = '---';
          document.getElementById('analysisTime').textContent = '---';
          document.getElementById('engineStrategy').textContent = '---';
          return;
        }
        
        document.getElementById('detectedPeriods').textContent = result.peaks ? result.peaks.length : 0;
        
        if (result.peaks && result.peaks.length > 0) {
          document.getElementById('dominantFrequency').textContent = `${result.peaks[0].frequency.toFixed(1)} Hz`;
        } else {
          document.getElementById('dominantFrequency').textContent = '--- Hz';
        }
        
        document.getElementById('xiRatiosCount').textContent = result.xiRatios ? result.xiRatios.length : 0;
        
        if (result.analysisTime) {
          document.getElementById('analysisTime').textContent = `${result.analysisTime.toFixed(1)} ms`;
        }
        
        if (result.strategy) {
          document.getElementById('engineStrategy').textContent = result.strategy.algorithm || 'Standard';
        }
        
        // Update signal info
        updateSignalInfo();
        
      } catch (error) {
        logMessage(`‚ö†Ô∏è Œæ-Analyse Panel Update Fehler: ${error.message}`);
      }
    }
    
    // ===== GENERATOR FUNCTIONS =====
    function getGeneratorMode() {
      const activeBtn = document.querySelector('[data-mode].active');
      return activeBtn ? activeBtn.dataset.mode : 'frequency';
    }
    
    function getSymmetryMode() {
      const activeBtn = document.querySelector('[data-symmetry].active');
      return activeBtn ? activeBtn.dataset.symmetry : 'symmetric';
    }
    
    function switchGeneratorMode() {
      const mode = getGeneratorMode();
      const frequencyControls = document.getElementById('frequencyControls');
      const beatControls = document.getElementById('beatControls');
      const harmonicControls = document.getElementById('harmonicControls');
      const symmetrySelector = document.getElementById('symmetrySelector');
      
      // Hide all controls first
      frequencyControls.style.display = 'none';
      beatControls.style.display = 'none';
      harmonicControls.style.display = 'none';
      symmetrySelector.style.display = 'none';
      
      switch(mode) {
        case 'frequency':
          frequencyControls.style.display = 'block';
          logMessage('üéõÔ∏è Wechsel zu Frequenz-Modus');
          break;
        case 'beat':
          beatControls.style.display = 'block';
          symmetrySelector.style.display = 'flex';
          initializeBeatMode();
          logMessage('üéõÔ∏è Wechsel zu Differenzton-Modus');
          break;
        case 'harmonic':
          harmonicControls.style.display = 'block';
          logMessage('üéõÔ∏è Wechsel zu Harmonik-Modus');
          break;
      }
    }
    
    function initializeBeatMode() {
      const baseFreq = parseInt(document.getElementById('baseFreqSlider').value);
      const lowerFreq = parseInt(document.getElementById('lowerFreqSlider').value);
      const upperFreq = parseInt(document.getElementById('upperFreqSlider').value);
      
      const lowerBeat = Math.abs(baseFreq - lowerFreq);
      const upperBeat = Math.abs(upperFreq - baseFreq);
      
      document.getElementById('lowerBeatSlider').value = lowerBeat.toFixed(1);
      document.getElementById('lowerBeatValue').textContent = `${lowerBeat.toFixed(1)} Hz`;
      
      document.getElementById('upperBeatSlider').value = upperBeat.toFixed(1);
      document.getElementById('upperBeatValue').textContent = `${upperBeat.toFixed(1)} Hz`;
      
      logMessage(`üîÑ Differenzton-Werte: ${lowerBeat.toFixed(1)}Hz, ${upperBeat.toFixed(1)}Hz`);
    }
    
    function updateSymmetryMode() {
      const symmetry = getSymmetryMode();
      
      if (symmetry === 'symmetric') {
        const lowerBeat = parseFloat(document.getElementById('lowerBeatSlider').value);
        document.getElementById('upperBeatSlider').value = lowerBeat.toFixed(1);
        document.getElementById('upperBeatValue').textContent = `${lowerBeat.toFixed(1)} Hz`;
        
        const lowerAmp = document.getElementById('lowerBeatAmpSlider').value;
        document.getElementById('upperBeatAmpSlider').value = lowerAmp;
        document.getElementById('upperBeatAmpValue').textContent = `${lowerAmp}%`;
        
        updateFrequenciesFromBeats();
        logMessage('üîÑ Symmetrischer Modus aktiviert');
      } else {
        logMessage('üîÑ Asymmetrischer Modus aktiviert');
      }
    }
    
    function updateFrequenciesFromBase() {
      const mode = getGeneratorMode();
      if (mode === 'beat') {
        updateFrequenciesFromBeats();
      }
    }
    
    function updateFrequenciesFromBeats() {
      const mode = getGeneratorMode();
      if (mode !== 'beat') return;
      
      const baseFreq = parseInt(document.getElementById('baseFreqSlider').value);
      const lowerBeat = parseFloat(document.getElementById('lowerBeatSlider').value);
      const upperBeat = parseFloat(document.getElementById('upperBeatSlider').value);
      
      const lowerFreq = baseFreq - lowerBeat;
      const upperFreq = baseFreq + upperBeat;
      
      document.getElementById('lowerFreqSlider').value = lowerFreq;
      document.getElementById('upperFreqSlider').value = upperFreq;
      
      logMessage(`üîÑ Frequenzen: f·µ§=${lowerFreq.toFixed(1)}Hz, f‚ÇÄ=${baseFreq}Hz, f‚Çí=${upperFreq.toFixed(1)}Hz`);
    }
    
    // ===== SIGNAL GENERATION =====
    async function generateSignal() {
      try {
        logMessage('üéµ Starte Signal-Generierung...');
        
        const mode = getGeneratorMode();
        let signal;
        
        switch(mode) {
          case 'frequency':
            signal = generateFrequencyModeSignal();
            break;
          case 'beat':
            signal = generateBeatModeSignal();
            break;
          case 'harmonic':
            signal = generateHarmonicModeSignal();
            break;
          default:
            throw new Error(`Unbekannter Modus: ${mode}`);
        }
        
        if (!signal) {
          throw new Error('Signal-Generierung fehlgeschlagen');
        }
        
        // Normalization
        const normalizedSignal = normalizeSignal(signal);
        
        currentSignal = normalizedSignal;
        signalMetadata = {
          type: 'generated',
          mode: mode,
          duration: SIGNAL_DURATION,
          sampleRate: SAMPLE_RATE,
          generatedAt: new Date().toISOString()
        };
        
        updateSignalInfo();
        drawOscilloscope(normalizedSignal);
        
        // Perform analyses
        await performXiHarmonicAnalysis(normalizedSignal);
        await performSpectrumAnalysis(normalizedSignal);
        
        updateStatus(`‚úÖ ${mode}-Signal erfolgreich generiert`, 'success');
        logMessage('‚úÖ Signal-Generierung abgeschlossen');
        
      } catch (error) {
        logMessage(`‚ùå Signal-Generierung fehlgeschlagen: ${error.message}`);
        updateStatus('‚ùå Signal-Generierung fehlgeschlagen', 'error');
      }
    }
    
    function generateFrequencyModeSignal() {
      const baseFreq = parseInt(document.getElementById('baseFreqSlider').value);
      const lowerFreq = parseInt(document.getElementById('lowerFreqSlider').value);
      const upperFreq = parseInt(document.getElementById('upperFreqSlider').value);
      
      const baseAmp = parseInt(document.getElementById('baseAmpSlider').value) / 100;
      const lowerAmp = parseInt(document.getElementById('lowerAmpSlider').value) / 100;
      const upperAmp = parseInt(document.getElementById('upperAmpSlider').value) / 100;
      
      logMessage(`üìä Frequenz-Modus: ${baseFreq}Hz + ${lowerFreq}Hz + ${upperFreq}Hz`);
      
      return generateMultiFrequencySignal([
        {freq: baseFreq, amp: baseAmp},
        {freq: lowerFreq, amp: lowerAmp},
        {freq: upperFreq, amp: upperAmp}
      ]);
    }
    
    function generateBeatModeSignal() {
      const baseFreq = parseInt(document.getElementById('baseFreqSlider').value);
      const lowerBeat = parseFloat(document.getElementById('lowerBeatSlider').value);
      const upperBeat = parseFloat(document.getElementById('upperBeatSlider').value);
      
      const baseAmp = parseInt(document.getElementById('baseAmpSlider').value) / 100;
      const lowerAmp = parseInt(document.getElementById('lowerBeatAmpSlider').value) / 100;
      const upperAmp = parseInt(document.getElementById('upperBeatAmpSlider').value) / 100;
      
      const lowerFreq = baseFreq - lowerBeat;
      const upperFreq = baseFreq + upperBeat;
      
      logMessage(`üìä Differenzton-Modus: ${baseFreq}Hz ¬±${lowerBeat.toFixed(1)}Hz/¬±${upperBeat.toFixed(1)}Hz`);
      
      return generateMultiFrequencySignal([
        {freq: baseFreq, amp: baseAmp},
        {freq: lowerFreq, amp: lowerAmp},
        {freq: upperFreq, amp: upperAmp}
      ]);
    }
    
    function generateHarmonicModeSignal() {
      const baseFreq = parseInt(document.getElementById('baseFreqSlider').value);
      const harmonicCount = parseInt(document.getElementById('harmonicCountSlider').value);
      const intensity = parseFloat(document.getElementById('harmonicIntensitySlider').value);
      const baseAmp = parseInt(document.getElementById('baseAmpSlider').value) / 100;
      
      const frequencies = [];
      for (let i = 1; i <= harmonicCount; i++) {
        frequencies.push({
          freq: baseFreq * i,
          amp: baseAmp * Math.pow(intensity, i - 1)
        });
      }
      
      logMessage(`üìä Harmonik-Modus: ${harmonicCount} Harmonische von ${baseFreq}Hz`);
      
      return generateMultiFrequencySignal(frequencies);
    }
    
    function generateMultiFrequencySignal(frequencies) {
      const samples = Math.floor(SIGNAL_DURATION * SAMPLE_RATE);
      const signal = new Float32Array(samples);
      
      for (let i = 0; i < samples; i++) {
        const t = i / SAMPLE_RATE;
        let sample = 0;
        
        frequencies.forEach(({freq, amp}) => {
          if (freq > 0 && amp > 0) {
            sample += amp * Math.sin(2 * Math.PI * freq * t);
          }
        });
        
        signal[i] = sample;
      }
      
      return signal;
    }
    
    function normalizeSignal(signal) {
      logMessage('üîß Signal-Normalisierung...');
      
      // Calculate signal statistics
      let maxAmp = 0;
      let rms = 0;
      for (let i = 0; i < signal.length; i++) {
        const abs = Math.abs(signal[i]);
        maxAmp = Math.max(maxAmp, abs);
        rms += signal[i] * signal[i];
      }
      rms = Math.sqrt(rms / signal.length);
      
      // IMPROVED: Better normalization strategy
      const normalizedSignal = new Float32Array(signal.length);
      
      // Determine normalization approach based on signal characteristics
      let targetLevel = 0.7; // More conservative default
      let normalizationFactor = 1.0;
      
      if (maxAmp > 0) {
        // Use RMS-based normalization for more natural levels
        const targetRms = 0.2; // Target RMS level
        if (rms > 0) {
          normalizationFactor = Math.min(targetRms / rms, targetLevel / maxAmp);
        } else {
          normalizationFactor = targetLevel / maxAmp;
        }
        
        // Limit maximum amplification to prevent noise boost
        normalizationFactor = Math.min(normalizationFactor, 2.0);
      }
      
      for (let i = 0; i < signal.length; i++) {
        let sample = signal[i] * normalizationFactor;
        
        // IMPROVED: Gentler soft limiting
        if (Math.abs(sample) > 0.8) {
          sample = Math.sign(sample) * (0.8 + 0.2 * Math.tanh((Math.abs(sample) - 0.8) * 5));
        }
        
        normalizedSignal[i] = sample;
      }
      
      // Calculate final levels for logging
      let finalRms = 0;
      let finalMax = 0;
      for (let i = 0; i < normalizedSignal.length; i++) {
        const abs = Math.abs(normalizedSignal[i]);
        finalMax = Math.max(finalMax, abs);
        finalRms += normalizedSignal[i] * normalizedSignal[i];
      }
      finalRms = Math.sqrt(finalRms / normalizedSignal.length);
      
      logMessage(`üìä Normalisierung: ${normalizationFactor.toFixed(3)}x, RMS: ${(rms*100).toFixed(1)}%‚Üí${(finalRms*100).toFixed(1)}%, Peak: ${(maxAmp*100).toFixed(1)}%‚Üí${(finalMax*100).toFixed(1)}%`);
      return normalizedSignal;
    }
    
    // ===== MICROPHONE FUNCTIONS =====
    async function startMicrophone() {
      try {
        updateStatus('üé§ Mikrofon wird gestartet...', 'running');
        logMessage('üé§ Starte Mikrofon...');
        
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }
        
        const constraints = { 
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false,
            sampleRate: SAMPLE_RATE,
            latency: 0.01
          }
        };
        
        micStream = await navigator.mediaDevices.getUserMedia(constraints);
        
        const source = audioContext.createMediaStreamSource(micStream);
        micAnalyzer = audioContext.createAnalyser();
        micAnalyzer.fftSize = 8192;
        micAnalyzer.smoothingTimeConstant = 0.1;
        source.connect(micAnalyzer);
        
        micDataArray = new Uint8Array(micAnalyzer.frequencyBinCount);
        micTimeDataArray = new Float32Array(micAnalyzer.fftSize);
        isRecordingMic = true;
        
        // UI updates
        document.getElementById('micStartBtn').style.display = 'none';
        document.getElementById('micStopBtn').style.display = 'block';
        document.getElementById('micCaptureBtn').disabled = false;
        document.getElementById('liveAnalysisBtn').disabled = false;
        
        updateMicInfo('Aktiv', audioContext.sampleRate, 0);
        startMicLevelMonitoring();
        
        updateStatus('‚úÖ Mikrofon aktiv', 'success');
        logMessage('‚úÖ Mikrofon erfolgreich gestartet');
        
      } catch (error) {
        logMessage(`‚ùå Mikrofon-Fehler: ${error.message}`);
        updateStatus(`‚ùå Mikrofon-Fehler: ${error.message}`, 'error');
      }
    }
    
    function stopMicrophone() {
      isRecordingMic = false;
      
      stopLiveAnalysis();
      
      if (micLevelUpdateInterval) {
        clearInterval(micLevelUpdateInterval);
        micLevelUpdateInterval = null;
      }
      
      if (micStream) {
        micStream.getTracks().forEach(track => track.stop());
        micStream = null;
      }
      
      isClipping = false;
      
      // UI updates
      document.getElementById('micStartBtn').style.display = 'block';
      document.getElementById('micStopBtn').style.display = 'none';
      document.getElementById('micCaptureBtn').disabled = true;
      document.getElementById('liveAnalysisBtn').disabled = true;
      
      updateMicLevel(0);
      updateMicInfo('Inaktiv', '---', '---');
      document.getElementById('frequencyIndicator').textContent = 'f‚ÇÄ: --- Hz';
      
      const clippingWarning = document.getElementById('clippingWarning');
      if (clippingWarning) clippingWarning.style.display = 'none';
      
      updateStatus('‚èπÔ∏è Mikrofon gestoppt', 'info');
      logMessage('‚èπÔ∏è Mikrofon gestoppt');
    }
    
    function startMicLevelMonitoring() {
      micLevelUpdateInterval = setInterval(() => {
        if (!isRecordingMic || !micAnalyzer || !micDataArray) return;
        
        micAnalyzer.getByteFrequencyData(micDataArray);
        micAnalyzer.getFloatTimeDomainData(micTimeDataArray);
        
        // Level calculation
        let sum = 0;
        let maxSample = 0;
        let clippedSamples = 0;
        let timeRms = 0;
        
        // Check for clipping and calculate time domain RMS
        for (let i = 0; i < micTimeDataArray.length; i++) {
          const sample = Math.abs(micTimeDataArray[i]);
          maxSample = Math.max(maxSample, sample);
          timeRms += sample * sample;
          if (sample > 0.95) clippedSamples++;
        }
        timeRms = Math.sqrt(timeRms / micTimeDataArray.length);
        
        // Calculate frequency domain RMS
        for (let i = 0; i < micDataArray.length; i++) {
          sum += micDataArray[i] * micDataArray[i];
        }
        
        const rmsFreq = Math.sqrt(sum / micDataArray.length);
        const levelPercent = Math.round((rmsFreq / 255) * 100);
        const levelDb = rmsFreq > 0 ? (20 * Math.log10(rmsFreq / 255)).toFixed(1) : -60;
        
        updateMicLevel(levelPercent);
        updateMicInfo('Aktiv', audioContext.sampleRate, levelDb);
        
        // Clipping detection
        const clippingRatio = clippedSamples / micTimeDataArray.length;
        isClipping = clippingRatio > 0.01;
        
        const clippingWarning = document.getElementById('clippingWarning');
        if (clippingWarning) {
          clippingWarning.style.display = isClipping ? 'block' : 'none';
        }
        
        // IMPROVED: Better frequency detection with multiple methods
        if (timeRms > noiseGateThreshold && !isClipping) {
          const detectedFreq = detectFundamentalFrequency(micDataArray, micTimeDataArray);
          
          if (detectedFreq > 0) {
            lastDetectedFundamental = detectedFreq;
            document.getElementById('frequencyIndicator').textContent = `f‚ÇÄ: ${detectedFreq.toFixed(1)} Hz`;
          } else {
            document.getElementById('frequencyIndicator').textContent = 'f‚ÇÄ: [Suche...]';
          }
        } else if (timeRms <= noiseGateThreshold) {
          document.getElementById('frequencyIndicator').textContent = 'f‚ÇÄ: [Noise Gate]';
        } else {
          document.getElementById('frequencyIndicator').textContent = 'f‚ÇÄ: [Clipping]';
        }
        
      }, 50); // 20 FPS
    }
    
    // IMPROVED: Better fundamental frequency detection
    function detectFundamentalFrequency(freqData, timeData) {
      // Method 1: Peak detection in frequency domain with harmonic analysis
      let peakFreq = 0;
      let maxMagnitude = 0;
      const minFreq = 80; // Hz
      const maxFreq = 2000; // Hz
      
      const freqResolution = audioContext.sampleRate / (2 * freqData.length);
      const minBin = Math.floor(minFreq / freqResolution);
      const maxBin = Math.floor(maxFreq / freqResolution);
      
      // Find frequency domain peaks
      const peaks = [];
      for (let i = minBin; i < maxBin - 2; i++) {
        if (freqData[i] > freqData[i-1] && freqData[i] > freqData[i+1] && freqData[i] > 30) {
          const freq = i * freqResolution;
          const magnitude = freqData[i];
          peaks.push({ freq, magnitude });
        }
      }
      
      // Sort peaks by magnitude
      peaks.sort((a, b) => b.magnitude - a.magnitude);
      
      // Method 2: Autocorrelation for fundamental detection
      const autocorrFreq = autocorrelationFundamental(timeData);
      
      // Method 3: Find best fundamental candidate
      let bestFundamental = 0;
      let bestScore = 0;
      
      // Test top frequency peaks
      for (let i = 0; i < Math.min(5, peaks.length); i++) {
        const testFreq = peaks[i].freq;
        const score = evaluateFundamentalCandidate(testFreq, peaks, autocorrFreq);
        
        if (score > bestScore) {
          bestScore = score;
          bestFundamental = testFreq;
        }
      }
      
      // Also test autocorrelation result
      if (autocorrFreq > 0) {
        const autocorrScore = evaluateFundamentalCandidate(autocorrFreq, peaks, autocorrFreq);
        if (autocorrScore > bestScore) {
          bestScore = autocorrScore;
          bestFundamental = autocorrFreq;
        }
      }
      
      return bestScore > 0.3 ? bestFundamental : 0;
    }
    
    function autocorrelationFundamental(timeData) {
      const sampleRate = audioContext.sampleRate;
      const minPeriod = Math.floor(sampleRate / 2000); // 2000 Hz max
      const maxPeriod = Math.floor(sampleRate / 80);  // 80 Hz min
      
      let bestPeriod = 0;
      let maxCorrelation = 0;
      
      for (let period = minPeriod; period <= maxPeriod; period++) {
        let correlation = 0;
        let norm1 = 0;
        let norm2 = 0;
        
        const testLength = Math.min(period * 3, timeData.length - period);
        
        for (let i = 0; i < testLength; i++) {
          const val1 = timeData[i];
          const val2 = timeData[i + period];
          
          correlation += val1 * val2;
          norm1 += val1 * val1;
          norm2 += val2 * val2;
        }
        
        const normalizedCorr = correlation / Math.sqrt(norm1 * norm2 + 1e-10);
        
        if (normalizedCorr > maxCorrelation) {
          maxCorrelation = normalizedCorr;
          bestPeriod = period;
        }
      }
      
      return maxCorrelation > 0.3 ? sampleRate / bestPeriod : 0;
    }
    
    function evaluateFundamentalCandidate(testFreq, peaks, autocorrFreq) {
      let score = 0;
      
      // Score based on peak magnitude
      const peak = peaks.find(p => Math.abs(p.freq - testFreq) < 10);
      if (peak) {
        score += peak.magnitude / 255 * 0.5;
      }
      
      // Score based on harmonic series presence
      let harmonicScore = 0;
      for (let h = 2; h <= 6; h++) {
        const harmonicFreq = testFreq * h;
        const harmonic = peaks.find(p => Math.abs(p.freq - harmonicFreq) < 20);
        if (harmonic) {
          harmonicScore += harmonic.magnitude / 255 / h;
        }
      }
      score += harmonicScore * 0.3;
      
      // Score based on autocorrelation agreement
      if (autocorrFreq > 0 && Math.abs(testFreq - autocorrFreq) < 20) {
        score += 0.2;
      }
      
      return score;
    }
    
    async function captureMicrophoneSignal() {
      if (!isRecordingMic || !micStream) {
        updateStatus('‚ö†Ô∏è Bitte zuerst Mikrofon aktivieren', 'warning');
        return;
      }
      
      try {
        updateStatus('üìπ 3s Aufnahme l√§uft...', 'running');
        logMessage('üìπ Starte 3-Sekunden-Aufnahme...');
        
        const mediaRecorder = new MediaRecorder(micStream, {
          mimeType: 'audio/webm;codecs=opus'
        });
        const audioChunks = [];
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };
        
        mediaRecorder.onstop = async () => {
          try {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            const arrayBuffer = await audioBlob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            let processedSignal = new Float32Array(audioBuffer.getChannelData(0));
            
            // Apply sensitivity scaling
            for (let i = 0; i < processedSignal.length; i++) {
              processedSignal[i] *= micSensitivity;
            }
            
            if (processedSignal.length > SAMPLE_RATE * 3) {
              processedSignal = processedSignal.slice(0, SAMPLE_RATE * 3);
            }
            
            currentSignal = processedSignal;
            signalMetadata = {
              type: 'microphone',
              duration: audioBuffer.duration,
              sampleRate: audioBuffer.sampleRate,
              channels: audioBuffer.numberOfChannels,
              capturedAt: new Date().toISOString()
            };
            
            updateSignalInfo();
            drawOscilloscope(currentSignal);
            
            // Perform analyses
            await performXiHarmonicAnalysis(currentSignal);
            await performSpectrumAnalysis(currentSignal);
            
            updateStatus('‚úÖ Mikrofon-Aufnahme abgeschlossen', 'success');
            logMessage(`‚úÖ Aufnahme: ${audioBuffer.duration.toFixed(1)}s erfolgreich`);
            
          } catch (error) {
            logMessage(`‚ùå Aufnahme-Verarbeitung: ${error.message}`);
            updateStatus('‚ùå Verarbeitung fehlgeschlagen', 'error');
          }
        };
        
        mediaRecorder.start();
        setTimeout(() => mediaRecorder.stop(), 3000);
        
      } catch (error) {
        logMessage(`‚ùå Aufnahme-Fehler: ${error.message}`);
        updateStatus('‚ùå Aufnahme fehlgeschlagen', 'error');
      }
    }
    
    // ===== LIVE ANALYSIS =====
    function startLiveAnalysis() {
      if (!isRecordingMic || !micAnalyzer) {
        updateStatus('‚ö†Ô∏è Bitte zuerst Mikrofon aktivieren', 'warning');
        return;
      }
      
      if (isLiveAnalysisRunning) return;
      
      isLiveAnalysisRunning = true;
      document.getElementById('liveAnalysisBtn').style.display = 'none';
      document.getElementById('stopLiveBtn').style.display = 'block';
      
      updateStatus('üî¥ Live-Analyse aktiv', 'running');
      logMessage('üî¥ Live-Analyse gestartet');
      
      startLiveVisualization();
    }
    
    function stopLiveAnalysis() {
      if (!isLiveAnalysisRunning) return;
      
      isLiveAnalysisRunning = false;
      
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      document.getElementById('liveAnalysisBtn').style.display = 'block';
      document.getElementById('stopLiveBtn').style.display = 'none';
      
      currentSignal = null;
      signalMetadata = null;
      currentXiResult = null;
      currentSpectrumResult = null;
      updateSignalInfo();
      updateXiAnalysisPanel(null);
      drawOscilloscope(null);
      drawSpectrum(null);
      
      updateStatus('‚èπÔ∏è Live-Analyse gestoppt', 'info');
      logMessage('‚èπÔ∏è Live-Analyse gestoppt');
    }
    
    function startLiveVisualization() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      if (isLiveAnalysisRunning) {
        animateLiveVisualization();
      }
    }
    
    async function animateLiveVisualization() {
      if (!isLiveAnalysisRunning || !micAnalyzer || !micTimeDataArray) {
        return;
      }
      
      try {
        micAnalyzer.getFloatTimeDomainData(micTimeDataArray);
        
        // Process signal
        const processedSignal = liveProcessing(micTimeDataArray);
        
        drawOscilloscope(processedSignal);
        
        // Perform analyses every few frames
        if (frameCount % 10 === 0) { // Every 10 frames
          await performXiHarmonicAnalysis(processedSignal);
        }
        
        if (frameCount % 5 === 0) { // Every 5 frames for spectrum
          await performSpectrumAnalysis(processedSignal);
        }
        
        animationId = requestAnimationFrame(animateLiveVisualization);
      } catch (error) {
        logMessage(`‚ö†Ô∏è Live-Visualisierung Fehler: ${error.message}`);
        stopLiveAnalysis();
      }
    }
    
    function liveProcessing(rawSignal) {
      const filtered = new Float32Array(rawSignal.length);
      
      // Apply sensitivity scaling
      for (let i = 0; i < rawSignal.length; i++) {
        filtered[i] = rawSignal[i] * micSensitivity;
      }
      
      // Calculate signal level
      let signalLevel = 0;
      for (let i = 0; i < filtered.length; i++) {
        signalLevel += Math.abs(filtered[i]);
      }
      signalLevel /= filtered.length;
      
      // Apply noise gate
      if (signalLevel < noiseGateThreshold) {
        filtered.fill(0);
        return filtered;
      }
      
      // Simple smoothing filter
      const processedSignal = new Float32Array(filtered.length);
      let prev1 = 0, prev2 = 0;
      
      for (let i = 0; i < filtered.length; i++) {
        const input = filtered[i];
        const output = 0.25 * input + 0.5 * prev1 + 0.25 * prev2;
        processedSignal[i] = output;
        prev2 = prev1;
        prev1 = input;
      }
      
      // Soft limiting
      for (let i = 0; i < processedSignal.length; i++) {
        const sample = processedSignal[i];
        if (Math.abs(sample) > 0.9) {
          processedSignal[i] = Math.sign(sample) * Math.tanh(Math.abs(sample) / 0.9) * 0.9;
        }
      }
      
      return processedSignal;
    }
    
    // ===== CONTINUOUS MODE =====
    function startContinuousMode() {
      if (isContinuousMode) return;
      
      isContinuousMode = true;
      document.getElementById('continuousBtn').style.display = 'none';
      document.getElementById('stopContinuousBtn').style.display = 'block';
      
      continuousInterval = setInterval(async () => {
        await generateSignal();
      }, 100);
      
      logMessage('üîÑ Kontinuierlicher Modus gestartet');
      updateStatus('üîÑ Kontinuierlicher Modus aktiv', 'running');
    }
    
    function stopContinuousMode() {
      if (!isContinuousMode) return;
      
      isContinuousMode = false;
      
      if (continuousInterval) {
        clearInterval(continuousInterval);
        continuousInterval = null;
      }
      
      document.getElementById('continuousBtn').style.display = 'block';
      document.getElementById('stopContinuousBtn').style.display = 'none';
      
      logMessage('‚èπÔ∏è Kontinuierlicher Modus gestoppt');
      updateStatus('‚èπÔ∏è Kontinuierlicher Modus gestoppt', 'info');
    }
    
    // ===== FILE FUNCTIONS =====
    function loadDemoSignal() {
      try {
        logMessage('üéµ Lade Demo-Signal...');
        
        // Generate A-Major chord demo signal
        const demo = DEMO_SIGNALS.chord_a_major;
        const frequencies = [];
        
        demo.frequencies.forEach((freq, idx) => {
          frequencies.push({
            freq: freq,
            amp: demo.amplitudes[idx] * 0.7
          });
        });
        
        const demoSignal = generateMultiFrequencySignal(frequencies);
        const normalizedSignal = normalizeSignal(demoSignal);
        
        currentSignal = normalizedSignal;
        signalMetadata = {
          type: 'demo',
          name: demo.name,
          frequencies: demo.frequencies,
          duration: SIGNAL_DURATION,
          sampleRate: SAMPLE_RATE
        };
        
        updateSignalInfo();
        updateFileInfo(demo.name, 'Demo-Signal', 'Intern');
        drawOscilloscope(currentSignal);
        
        // Perform analyses
        performXiHarmonicAnalysis(currentSignal);
        performSpectrumAnalysis(currentSignal);
        
        updateStatus(`‚úÖ Demo-Signal geladen: ${demo.name}`, 'success');
        logMessage(`‚úÖ Demo-Signal geladen: ${demo.name}`);
        
      } catch (error) {
        logMessage(`‚ùå Demo-Signal Fehler: ${error.message}`);
        updateStatus('‚ùå Demo-Signal Fehler', 'error');
      }
    }
    
    function loadWavFile(file) {
      if (!file.name.toLowerCase().match(/\.(wav|mp3)$/)) {
        updateStatus('‚ö†Ô∏è Bitte eine .wav oder .mp3 Datei ausw√§hlen', 'warning');
        return;
      }
      
      updateStatus('üìÅ WAV wird geladen...', 'running');
      logMessage(`üìÅ Lade WAV-Datei: ${file.name}`);
      
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const arrayBuffer = event.target.result;
          
          if (file.name.toLowerCase().endsWith('.wav')) {
            processWavFile(arrayBuffer, file);
          } else {
            logMessage('‚ö†Ô∏è MP3-Unterst√ºtzung vereinfacht');
            updateStatus('‚ö†Ô∏è Bitte WAV-Datei verwenden', 'warning');
          }
          
        } catch (error) {
          logMessage(`‚ùå WAV-Fehler: ${error.message}`);
          updateStatus(`‚ùå Datei-Fehler: ${error.message}`, 'error');
        }
      };
      
      reader.readAsArrayBuffer(file);
    }
    
    function processWavFile(arrayBuffer, file) {
      const dataView = new DataView(arrayBuffer);
      
      // WAV header validation
      const riffHeader = String.fromCharCode(
        dataView.getUint8(0), dataView.getUint8(1), 
        dataView.getUint8(2), dataView.getUint8(3)
      );
      
      if (riffHeader !== 'RIFF') {
        throw new Error('Ung√ºltige WAV-Datei');
      }
      
      // Audio parameter extraction
      const numChannels = dataView.getUint16(22, true);
      const sampleRate = dataView.getUint32(24, true);
      const bitsPerSample = dataView.getUint16(34, true);
      
      logMessage(`üìä WAV-Info: ${numChannels}ch, ${sampleRate}Hz, ${bitsPerSample}bit`);
      
      if (bitsPerSample !== 16 && bitsPerSample !== 24 && bitsPerSample !== 32) {
        throw new Error('Unterst√ºtzt 16-bit, 24-bit und 32-bit WAV');
      }
      
      // Audio data extraction
      const dataOffset = 44;
      const bytesPerSample = bitsPerSample / 8;
      const numSamples = Math.floor((arrayBuffer.byteLength - dataOffset) / (numChannels * bytesPerSample));
      const signal = new Float32Array(numSamples);
      
      // IMPROVED: Better sample extraction with proper scaling
      for (let i = 0; i < numSamples; i++) {
        const sampleOffset = dataOffset + i * numChannels * bytesPerSample;
        let sample;
        
        if (bitsPerSample === 16) {
          sample = dataView.getInt16(sampleOffset, true) / 32768.0;
        } else if (bitsPerSample === 24) {
          const byte1 = dataView.getUint8(sampleOffset);
          const byte2 = dataView.getUint8(sampleOffset + 1);
          const byte3 = dataView.getUint8(sampleOffset + 2);
          const sample24 = (byte3 << 16) | (byte2 << 8) | byte1;
          sample = (sample24 > 8388607 ? sample24 - 16777216 : sample24) / 8388608.0;
        } else if (bitsPerSample === 32) {
          sample = dataView.getFloat32(sampleOffset, true);
        }
        
        // Stereo to mono conversion
        if (numChannels === 2) {
          let rightSample;
          const rightOffset = sampleOffset + bytesPerSample;
          
          if (bitsPerSample === 16) {
            rightSample = dataView.getInt16(rightOffset, true) / 32768.0;
          } else if (bitsPerSample === 24) {
            const byte1 = dataView.getUint8(rightOffset);
            const byte2 = dataView.getUint8(rightOffset + 1);
            const byte3 = dataView.getUint8(rightOffset + 2);
            const rightSample24 = (byte3 << 16) | (byte2 << 8) | byte1;
            rightSample = (rightSample24 > 8388607 ? rightSample24 - 16777216 : rightSample24) / 8388608.0;
          } else if (bitsPerSample === 32) {
            rightSample = dataView.getFloat32(rightOffset, true);
          }
          
          sample = (sample + rightSample) / 2;
        }
        
        signal[i] = sample;
      }
      
      // IMPROVED: Check signal levels and warn if too hot
      let maxLevel = 0;
      let rmsLevel = 0;
      for (let i = 0; i < signal.length; i++) {
        const abs = Math.abs(signal[i]);
        maxLevel = Math.max(maxLevel, abs);
        rmsLevel += signal[i] * signal[i];
      }
      rmsLevel = Math.sqrt(rmsLevel / signal.length);
      
      // Log signal levels for debugging
      logMessage(`üìä WAV-Pegel: Peak=${(maxLevel*100).toFixed(1)}%, RMS=${(rmsLevel*100).toFixed(1)}%`);
      
      // Warn if signal is very hot
      if (maxLevel > 0.95) {
        logMessage('‚ö†Ô∏è Signal ist sehr laut - m√∂glicherweise geclippt');
        updateStatus('‚ö†Ô∏è Signal sehr laut - Frequenzerkennung kann beeintr√§chtigt sein', 'warning');
      }
      
      // Resampling if needed
      let finalSignal = signal;
      if (sampleRate !== SAMPLE_RATE) {
        finalSignal = resampleSignal(signal, sampleRate, SAMPLE_RATE);
        logMessage(`üîÑ Resampling: ${sampleRate}Hz ‚Üí ${SAMPLE_RATE}Hz`);
      }
      
      // IMPROVED: Apply gentle level normalization only if needed
      if (maxLevel > 0.8 || rmsLevel > 0.3) {
        logMessage('üîß Datei-Signal wird sanft normalisiert...');
        finalSignal = normalizeSignal(finalSignal);
      }
      
      currentSignal = finalSignal;
      signalMetadata = {
        type: 'wav_file',
        filename: file.name,
        originalSampleRate: sampleRate,
        originalChannels: numChannels,
        originalBitDepth: bitsPerSample,
        originalPeakLevel: maxLevel,
        originalRmsLevel: rmsLevel,
        duration: finalSignal.length / SAMPLE_RATE,
        sampleRate: SAMPLE_RATE,
        fileSize: file.size
      };
      
      updateSignalInfo();
      updateFileInfo(
        file.name, 
        `${numChannels}ch/${sampleRate}Hz/${bitsPerSample}bit`, 
        file.size
      );
      drawOscilloscope(currentSignal);
      
      // Perform analyses
      performXiHarmonicAnalysis(currentSignal);
      performSpectrumAnalysis(currentSignal);
      
      updateStatus(`‚úÖ ${file.name} geladen`, 'success');
      logMessage(`‚úÖ WAV-Datei erfolgreich geladen: ${file.name}`);
    }
    
    function resampleSignal(inputSignal, fromRate, toRate) {
      if (fromRate === toRate) return inputSignal;
      
      const ratio = fromRate / toRate;
      const outputLength = Math.floor(inputSignal.length / ratio);
      const outputSignal = new Float32Array(outputLength);
      
      // Linear interpolation
      for (let i = 0; i < outputLength; i++) {
        const srcIndex = i * ratio;
        const srcIndexFloor = Math.floor(srcIndex);
        const fraction = srcIndex - srcIndexFloor;
        
        if (srcIndexFloor + 1 < inputSignal.length) {
          outputSignal[i] = inputSignal[srcIndexFloor] * (1 - fraction) + 
                   inputSignal[srcIndexFloor + 1] * fraction;
        } else {
          outputSignal[i] = inputSignal[srcIndexFloor];
        }
      }
      
      return outputSignal;
    }
    
    // ===== VISUALIZATION =====
    function drawOscilloscope(signal) {
      const canvas = oscilloscopeCanvas;
      const ctx = oscilloscopeCtx;
      
      if (!canvas || !ctx) return;
      
      // Performance throttling
      const now = Date.now();
      if (now - lastDrawTime < DRAW_THROTTLE_MS) {
        return; // Skip this frame
      }
      lastDrawTime = now;
      
      frameCount++; // Performance monitoring
      
      const width = canvas.width;
      const height = canvas.height;
      
      // Background
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, '#000000');
      gradient.addColorStop(0.5, '#0a0a0a');
      gradient.addColorStop(1, '#000000');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      
      drawGrid(ctx, width, height, '#333333');
      
      if (!signal || signal.length === 0) {
        ctx.fillStyle = '#667eea';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Œæ-Oszilloskop mit Spektrum-Analyzer bereit', width / 2, height / 2 - 10);
        ctx.font = '14px Arial';
        ctx.fillStyle = '#888888';
        ctx.fillText('Œæ-FFT Engine v2.0 ‚Ä¢ Performance-Optimiert ‚Ä¢ Adaptive Algorithmen', width / 2, height / 2 + 15);
        return;
      }
      
      const margin = 40;
      const plotWidth = width - 2 * margin;
      const plotHeight = height - 2 * margin;
      
      const samplesForTimeRange = Math.floor((timeRangeMs / 1000) * SAMPLE_RATE);
      const maxSamples = Math.min(signal.length, samplesForTimeRange);
      
      // Waveform rendering
      ctx.strokeStyle = '#00ff41';
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.shadowColor = '#00ff41';
      ctx.shadowBlur = 3;
      
      ctx.beginPath();
      
      let hasStarted = false;
      const step = Math.max(1, Math.floor(maxSamples / (plotWidth * 2)));
      
      for (let i = 0; i < maxSamples; i += step) {
        const x = margin + (i / maxSamples) * plotWidth;
        let amplitude = signal[i] || 0;
        
        // Amplitude processing
        amplitude = Math.max(-1, Math.min(1, amplitude * amplificationFactor));
        if (Math.abs(amplitude) > 0.95) {
          amplitude = Math.sign(amplitude) * Math.tanh(Math.abs(amplitude) * 0.95);
        }
        
        const y = margin + plotHeight / 2 - (amplitude * plotHeight / 2 * 0.9);
        
        if (!hasStarted) {
          ctx.moveTo(x, y);
          hasStarted = true;
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      // Zero line
      ctx.strokeStyle = '#444444';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(margin, height / 2);
      ctx.lineTo(width - margin, height / 2);
      ctx.stroke();
      ctx.setLineDash([]);
      
      drawOscilloscopeLabels(ctx, width, height, margin, timeRangeMs);
    }
    
    function drawSpectrum(result) {
      const canvas = spectrumCanvas;
      const ctx = spectrumCtx;
      
      if (!canvas || !ctx) return;
      
      const width = canvas.width;
      const height = canvas.height;
      
      // Background with spectrum-specific gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, '#001122');
      gradient.addColorStop(0.5, '#112233');
      gradient.addColorStop(1, '#001122');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      
      drawSpectrumGrid(ctx, width, height);
      
      if (!result || !result.magnitude) {
        ctx.fillStyle = '#00ff88';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Spektrum-Analyzer bereit', width / 2, height / 2 - 10);
        ctx.font = '12px Arial';
        ctx.fillStyle = '#66ccaa';
        ctx.fillText(`Modus: ${spectrumMode.toUpperCase()} | FFT-Gr√∂√üe: ${fftSpectrumAnalyzer ? fftSpectrumAnalyzer.config.fftSize : 'N/A'}`, width / 2, height / 2 + 15);
        return;
      }
      
      const margin = 40;
      const plotWidth = width - 2 * margin;
      const plotHeight = height - 2 * margin;
      
      if (result.type === 'waterfall' && result.waterfallData) {
        drawWaterfall(ctx, result.waterfallData, margin, plotWidth, plotHeight);
      } else {
        drawSpectrumLine(ctx, result, margin, plotWidth, plotHeight);
      }
      
      drawSpectrumLabels(ctx, width, height, margin);
    }
    
    function drawSpectrumLine(ctx, result, margin, plotWidth, plotHeight) {
      const magnitude = result.magnitude;
      const frequencies = result.frequencies;
      
      if (!magnitude || !frequencies) return;
      
      // Filter data to frequency range
      const maxFreqIndex = frequencies.findIndex(f => f > freqRangeHz);
      const endIndex = maxFreqIndex > 0 ? maxFreqIndex : frequencies.length;
      
      // Convert to display mode
      const displayMode = document.getElementById('spectrumDisplay').value;
      const displayData = convertMagnitudeForDisplay(magnitude.slice(0, endIndex), displayMode);
      
      // Draw spectrum line
      ctx.strokeStyle = result.type === 'xi' ? '#ff6600' : '#00ff88';
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.shadowColor = result.type === 'xi' ? '#ff6600' : '#00ff88';
      ctx.shadowBlur = 2;
      
      ctx.beginPath();
      
      let hasStarted = false;
      for (let i = 0; i < displayData.length; i++) {
        const freq = frequencies[i];
        const mag = displayData[i];
        
        if (freq <= freqRangeHz) {
          const x = margin + (freq / freqRangeHz) * plotWidth;
          let y;
          
          if (displayMode === 'db') {
            // dB scale: -120 to 0 dB
            const dbValue = 20 * Math.log10(Math.max(mag, 1e-6));
            const normalizedDb = Math.max(0, (dbValue + dbRange) / dbRange);
            y = margin + plotHeight * (1 - normalizedDb);
          } else {
            // Linear scale
            const normalizedMag = Math.min(1, mag);
            y = margin + plotHeight * (1 - normalizedMag);
          }
          
          if (!hasStarted) {
            ctx.moveTo(x, y);
            hasStarted = true;
          } else {
            ctx.lineTo(x, y);
          }
        }
      }
      
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      // Draw peaks
      if (result.peaks && result.peaks.length > 0) {
        drawSpectrumPeaks(ctx, result.peaks, margin, plotWidth, plotHeight, displayMode);
      }
    }
    
    function drawWaterfall(ctx, waterfallData, margin, plotWidth, plotHeight) {
      if (!waterfallData || waterfallData.length === 0) return;
      
      const lineHeight = plotHeight / waterfallData.length;
      
      for (let lineIndex = 0; lineIndex < waterfallData.length; lineIndex++) {
        const magnitude = waterfallData[lineIndex];
        const y = margin + lineIndex * lineHeight;
        
        // Filter to frequency range
        const maxFreqIndex = Math.floor(magnitude.length * freqRangeHz / (SAMPLE_RATE / 2));
        
        for (let i = 0; i < maxFreqIndex; i++) {
          const x = margin + (i / maxFreqIndex) * plotWidth;
          const mag = magnitude[i];
          
          // Color mapping based on magnitude
          const intensity = Math.min(1, mag * 10);
          const hue = 240 - intensity * 120; // Blue to red
          const saturation = 100;
          const lightness = intensity * 50;
          
          ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
          ctx.fillRect(x, y, Math.max(1, plotWidth / maxFreqIndex), lineHeight + 1);
        }
      }
    }
    
    function drawSpectrumPeaks(ctx, peaks, margin, plotWidth, plotHeight, displayMode) {
      ctx.fillStyle = '#ffff00';
      ctx.font = '10px Arial';
      
      for (let i = 0; i < Math.min(peaks.length, 10); i++) {
        const peak = peaks[i];
        const freq = peak.frequency;
        
        if (freq <= freqRangeHz) {
          const x = margin + (freq / freqRangeHz) * plotWidth;
          let y;
          
          if (displayMode === 'db') {
            const dbValue = 20 * Math.log10(Math.max(peak.magnitude, 1e-6));
            const normalizedDb = Math.max(0, (dbValue + dbRange) / dbRange);
            y = margin + plotHeight * (1 - normalizedDb);
          } else {
            const normalizedMag = Math.min(1, peak.magnitude);
            y = margin + plotHeight * (1 - normalizedMag);
          }
          
          // Peak marker
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, 2 * Math.PI);
          ctx.fill();
          
          // Frequency label
          if (i < 5) { // Only label top 5 peaks
            ctx.fillText(`${freq.toFixed(1)}Hz`, x - 20, y - 8);
          }
        }
      }
    }
    
    function convertMagnitudeForDisplay(magnitude, mode) {
      const result = new Float32Array(magnitude.length);
      
      switch(mode) {
        case 'magnitude':
          return magnitude;
          
        case 'power':
          for (let i = 0; i < magnitude.length; i++) {
            result[i] = magnitude[i] * magnitude[i];
          }
          break;
          
        case 'db':
          return magnitude; // dB conversion handled in drawing
          
        case 'log':
          for (let i = 0; i < magnitude.length; i++) {
            result[i] = Math.log10(Math.max(magnitude[i], 1e-6));
          }
          break;
          
        default:
          return magnitude;
      }
      
      return result;
    }
    
    function drawGrid(ctx, width, height, color) {
      ctx.strokeStyle = color;
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = 0.25;
      
      const gridSpacingX = width / 20;
      const gridSpacingY = height / 12;
      
      for (let x = gridSpacingX; x < width; x += gridSpacingX) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      for (let y = gridSpacingY; y < height; y += gridSpacingY) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      
      // Center lines
      ctx.strokeStyle = color.replace('#333333', '#666666');
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.7;
      
      ctx.beginPath();
      ctx.moveTo(0, height / 2);
      ctx.lineTo(width, height / 2);
      ctx.stroke();
      
      ctx.globalAlpha = 1.0;
    }
    
    function drawSpectrumGrid(ctx, width, height) {
      ctx.strokeStyle = '#004444';
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = 0.3;
      
      const gridSpacingX = width / 10; // 10 frequency divisions
      const gridSpacingY = height / 8; // 8 amplitude divisions
      
      for (let x = gridSpacingX; x < width; x += gridSpacingX) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      for (let y = gridSpacingY; y < height; y += gridSpacingY) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      
      ctx.globalAlpha = 1.0;
    }
    
    function drawOscilloscopeLabels(ctx, width, height, margin, timeRangeMs) {
      ctx.fillStyle = '#ffffff';
      ctx.font = '11px Arial';
      ctx.textAlign = 'center';
      
      // Time labels
      const timeSteps = 10;
      for (let i = 0; i <= timeSteps; i++) {
        const x = margin + (i / timeSteps) * (width - 2 * margin);
        const timeMs = (i / timeSteps) * timeRangeMs;
        ctx.fillText(`${timeMs.toFixed(1)}ms`, x, height - 8);
      }
      
      // Amplitude labels
      ctx.textAlign = 'left';
      ctx.fillStyle = '#cccccc';
      ctx.fillText('+1.0', 8, margin + 5);
      ctx.fillText('0.0', 8, height / 2 + 5);
      ctx.fillText('-1.0', 8, height - margin + 5);
      
      // Profile indicator
      ctx.fillStyle = '#00ffff';
      ctx.font = '10px Arial';
      if (xiHarmonicAnalyzer) {
        ctx.fillText(`Œæ-Harmonic: ${xiHarmonicAnalyzer.config.profile.toUpperCase()}`, 8, margin + 20);
      }
      
      // Axis labels
      ctx.font = 'bold 12px Arial';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#00ff41';
      ctx.fillText(`Zeit (${timeRangeMs} ms ‚Ä¢ ${amplificationFactor.toFixed(1)}x ‚Ä¢ FPS: ${currentFps})`, width / 2, height - 25);
    }
    
    function drawSpectrumLabels(ctx, width, height, margin) {
      ctx.fillStyle = '#ffffff';
      ctx.font = '10px Arial';
      ctx.textAlign = 'center';
      
      // Frequency labels
      const freqSteps = 5;
      for (let i = 0; i <= freqSteps; i++) {
        const x = margin + (i / freqSteps) * (width - 2 * margin);
        const freq = (i / freqSteps) * freqRangeHz;
        ctx.fillText(`${freq.toFixed(0)}Hz`, x, height - 8);
      }
      
      // Amplitude labels (dB scale)
      const displayMode = document.getElementById('spectrumDisplay').value;
      ctx.textAlign = 'left';
      ctx.fillStyle = '#aaccaa';
      
      if (displayMode === 'db') {
        ctx.fillText('0 dB', 8, margin + 5);
        ctx.fillText(`-${Math.floor(dbRange/2)} dB`, 8, height / 2 + 5);
        ctx.fillText(`-${dbRange} dB`, 8, height - margin + 5);
      } else {
        ctx.fillText('1.0', 8, margin + 5);
        ctx.fillText('0.5', 8, height / 2 + 5);
        ctx.fillText('0.0', 8, height - margin + 5);
      }
      
      // Axis labels
      ctx.font = 'bold 11px Arial';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#00ff88';
      ctx.fillText(`Frequenz (0-${freqRangeHz}Hz ‚Ä¢ ${spectrumMode.toUpperCase()} ‚Ä¢ ${displayMode.toUpperCase()})`, width / 2, height - 25);
    }
    
    // ===== UI UPDATES =====
    function updateSignalInfo() {
      try {
        if (!signalMetadata) {
          document.getElementById('signalType').textContent = 'Bereit';
          document.getElementById('signalFreqs').textContent = '--- Hz';
          document.getElementById('detectedFundamental').textContent = '--- Hz';
          return;
        }
        
        const meta = signalMetadata;
        let typeText = '';
        let freqText = '';
        
        switch(meta.type) {
          case 'generated':
            typeText = `${meta.mode} Signal`;
            freqText = 'Generiert';
            break;
          case 'microphone':
            typeText = 'Mikrofon';
            freqText = `${meta.sampleRate}Hz`;
            break;
          case 'wav_file':
            typeText = 'WAV-Datei';
            freqText = `${meta.originalSampleRate}Hz ‚Üí ${meta.sampleRate}Hz`;
            break;
          case 'demo':
            typeText = `Demo: ${meta.name}`;
            freqText = meta.frequencies.map(f => f.toFixed(0)).join(', ') + ' Hz';
            break;
          default:
            typeText = 'Signal';
            freqText = '--- Hz';
        }
        
        document.getElementById('signalType').textContent = typeText;
        document.getElementById('signalFreqs').textContent = freqText;
        
        if (lastDetectedFundamental) {
          document.getElementById('detectedFundamental').textContent = `${lastDetectedFundamental.toFixed(1)} Hz`;
          document.getElementById('frequencyIndicator').textContent = `f‚ÇÄ: ${lastDetectedFundamental.toFixed(1)} Hz`;
        } else {
          document.getElementById('detectedFundamental').textContent = '--- Hz';
        }
        
      } catch (error) {
        logMessage(`‚ö†Ô∏è Signal-Info Update Fehler: ${error.message}`);
      }
    }
    
    function updateMicLevel(percent) {
      try {
        const indicator = document.getElementById('micLevelIndicator');
        const text = document.getElementById('micLevelText');
        
        if (indicator) {
          indicator.style.width = `${percent}%`;
          if (percent > 85) {
            indicator.style.background = 'linear-gradient(90deg, #ff4757 0%, #ff3742 100%)';
          } else if (percent > 70) {
            indicator.style.background = 'linear-gradient(90deg, #ffa500 0%, #ff6348 100%)';
          } else if (percent > 50) {
            indicator.style.background = 'linear-gradient(90deg, #32cd32 0%, #ffa500 50%, #2ed573 100%)';
          } else {
            indicator.style.background = 'linear-gradient(90deg, #32cd32 0%, #2ed573 100%)';
          }
        }
        if (text) text.textContent = `${percent}%`;
      } catch (error) {
        // Ignore UI update errors
      }
    }
    
    function updateMicInfo(status, sampleRate, peakLevel) {
      try {
        const statusEl = document.getElementById('micStatus');
        const rateEl = document.getElementById('micSampleRate');
        const levelEl = document.getElementById('micPeakLevel');
        
        if (statusEl) statusEl.textContent = status;
        if (rateEl) {
          const rateText = typeof sampleRate === 'number' ? `${sampleRate} Hz` : sampleRate;
          rateEl.textContent = rateText;
        }
        if (levelEl) {
          levelEl.textContent = typeof peakLevel === 'number' ? `${peakLevel} dB` : peakLevel;
        }
      } catch (error) {
        // Ignore UI update errors
      }
    }
    
    function updateFileInfo(filename, format, size) {
      try {
        const nameEl = document.getElementById('fileName');
        const formatEl = document.getElementById('fileFormat');
        const sizeEl = document.getElementById('fileSize');
        
        if (nameEl) nameEl.textContent = filename || 'Keine geladen';
        if (formatEl) formatEl.textContent = format || '---';
        if (sizeEl) {
          if (typeof size === 'number') {
            sizeEl.textContent = `${(size/1024).toFixed(1)} KB`;
          } else {
            sizeEl.textContent = size || '--- KB';
          }
        }
      } catch (error) {
        // Ignore UI update errors
      }
    }
    
    // ===== EXPORT FUNCTIONS =====
    function exportSignalAsWav() {
      if (!currentSignal || currentSignal.length === 0) {
        updateStatus('‚ö†Ô∏è Kein Signal zum Exportieren', 'warning');
        return;
      }
      
      try {
        updateStatus('üíæ WAV wird erstellt...', 'running');
        
        const header = createWavHeader(SAMPLE_RATE, 1, currentSignal.length, 16);
        const pcmData = floatTo16BitPCM(currentSignal);
        const pcmBytes = new Uint8Array(pcmData.buffer);
        
        const wavData = new Uint8Array(header.length + pcmBytes.length);
        wavData.set(header, 0);
        wavData.set(pcmBytes, header.length);
        
        let filename = 'xi_oszilloskop_signal';
        if (signalMetadata) {
          const timestamp = new Date().toISOString().slice(0,19).replace(/[:.]/g, '-');
          filename = `xi_${signalMetadata.type}_${timestamp}`;
        }
        filename += '.wav';
        
        const blob = new Blob([wavData], { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        updateStatus(`‚úÖ ${filename} gespeichert`, 'success');
        logMessage(`üíæ WAV exportiert: ${filename}`);
        
      } catch (error) {
        logMessage(`‚ùå Export-Fehler: ${error.message}`);
        updateStatus('‚ùå Export fehlgeschlagen', 'error');
      }
    }
    
    function createWavHeader(sampleRate, numChannels, numSamples, bitsPerSample = 16) {
      const byteRate = sampleRate * numChannels * bitsPerSample / 8;
      const blockAlign = numChannels * bitsPerSample / 8;
      const dataSize = numSamples * numChannels * bitsPerSample / 8;
      const fileSize = 36 + dataSize;
      
      const buffer = new ArrayBuffer(44);
      const view = new DataView(buffer);
      
      view.setUint32(0, 0x52494646, false); // "RIFF"
      view.setUint32(4, fileSize, true);
      view.setUint32(8, 0x57415645, false); // "WAVE"
      view.setUint32(12, 0x666d7420, false); // "fmt "
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true); // PCM format
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitsPerSample, true);
      view.setUint32(36, 0x64617461, false); // "data"
      view.setUint32(40, dataSize, true);
      
      return new Uint8Array(buffer);
    }
    
    function floatTo16BitPCM(floatArray) {
      const pcmArray = new Int16Array(floatArray.length);
      for (let i = 0; i < floatArray.length; i++) {
        const clamped = Math.max(-1, Math.min(1, floatArray[i]));
        const scaled = clamped * 32767;
        
        // Triangular dithering
        const dither = (Math.random() + Math.random() - 1) * 0.5;
        pcmArray[i] = Math.round(scaled + dither);
      }
      return pcmArray;
    }
    
    function saveLog() {
      try {
        const logContainer = document.getElementById('logContainer');
        if (!logContainer) return;
        
        const timestamp = new Date().toISOString().slice(0,19).replace(/[:.]/g, '-');
        const header = `Œæ-OSZILLOSKOP mit SPEKTRUM-ANALYZER LOG\nGeneriert: ${new Date().toLocaleString()}\nVersion: Œæ-Harmonic Analyzer v2.0 + FFT Spektrum\n${'='.repeat(70)}\n\n`;
        
        const logText = logContainer.textContent || '';
        
        let systemInfo = '\nSYSTEM INFO:\n';
        systemInfo += `- Audio Context: ${audioContext ? audioContext.state : 'Nicht verf√ºgbar'}\n`;
        systemInfo += `- Sample Rate: ${SAMPLE_RATE} Hz\n`;
        systemInfo += `- Aktuelles Signal: ${signalMetadata ? signalMetadata.type : 'Keines'}\n`;
        systemInfo += `- Letzte Grundfrequenz: ${lastDetectedFundamental ? lastDetectedFundamental.toFixed(1) + ' Hz' : 'Keine'}\n`;
        systemInfo += `- Performance: ${currentFps} FPS\n`;
        systemInfo += `- Spektrum-Modus: ${spectrumMode.toUpperCase()}\n`;
        
        if (xiHarmonicAnalyzer) {
          const config = xiHarmonicAnalyzer.config;
          systemInfo += `\nŒæ-HARMONIC ANALYZER INFO:\n`;
          systemInfo += `- Profil: ${config.profile}\n`;
          systemInfo += `- Œæ-Parameter: ${config.xiValue}\n`;
          systemInfo += `- Schwellwert: ${config.threshold}\n`;
          systemInfo += `- Cache-Gr√∂√üe: ${xiHarmonicAnalyzer.cache.size}\n`;
          systemInfo += `- Methode: Autokorrelation + Œæ-Bewertung\n`;
        }
        
        if (fftSpectrumAnalyzer) {
          const config = fftSpectrumAnalyzer.config;
          systemInfo += `\nFFT SPEKTRUM-ANALYZER INFO:\n`;
          systemInfo += `- FFT-Gr√∂√üe: ${config.fftSize}\n`;
          systemInfo += `- Fenster-Funktion: ${config.windowFunction}\n`;
          systemInfo += `- Averaging: ${config.averagingFrames} Frames\n`;
          systemInfo += `- Frequenz-Bereich: 0-${freqRangeHz} Hz\n`;
          systemInfo += `- dB-Bereich: ${dbRange} dB\n`;
        }
        
        if (currentXiResult) {
          systemInfo += `\nLETZTE Œæ-HARMONIC ANALYSE:\n`;
          systemInfo += `- Peaks: ${currentXiResult.peaks ? currentXiResult.peaks.length : 0}\n`;
          systemInfo += `- Œæ-Ratios: ${currentXiResult.xiRatios ? currentXiResult.xiRatios.length : 0}\n`;
          if (currentXiResult.analysisTime) {
            systemInfo += `- Analyse-Zeit: ${currentXiResult.analysisTime.toFixed(1)}ms\n`;
          }
          if (currentXiResult.strategy) {
            systemInfo += `- Strategie: ${currentXiResult.strategy.algorithm}\n`;
            systemInfo += `- Beschreibung: ${currentXiResult.strategy.description || 'Standard'}\n`;
          }
        }
        
        if (currentSpectrumResult) {
          systemInfo += `\nLETZTE SPEKTRUM-ANALYSE:\n`;
          systemInfo += `- Typ: ${currentSpectrumResult.type ? currentSpectrumResult.type.toUpperCase() : 'UNKNOWN'}\n`;
          systemInfo += `- Peaks: ${currentSpectrumResult.peaks ? currentSpectrumResult.peaks.length : 0}\n`;
          if (currentSpectrumResult.fftSize) {
            systemInfo += `- FFT-Gr√∂√üe: ${currentSpectrumResult.fftSize}\n`;
          }
        }
        
        // Microphone info
        if (isRecordingMic) {
          systemInfo += `\nMIKROFON INFO:\n`;
          systemInfo += `- Mikrofon aktiv: Empfindlichkeit=${micSensitivity.toFixed(1)}x\n`;
          systemInfo += `- Noise Gate: ${noiseGateThreshold.toFixed(2)}\n`;
          systemInfo += `- Clipping erkannt: ${isClipping ? 'JA' : 'NEIN'}\n`;
          systemInfo += `- Live-Analyse: ${isLiveAnalysisRunning ? 'AKTIV' : 'INAKTIV'}\n`;
        }
        
        const fullContent = header + logText + systemInfo + `\n\n${'='.repeat(70)}\nŒæ-Harmonic Analyzer + Spektrum Log Ende`;
        
        const blob = new Blob([fullContent], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `xi-oszilloskop-spektrum_${timestamp}.txt`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        updateStatus(`‚úÖ Log gespeichert`, 'success');
        logMessage(`üíæ Log-Datei gespeichert`);
        
      } catch (error) {
        logMessage(`‚ùå Log-Speichern Fehler: ${error.message}`);
      }
    }
    
    function logMessage(message) {
      try {
        const logContainer = document.getElementById('logContainer');
        if (logContainer) {
          const timestamp = new Date().toLocaleTimeString();
          const lines = logContainer.innerHTML.split('<br>');
          
          if (lines.length > LOG_MAX_LINES) {
            lines.splice(0, lines.length - LOG_MAX_LINES);
            logContainer.innerHTML = lines.join('<br>');
          }
          
          logContainer.innerHTML += `<br>[${timestamp}] ${message}`;
          logContainer.scrollTop = logContainer.scrollHeight;
        }
        console.log(`[Œæ-Oszilloskop Spektrum] ${message}`);
      } catch (error) {
        console.log(`[Œæ-Oszilloskop Spektrum] ${message}`);
      }
    }
    
    function updateStatus(message, type = 'info') {
      try {
        const statusDisplay = document.getElementById('statusDisplay');
        if (statusDisplay) {
          statusDisplay.textContent = message;
          
          const colors = {
            success: 'linear-gradient(135deg, #2ed573 0%, #17a2b8 100%)',
            error: 'linear-gradient(135deg, #ff4757 0%, #ff3742 100%)',
            running: 'linear-gradient(135deg, #ffa502 0%, #ff6348 100%)',
            warning: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
            info: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'
          };
          
          statusDisplay.style.background = colors[type] || colors.info;
          
          statusDisplay.style.transform = 'scale(1.02)';
          setTimeout(() => {
            statusDisplay.style.transform = 'scale(1.0)';
          }, 200);
        }
      } catch (error) {
        console.error('Status update error:', error);
      }
    }
    
    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(initializeSystem, 100);
    });
    
    // Error handling
    window.addEventListener('error', function(event) {
      logMessage(`‚ùå System Error: ${event.message}`);
      updateStatus('‚ùå System Error - siehe Log', 'error');
    });
    
    // Performance monitoring
    window.addEventListener('beforeunload', function() {
      if (isRecordingMic) {
        stopMicrophone();
      }
      if (isContinuousMode) {
        stopContinuousMode();
      }
    });
    
    console.log('üî¨ Œæ-Oszilloskop mit Spektrum-Analyzer geladen - Version 2.0');
    console.log('‚ú® Features: Œæ-Harmonic Analyzer v2.0 ‚Ä¢ Autokorrelations-basiert ‚Ä¢ Harmonik-Analyse ‚Ä¢ FFT-Spektrum ‚Ä¢ Real-time Processing');
  </script>
</body>
</html>
            
