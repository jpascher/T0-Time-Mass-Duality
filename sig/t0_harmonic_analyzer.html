<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rational Harmonic Analyzer - Test Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            text-align: center;
            margin-bottom: 40px;
            font-size: 1.2em;
            opacity: 0.9;
        }

        .panel {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .panel h2 {
            color: #ffd700;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #fff;
        }

        input, select, button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input, select {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        input:focus, select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.5);
            transform: translateY(-2px);
        }

        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            cursor: pointer;
            font-weight: bold;
            margin: 5px 0;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        canvas {
            width: 100%;
            height: 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .analysis-results {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid rgba(255, 255, 255, 0.2);
            line-height: 1.2;
        }

        .log-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .log-controls button {
            width: auto;
            padding: 8px 16px;
            font-size: 14px;
            margin: 0;
        }

        .save-btn {
            background: linear-gradient(45deg, #2196F3, #1976D2) !important;
        }

        .clear-btn {
            background: linear-gradient(45deg, #ff9800, #f57c00) !important;
        }

        .copy-btn {
            background: linear-gradient(45deg, #9c27b0, #7b1fa2) !important;
        }

        .frequency-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .freq-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .freq-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #ffd700;
        }

        .interval-info {
            margin-top: 10px;
            font-size: 0.9em;
            opacity: 0.8;
        }

        .xi-controls {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .xi-controls h3 {
            color: #ffd700;
            margin-bottom: 15px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-playing { background: #4CAF50; }
        .status-stopped { background: #f44336; }

        .spectrum-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .spectrum-controls label {
            margin: 0;
            min-width: auto;
        }

        .spectrum-controls input, .spectrum-controls select {
            width: auto;
            min-width: 100px;
            padding: 8px;
        }

        .zoom-controls {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .freq-range {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .freq-range input {
            width: 80px;
        }

        .octave-controls {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .octave-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .octave-preset {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .octave-preset:hover {
            background: rgba(0, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .scale-controls {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid rgba(255, 0, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .scale-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .scale-preset {
            background: rgba(255, 0, 255, 0.2);
            border: 1px solid rgba(255, 0, 255, 0.4);
            border-radius: 5px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 11px;
        }

        .scale-preset:hover {
            background: rgba(255, 0, 255, 0.3);
            transform: translateY(-2px);
        }

        .spectrum-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 12px;
            opacity: 0.8;
        }

        .analysis-header {
            color: #ffd700;
            font-size: 14px;
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 5px;
            border-left: 4px solid #ffd700;
        }

        .measurement-block {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 3px solid #4CAF50;
        }

        .calculation-block {
            background: rgba(0, 150, 255, 0.1);
            padding: 6px;
            margin: 3px 0;
            border-radius: 3px;
            font-size: 11px;
        }

        .result-block {
            background: rgba(255, 100, 100, 0.1);
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 3px solid #ff6464;
        }

        .success { border-left-color: #4CAF50; background: rgba(76, 175, 80, 0.1); }
        .warning { border-left-color: #ff9800; background: rgba(255, 152, 0, 0.1); }
        .error { border-left-color: #f44336; background: rgba(244, 67, 54, 0.1); }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .frequency-display {
                grid-template-columns: 1fr;
            }
            
            .spectrum-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .spectrum-controls input, .spectrum-controls select {
                width: 100%;
            }
            
            .freq-range {
                flex-direction: column;
                gap: 5px;
            }
            
            .octave-grid, .scale-grid {
                grid-template-columns: 1fr;
            }

            .log-controls {
                flex-direction: column;
            }

            .log-controls button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎵 Rational Harmonic Analyzer</h1>
        <p class="subtitle">
            Test Interface für Spektrum-Darstellung und Frequenz-Generator<br>
            <em>Implementiert: ξ-Parameter, Euler's Gradus Suavitatis, Oktav-Reduktion & Rationale Arithmetik</em>
        </p>

        <div class="controls-grid">
            <!-- Frequenz-Generator Panel -->
            <div class="panel">
                <h2>🎛️ Frequenz-Generator</h2>
                
                <div class="control-group">
                    <label for="masterVolume">Master Lautstärke</label>
                    <input type="range" id="masterVolume" min="0" max="100" value="30">
                    <span id="volumeValue">30%</span>
                </div>

                <div class="control-group">
                    <label for="generatorMode">Generator-Modus</label>
                    <select id="generatorMode">
                        <option value="single">Einzelfrequenz</option>
                        <option value="chord">Akkord (3 Frequenzen)</option>
                        <option value="harmonic">Harmonische Reihe</option>
                        <option value="beating">Beat-Frequenzen</option>
                        <option value="custom">Benutzerdefiniert</option>
                    </select>
                </div>

                <div id="frequencyInputs" class="frequency-display">
                    <!-- Dynamisch generiert -->
                </div>

                <div class="control-group">
                    <button id="playButton">▶️ Abspielen</button>
                    <button id="stopButton">⏹️ Stoppen</button>
                    <button id="analyzeButton">🔬 Analysieren</button>
                </div>

                <div class="octave-controls">
                    <h3>🎼 Oktav-Kombinationen</h3>
                    <div class="control-group">
                        <label for="baseNote">Grundton</label>
                        <select id="baseNote">
                            <option value="261.63">C4 (261.63 Hz)</option>
                            <option value="277.18">C#4 (277.18 Hz)</option>
                            <option value="293.66">D4 (293.66 Hz)</option>
                            <option value="311.13">D#4 (311.13 Hz)</option>
                            <option value="329.63">E4 (329.63 Hz)</option>
                            <option value="349.23">F4 (349.23 Hz)</option>
                            <option value="369.99">F#4 (369.99 Hz)</option>
                            <option value="392.00">G4 (392.00 Hz)</option>
                            <option value="415.30">G#4 (415.30 Hz)</option>
                            <option value="440.00" selected>A4 (440.00 Hz)</option>
                            <option value="466.16">A#4 (466.16 Hz)</option>
                            <option value="493.88">B4 (493.88 Hz)</option>
                        </select>
                    </div>
                    
                    <div class="octave-grid">
                        <div class="octave-preset" data-octaves="unison">
                            <strong>Unison</strong><br>
                            Grundton (1:1)
                        </div>
                        <div class="octave-preset" data-octaves="octave">
                            <strong>Oktave</strong><br>
                            Grundton + Oktave (1:2)
                        </div>
                        <div class="octave-preset" data-octaves="fifth">
                            <strong>Perfect Fifth</strong><br>
                            Grundton + Quinte (2:3)
                        </div>
                        <div class="octave-preset" data-octaves="fourth">
                            <strong>Perfect Fourth</strong><br>
                            Grundton + Quarte (3:4)
                        </div>
                        <div class="octave-preset" data-octaves="major3rd">
                            <strong>Major Third</strong><br>
                            Grundton + große Terz (4:5)
                        </div>
                        <div class="octave-preset" data-octaves="minor3rd">
                            <strong>Minor Third</strong><br>
                            Grundton + kleine Terz (5:6)
                        </div>
                        <div class="octave-preset" data-octaves="tritone">
                            <strong>Tritone</strong><br>
                            Grundton + Tritonus (32:45)
                        </div>
                        <div class="octave-preset" data-octaves="harmonic">
                            <strong>Harmonische Reihe</strong><br>
                            1:2:3:4:5 Obertöne
                        </div>
                        <div class="octave-preset" data-octaves="cross-octave">
                            <strong>Cross-Oktaven</strong><br>
                            Über 3 Oktaven verteilt
                        </div>
                        <div class="octave-preset" data-octaves="cluster">
                            <strong>Cluster</strong><br>
                            Dichte Frequenzen
                        </div>
                    </div>
                </div>

                <div class="scale-controls">
                    <h3>🎵 Musikalische Skalen</h3>
                    <div class="scale-grid">
                        <div class="scale-preset" data-scale="major">
                            <strong>Dur-Tonleiter</strong><br>
                            C-D-E-F-G-A-B-C
                        </div>
                        <div class="scale-preset" data-scale="minor">
                            <strong>Moll-Tonleiter</strong><br>
                            A-B-C-D-E-F-G-A
                        </div>
                        <div class="scale-preset" data-scale="pentatonic">
                            <strong>Pentatonisch</strong><br>
                            C-D-E-G-A-C
                        </div>
                        <div class="scale-preset" data-scale="chromatic">
                            <strong>Chromatisch</strong><br>
                            Alle 12 Halbtöne
                        </div>
                        <div class="scale-preset" data-scale="dorian">
                            <strong>Dorisch</strong><br>
                            D-E-F-G-A-B-C-D
                        </div>
                        <div class="scale-preset" data-scale="mixolydian">
                            <strong>Mixolydisch</strong><br>
                            G-A-B-C-D-E-F-G
                        </div>
                        <div class="scale-preset" data-scale="blues">
                            <strong>Blues-Skala</strong><br>
                            C-Eb-F-F#-G-Bb-C
                        </div>
                        <div class="scale-preset" data-scale="whole-tone">
                            <strong>Ganzton</strong><br>
                            C-D-E-F#-G#-A#-C
                        </div>
                        <div class="scale-preset" data-scale="just-intonation">
                            <strong>Just Intonation</strong><br>
                            Reine Stimmung
                        </div>
                        <div class="scale-preset" data-scale="pythagorean">
                            <strong>Pythagoräisch</strong><br>
                            Quinten-Stimmung
                        </div>
                    </div>
                </div>
            </div>

            <!-- ξ-Parameter Kontrollen -->
            <div class="panel">
                <h2>⚡ ξ-Parameter Kontrollen</h2>
                
                <div class="xi-controls">
                    <h3>T0-Theory ξ-Profile</h3>
                    <div class="control-group">
                        <label for="xiProfile">ξ-Profil</label>
                        <select id="xiProfile">
                            <option value="strict">Strict (10¢) - Twin Prime Optimized</option>
                            <option value="standard" selected>Standard (50¢) - Universal</option>
                            <option value="loose">Loose (100¢) - Medium Size</option>
                            <option value="experimental">Experimental (200¢) - Special Cases</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="toleranceCents">Toleranz (Cents)</label>
                        <input type="range" id="toleranceCents" min="1" max="300" value="50">
                        <span id="toleranceValue">50¢</span>
                    </div>
                </div>

                <div class="control-group">
                    <label for="analysisMode">Analyse-Modus</label>
                    <select id="analysisMode">
                        <option value="rational">Rationale Arithmetik</option>
                        <option value="floating">Floating-Point (Vergleich)</option>
                        <option value="both">Beide (Genauigkeits-Vergleich)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="eulerComplexity">Euler Komplexitäts-Filter</label>
                    <select id="eulerComplexity">
                        <option value="all">Alle Intervalle</option>
                        <option value="perfect">Nur Perfect (Gradus ≤3)</option>
                        <option value="consonant">Nur Consonant (Gradus ≤4)</option>
                        <option value="simple">Nur Simple (Gradus ≤6)</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Spektrum-Anzeige -->
        <div class="panel">
            <h2>📊 Erweiterte Spektrum-Darstellung</h2>
            
            <div class="zoom-controls">
                <div class="freq-range">
                    <label>Frequenzbereich:</label>
                    <input type="number" id="minFreq" value="20" min="1" max="20000"> Hz bis
                    <input type="number" id="maxFreq" value="2000" min="1" max="20000"> Hz
                    <button id="autoZoom">Auto-Zoom auf aktive Frequenzen</button>
                </div>
                
                <div class="spectrum-controls">
                    <label for="spectrumScale">Skalierung:</label>
                    <select id="spectrumScale">
                        <option value="linear">Linear</option>
                        <option value="log" selected>Logarithmisch</option>
                    </select>
                    
                    <label for="spectrumSmoothing">Glättung:</label>
                    <input type="range" id="spectrumSmoothing" min="0" max="0.9" step="0.1" value="0.8">
                    <span id="smoothingValue">0.8</span>
                    
                    <label for="peakThreshold">Peak-Schwelle:</label>
                    <input type="range" id="peakThreshold" min="0" max="255" value="50">
                    <span id="thresholdValue">50</span>
                    
                    <label for="spectrumGain">Verstärkung:</label>
                    <input type="range" id="spectrumGain" min="0.1" max="5" step="0.1" value="1">
                    <span id="gainValue">1x</span>
                </div>
            </div>
            
            <div style="position: relative;">
                <canvas id="spectrumCanvas"></canvas>
                <div class="peak-labels" id="peakLabels"></div>
            </div>
            
            <div class="spectrum-info">
                <span id="freqInfo">Fahren Sie mit der Maus über das Spektrum für Frequenz-Info</span>
                <span id="peakInfo">Peaks: <span id="peakCount">0</span></span>
                <span><span class="status-indicator" id="audioStatus"></span><span id="statusText">Audio gestoppt</span></span>
            </div>
        </div>

        <!-- Analyse-Ergebnisse -->
        <div class="panel">
            <h2>🔬 Harmonik-Analyse Ergebnisse</h2>
            
            <div class="log-controls">
                <button id="saveLogButton" class="save-btn">💾 Log Speichern</button>
                <button id="copyLogButton" class="copy-btn">📋 Log Kopieren</button>
                <button id="clearLogButton" class="clear-btn">🗑️ Log Löschen</button>
                <button id="exportLogButton" class="save-btn">📊 Export CSV</button>
            </div>
            
            <div class="analysis-results" id="analysisResults">
                <div style="text-align: center; opacity: 0.6; padding: 40px;">
                    Klicken Sie auf "Analysieren" um die Harmonik-Analyse zu starten...<br><br>
                    <em>Diese Analyse implementiert:</em><br>
                    • Rationale Arithmetik (100% exakt)<br>
                    • Oktav-Reduktion (universelle Äquivalenz)<br>
                    • Euler's Gradus Suavitatis (1739)<br>
                    • ξ-Parameter (T0-Theory kompatibel)<br>
                    • Just Intonation Erkennung
                </div>
            </div>
        </div>
    </div>

    <script>
        // Audio Context und Variablen
        let audioContext;
        let oscillators = [];
        let gainNode;
        let analyser;
        let spectrumCanvas;
        let spectrumCtx;
        let animationId;

        // Spektrum-Variablen
        let minDisplayFreq = 20;
        let maxDisplayFreq = 2000;
        let spectrumScale = 'log';
        let spectrumSmoothing = 0.8;
        let peakThreshold = 50;
        let spectrumGain = 1.0;

        // Log-Storage für Export
        let analysisLog = [];

        // Erweiterte Oktav-Kombinationen
        const octaveCombinations = {
            unison: (base) => [base],
            octave: (base) => [base, base * 2],
            fifth: (base) => [base, base * 1.5],
            fourth: (base) => [base, base * 4/3],
            major3rd: (base) => [base, base * 5/4],
            minor3rd: (base) => [base, base * 6/5],
            tritone: (base) => [base, base * 45/32],
            harmonic: (base) => [base, base * 2, base * 3, base * 4, base * 5],
            'cross-octave': (base) => [base, base * 1.5, base * 2, base * 2.5, base * 4],
            cluster: (base) => [base, base * 1.05, base * 1.1, base * 1.15, base * 1.2]
        };

        // Musikalische Skalen (Verhältnisse zur Grundfrequenz)
        const musicalScales = {
            major: [1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8, 2],
            minor: [1, 9/8, 6/5, 4/3, 3/2, 8/5, 9/5, 2],
            pentatonic: [1, 9/8, 5/4, 3/2, 5/3, 2],
            chromatic: [1, 16/15, 9/8, 6/5, 5/4, 4/3, 45/32, 3/2, 8/5, 5/3, 9/5, 15/8],
            dorian: [1, 9/8, 6/5, 4/3, 3/2, 5/3, 16/9, 2],
            mixolydian: [1, 9/8, 5/4, 4/3, 3/2, 5/3, 16/9, 2],
            blues: [1, 6/5, 4/3, 7/5, 3/2, 16/9, 2],
            'whole-tone': [1, 9/8, 5/4, 45/32, 5/3, 15/8, 2],
            'just-intonation': [1, 16/15, 9/8, 6/5, 5/4, 4/3, 7/5, 3/2, 8/5, 5/3, 9/5, 15/8],
            pythagorean: [1, 256/243, 9/8, 32/27, 81/64, 4/3, 729/512, 3/2, 128/81, 27/16, 16/9, 243/128]
        };

        // Rationale Arithmetik Klasse
        class RationalNumber {
            constructor(num, den = 1) {
                if (den === 0) throw new Error("Denominator cannot be zero");
                
                const gcd = this.gcd(Math.abs(num), Math.abs(den));
                this.numerator = Math.floor(num / gcd);
                this.denominator = Math.floor(den / gcd);
                
                if (this.denominator < 0) {
                    this.numerator = -this.numerator;
                    this.denominator = -this.denominator;
                }
            }
            
            gcd(a, b) {
                while (b !== 0) {
                    [a, b] = [b, a % b];
                }
                return a;
            }
            
            multiply(other) {
                return new RationalNumber(
                    this.numerator * other.numerator,
                    this.denominator * other.denominator
                );
            }
            
            divide(other) {
                return new RationalNumber(
                    this.numerator * other.denominator,
                    this.denominator * other.numerator
                );
            }
            
            reduceToOctave() {
                let ratio = new RationalNumber(this.numerator, this.denominator);
                const two = new RationalNumber(2, 1);
                
                while (ratio.toFloat() >= 2.0) {
                    ratio = ratio.divide(two);
                }
                
                while (ratio.toFloat() < 1.0) {
                    ratio = ratio.multiply(two);
                }
                
                return ratio;
            }
            
            toFloat() {
                return this.numerator / this.denominator;
            }
            
            toString() {
                return this.denominator === 1 ? this.numerator.toString() : `${this.numerator}/${this.denominator}`;
            }
        }

        // Musikalische Intervalle mit Euler Gradus
        class MusicalInterval {
            constructor(ratio, name, category) {
                this.ratio = ratio;
                this.name = name;
                this.category = category;
                this.eulerGradus = this.calculateEulerGradus(ratio);
            }
            
            calculateEulerGradus(ratio) {
                const numFactors = this.countPrimeFactors(Math.abs(ratio.numerator));
                const denFactors = this.countPrimeFactors(Math.abs(ratio.denominator));
                return numFactors + denFactors + 1;
            }
            
            countPrimeFactors(n) {
                let count = 0;
                let factor = 2;
                
                while (factor * factor <= n) {
                    while (n % factor === 0) {
                        count++;
                        n = n / factor;
                    }
                    factor++;
                }
                
                if (n > 1) count++;
                return count;
            }
        }

        // Just Intonation Intervalle
        const justIntervals = [
            new MusicalInterval(new RationalNumber(1, 1), "Unison", "PERFECT"),
            new MusicalInterval(new RationalNumber(16, 15), "Minor Second", "MINOR"),
            new MusicalInterval(new RationalNumber(9, 8), "Major Second", "MAJOR"),
            new MusicalInterval(new RationalNumber(6, 5), "Minor Third", "MINOR"),
            new MusicalInterval(new RationalNumber(5, 4), "Major Third", "MAJOR"),
            new MusicalInterval(new RationalNumber(4, 3), "Perfect Fourth", "PERFECT"),
            new MusicalInterval(new RationalNumber(45, 32), "Tritone", "DISSONANT"),
            new MusicalInterval(new RationalNumber(3, 2), "Perfect Fifth", "PERFECT"),
            new MusicalInterval(new RationalNumber(8, 5), "Minor Sixth", "MINOR"),
            new MusicalInterval(new RationalNumber(5, 3), "Major Sixth", "MAJOR"),
            new MusicalInterval(new RationalNumber(16, 9), "Minor Seventh", "MINOR"),
            new MusicalInterval(new RationalNumber(15, 8), "Major Seventh", "MAJOR"),
            new MusicalInterval(new RationalNumber(2, 1), "Octave", "PERFECT")
        ];

        // Initialisierung
        document.addEventListener('DOMContentLoaded', function() {
            console.log("🚀 DOM loaded, initializing application");
            
            spectrumCanvas = document.getElementById('spectrumCanvas');
            spectrumCtx = spectrumCanvas.getContext('2d');
            
            if (!spectrumCanvas || !spectrumCtx) {
                console.error("Failed to get canvas or context");
                return;
            }
            
            setupEventListeners();
            updateFrequencyInputs();
            
            console.log("Application ready - click play to start audio");
        });

        function setupEventListeners() {
            // Generator-Modus Änderung
            document.getElementById('generatorMode').addEventListener('change', updateFrequencyInputs);
            
            // Lautstärke
            document.getElementById('masterVolume').addEventListener('input', function(e) {
                const volume = e.target.value / 100 * 0.2;
                document.getElementById('volumeValue').textContent = e.target.value + '%';
                if (gainNode) {
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                }
            });

            // ξ-Parameter
            document.getElementById('toleranceCents').addEventListener('input', function(e) {
                document.getElementById('toleranceValue').textContent = e.target.value + '¢';
            });

            document.getElementById('xiProfile').addEventListener('change', function(e) {
                const profiles = {
                    strict: 10,
                    standard: 50,
                    loose: 100,
                    experimental: 200
                };
                const tolerance = profiles[e.target.value];
                document.getElementById('toleranceCents').value = tolerance;
                document.getElementById('toleranceValue').textContent = tolerance + '¢';
            });

            // Buttons
            document.getElementById('playButton').addEventListener('click', playAudio);
            document.getElementById('stopButton').addEventListener('click', stopAudio);
            document.getElementById('analyzeButton').addEventListener('click', analyzeHarmonics);

            // Log-Kontrollen
            document.getElementById('saveLogButton').addEventListener('click', saveLog);
            document.getElementById('copyLogButton').addEventListener('click', copyLog);
            document.getElementById('clearLogButton').addEventListener('click', clearLog);
            document.getElementById('exportLogButton').addEventListener('click', exportLogCSV);

            // Oktav-Kombinationen
            document.querySelectorAll('.octave-preset').forEach(preset => {
                preset.addEventListener('click', function() {
                    const octaveType = this.dataset.octaves;
                    loadOctaveCombination(octaveType);
                });
            });

            // Musikalische Skalen
            document.querySelectorAll('.scale-preset').forEach(preset => {
                preset.addEventListener('click', function() {
                    const scaleType = this.dataset.scale;
                    loadMusicalScale(scaleType);
                });
            });

            // Spektrum-Kontrollen
            document.getElementById('minFreq').addEventListener('input', updateSpectrumRange);
            document.getElementById('maxFreq').addEventListener('input', updateSpectrumRange);
            document.getElementById('autoZoom').addEventListener('click', autoZoomToFrequencies);
            document.getElementById('spectrumScale').addEventListener('change', function(e) {
                spectrumScale = e.target.value;
            });
            document.getElementById('spectrumSmoothing').addEventListener('input', function(e) {
                spectrumSmoothing = parseFloat(e.target.value);
                document.getElementById('smoothingValue').textContent = e.target.value;
                if (analyser) {
                    analyser.smoothingTimeConstant = spectrumSmoothing;
                }
            });
            document.getElementById('peakThreshold').addEventListener('input', function(e) {
                peakThreshold = parseInt(e.target.value);
                document.getElementById('thresholdValue').textContent = e.target.value;
            });
            document.getElementById('spectrumGain').addEventListener('input', function(e) {
                spectrumGain = parseFloat(e.target.value);
                document.getElementById('gainValue').textContent = e.target.value + 'x';
            });

            // Mouse-over für Spektrum
            document.getElementById('spectrumCanvas').addEventListener('mousemove', handleSpectrumMouseMove);
        }

        function updateFrequencyInputs() {
            const mode = document.getElementById('generatorMode').value;
            const container = document.getElementById('frequencyInputs');
            
            let inputCount = 1;
            switch(mode) {
                case 'single': inputCount = 1; break;
                case 'chord': inputCount = 3; break;
                case 'harmonic': inputCount = 4; break;
                case 'beating': inputCount = 2; break;
                case 'custom': inputCount = 6; break;
            }

            container.innerHTML = '';
            
            for (let i = 0; i < inputCount; i++) {
                const freqCard = document.createElement('div');
                freqCard.className = 'freq-card';
                freqCard.innerHTML = `
                    <label for="freq${i}">Frequenz ${i + 1} (Hz)</label>
                    <input type="number" id="freq${i}" min="20" max="20000" value="${getDefaultFrequency(mode, i)}" step="0.1">
                    <div class="freq-value" id="freqDisplay${i}">${getDefaultFrequency(mode, i)} Hz</div>
                    <div class="interval-info" id="intervalInfo${i}">-</div>
                `;
                container.appendChild(freqCard);
                
                document.getElementById(`freq${i}`).addEventListener('input', function(e) {
                    document.getElementById(`freqDisplay${i}`).textContent = e.target.value + ' Hz';
                    updateIntervalInfo();
                });
            }
            
            updateIntervalInfo();
        }

        function getDefaultFrequency(mode, index) {
            const defaults = {
                single: [440],
                chord: [261.63, 329.63, 392.00],
                harmonic: [110, 220, 330, 440],
                beating: [440, 442],
                custom: [220, 330, 440, 550, 660, 770]
            };
            return defaults[mode] ? defaults[mode][index] || 440 : 440;
        }

        function updateIntervalInfo() {
            const mode = document.getElementById('generatorMode').value;
            if (mode === 'single') return;

            const frequencies = getCurrentFrequencies();
            
            for (let i = 1; i < frequencies.length; i++) {
                const ratio = frequencies[i] / frequencies[0];
                const interval = findClosestInterval(ratio);
                const infoElement = document.getElementById(`intervalInfo${i}`);
                
                if (infoElement && interval) {
                    const cents = calculateCentsDeviation(ratio, interval.ratio.toFloat());
                    infoElement.innerHTML = `
                        ${interval.name}<br>
                        Ratio: ${ratio.toFixed(3)} (${interval.ratio})<br>
                        Deviation: ${cents.toFixed(1)}¢
                    `;
                }
            }
        }

        function loadOctaveCombination(octaveType) {
            const baseFreq = parseFloat(document.getElementById('baseNote').value);
            const frequencies = octaveCombinations[octaveType](baseFreq);
            
            let mode = 'custom';
            if (frequencies.length === 1) mode = 'single';
            else if (frequencies.length === 2) mode = 'beating';
            else if (frequencies.length === 3) mode = 'chord';
            else if (frequencies.length > 3) mode = 'harmonic';
            
            document.getElementById('generatorMode').value = mode;
            updateFrequencyInputs();
            
            frequencies.forEach((freq, index) => {
                const input = document.getElementById(`freq${index}`);
                if (input) {
                    input.value = freq.toFixed(2);
                    document.getElementById(`freqDisplay${index}`).textContent = freq.toFixed(2) + ' Hz';
                }
            });
            
            updateIntervalInfo();
            
            const minFreq = Math.min(...frequencies) * 0.8;
            const maxFreq = Math.max(...frequencies) * 1.2;
            document.getElementById('minFreq').value = Math.round(minFreq);
            document.getElementById('maxFreq').value = Math.round(maxFreq);
            updateSpectrumRange();
        }

        function loadMusicalScale(scaleType) {
            const baseFreq = parseFloat(document.getElementById('baseNote').value);
            const ratios = musicalScales[scaleType];
            
            if (!ratios) return;
            
            const frequencies = ratios.map(ratio => baseFreq * ratio);
            
            document.getElementById('generatorMode').value = 'custom';
            updateFrequencyInputs();
            
            frequencies.slice(0, 6).forEach((freq, index) => {
                const input = document.getElementById(`freq${index}`);
                if (input) {
                    input.value = freq.toFixed(2);
                    document.getElementById(`freqDisplay${index}`).textContent = freq.toFixed(2) + ' Hz';
                }
            });
            
            updateIntervalInfo();
            
            const minFreq = Math.min(...frequencies) * 0.9;
            const maxFreq = Math.max(...frequencies) * 1.1;
            document.getElementById('minFreq').value = Math.round(minFreq);
            document.getElementById('maxFreq').value = Math.round(maxFreq);
            updateSpectrumRange();
        }

        function updateSpectrumRange() {
            minDisplayFreq = parseInt(document.getElementById('minFreq').value);
            maxDisplayFreq = parseInt(document.getElementById('maxFreq').value);
            
            if (minDisplayFreq >= maxDisplayFreq) {
                maxDisplayFreq = minDisplayFreq + 100;
                document.getElementById('maxFreq').value = maxDisplayFreq;
            }
        }

        function autoZoomToFrequencies() {
            const frequencies = getCurrentFrequencies();
            if (frequencies.length === 0) return;
            
            const minFreq = Math.min(...frequencies);
            const maxFreq = Math.max(...frequencies);
            const padding = (maxFreq - minFreq) * 0.2 || 100;
            
            document.getElementById('minFreq').value = Math.max(1, Math.round(minFreq - padding));
            document.getElementById('maxFreq').value = Math.round(maxFreq + padding);
            updateSpectrumRange();
        }

        function handleSpectrumMouseMove(event) {
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const normalizedX = x / canvas.offsetWidth;
            
            let frequency;
            if (spectrumScale === 'log') {
                const logMin = Math.log10(minDisplayFreq);
                const logMax = Math.log10(maxDisplayFreq);
                const logFreq = logMin + normalizedX * (logMax - logMin);
                frequency = Math.pow(10, logFreq);
            } else {
                frequency = minDisplayFreq + normalizedX * (maxDisplayFreq - minDisplayFreq);
            }
            
            const freqInfoElement = document.getElementById('freqInfo');
            if (freqInfoElement) {
                freqInfoElement.textContent = 
                    `Frequenz: ${frequency.toFixed(1)} Hz bei Position ${(normalizedX * 100).toFixed(1)}%`;
            }
        }

        function initAudioContext() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                gainNode.gain.value = 0.3 * 0.3;
                
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                
                gainNode.connect(analyser);
                analyser.connect(audioContext.destination);
                
                if (analyser) {
                    analyser.smoothingTimeConstant = spectrumSmoothing;
                }
            } catch (error) {
                console.error("Failed to initialize audio context:", error);
            }
        }

        function playAudio() {
            if (!audioContext) {
                initAudioContext();
            }

            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            stopAudio();

            const frequencies = getCurrentFrequencies();
            const volume = document.getElementById('masterVolume').value / 100 * 0.3;

            frequencies.forEach(freq => {
                const oscillator = audioContext.createOscillator();
                const oscGain = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                
                oscGain.gain.setValueAtTime(volume / frequencies.length, audioContext.currentTime);
                
                oscillator.connect(oscGain);
                oscGain.connect(gainNode);
                
                oscillator.start();
                oscillators.push(oscillator);
            });

            document.getElementById('audioStatus').className = 'status-indicator status-playing';
            document.getElementById('statusText').textContent = `Spielt ${frequencies.length} Frequenz(en)`;

            drawSpectrum();
        }

        function stopAudio() {
            oscillators.forEach(osc => {
                try {
                    osc.stop();
                    osc.disconnect();
                } catch (e) {
                    // Oszillator bereits gestoppt
                }
            });
            oscillators = [];

            document.getElementById('audioStatus').className = 'status-indicator status-stopped';
            document.getElementById('statusText').textContent = 'Audio gestoppt';

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function drawSpectrum() {
            if (!analyser || !spectrumCanvas || !spectrumCtx) {
                return;
            }

            const canvas = spectrumCanvas;
            const ctx = spectrumCtx;
            
            const rect = canvas.getBoundingClientRect();
            const width = canvas.width = rect.width;
            const height = canvas.height = rect.height;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            analyser.getByteFrequencyData(dataArray);

            ctx.fillStyle = 'rgba(20, 30, 40, 0.2)';
            ctx.fillRect(0, 0, width, height);

            const frequencies = getCurrentFrequencies();
            const nyquist = audioContext ? audioContext.sampleRate / 2 : 22050;
            
            let detectedPeaks = [];
            
            for (let i = 1; i < bufferLength - 1; i++) {
                const frequency = (i / bufferLength) * nyquist;
                
                if (frequency < minDisplayFreq || frequency > maxDisplayFreq) continue;
                
                let x;
                if (spectrumScale === 'log' && minDisplayFreq > 0) {
                    const logMin = Math.log10(Math.max(1, minDisplayFreq));
                    const logMax = Math.log10(maxDisplayFreq);
                    const logFreq = Math.log10(Math.max(1, frequency));
                    x = ((logFreq - logMin) / (logMax - logMin)) * width;
                } else {
                    x = ((frequency - minDisplayFreq) / (maxDisplayFreq - minDisplayFreq)) * width;
                }
                
                const magnitude = Math.min(255, dataArray[i] * spectrumGain);
                const barHeight = (magnitude / 255) * height * 0.85;
                
                if (magnitude > peakThreshold) {
                    if (dataArray[i] > dataArray[i-1] && dataArray[i] > dataArray[i+1]) {
                        detectedPeaks.push({ 
                            frequency: frequency, 
                            magnitude: magnitude, 
                            x: x,
                            binIndex: i
                        });
                    }
                }
                
                if (magnitude > 0) {
                    let hue;
                    if (spectrumScale === 'log' && minDisplayFreq > 0) {
                        const logRange = Math.log10(maxDisplayFreq) - Math.log10(Math.max(1, minDisplayFreq));
                        const logPos = (Math.log10(Math.max(1, frequency)) - Math.log10(Math.max(1, minDisplayFreq))) / logRange;
                        hue = 240 + logPos * 120;
                    } else {
                        const pos = (frequency - minDisplayFreq) / (maxDisplayFreq - minDisplayFreq);
                        hue = 240 + pos * 120;
                    }
                    
                    const intensity = magnitude / 255;
                    const saturation = 60 + intensity * 40;
                    const lightness = 20 + intensity * 60;
                    const alpha = 0.6 + intensity * 0.4;
                    
                    ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                    
                    const barWidth = Math.max(1, width / (bufferLength * 0.5));
                    ctx.fillRect(x - barWidth/2, height - barHeight, barWidth, barHeight);
                }
            }

            // Generator-Frequenz-Marker zeichnen
            ctx.lineWidth = 3;
            frequencies.forEach((freq, index) => {
                if (freq < minDisplayFreq || freq > maxDisplayFreq) return;
                
                let x;
                if (spectrumScale === 'log' && minDisplayFreq > 0) {
                    const logMin = Math.log10(Math.max(1, minDisplayFreq));
                    const logMax = Math.log10(maxDisplayFreq);
                    const logFreq = Math.log10(freq);
                    x = ((logFreq - logMin) / (logMax - logMin)) * width;
                } else {
                    x = ((freq - minDisplayFreq) / (maxDisplayFreq - minDisplayFreq)) * width;
                }
                
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#ffd700');
                gradient.addColorStop(0.5, '#ff8c00');
                gradient.addColorStop(1, '#ff4500');
                
                ctx.strokeStyle = gradient;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
                ctx.setLineDash([]);
                
                const labelWidth = 70;
                const labelHeight = 20;
                const labelY = 5 + index * 25;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(Math.max(0, Math.min(width - labelWidth, x - labelWidth/2)), labelY, labelWidth, labelHeight);
                
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 1;
                ctx.strokeRect(Math.max(0, Math.min(width - labelWidth, x - labelWidth/2)), labelY, labelWidth, labelHeight);
                
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${freq.toFixed(1)}Hz`, Math.max(labelWidth/2, Math.min(width - labelWidth/2, x)), labelY + 14);
            });

            const peakCountElement = document.getElementById('peakCount');
            if (peakCountElement) {
                peakCountElement.textContent = detectedPeaks.length;
            }

            animationId = requestAnimationFrame(drawSpectrum);
        }

        function getCurrentFrequencies() {
            const frequencies = [];
            let i = 0;
            while (document.getElementById(`freq${i}`)) {
                const freq = parseFloat(document.getElementById(`freq${i}`).value);
                if (!isNaN(freq) && freq > 0) {
                    frequencies.push(freq);
                }
                i++;
            }
            return frequencies;
        }

        function analyzeHarmonics() {
            console.log("🔬 Analyze button clicked - starting analysis");
            
            const frequencies = getCurrentFrequencies();
            console.log("Frequencies found:", frequencies);
            
            const toleranceCents = parseFloat(document.getElementById('toleranceCents').value);
            const analysisMode = document.getElementById('analysisMode').value;
            const eulerFilter = document.getElementById('eulerComplexity').value;
            
            console.log("Settings:", {toleranceCents, analysisMode, eulerFilter});
            
            if (frequencies.length < 2) {
                console.log("Not enough frequencies for analysis");
                document.getElementById('analysisResults').innerHTML = `
                    <div class="result-block error">
                        ⚠️ Mindestens 2 Frequenzen benötigt für Harmonik-Analyse
                    </div>
                `;
                return;
            }

            analysisLog = [];
            const timestamp = new Date().toISOString();

            let results = `
                <div class="analysis-header">
                    🔬 RATIONALE HARMONIK-ANALYSE [${new Date().toLocaleTimeString('de-DE')}]
                </div>
                <div class="measurement-block">
                    INPUT: ${frequencies.length} Frequenzen | ξ=${toleranceCents}¢ | Modus=${analysisMode} | Euler=${eulerFilter}
                </div>
            `;

            let totalPairs = 0;
            let acceptedPairs = 0;

            console.log("Starting pair analysis...");

            for (let i = 0; i < frequencies.length; i++) {
                for (let j = i + 1; j < frequencies.length; j++) {
                    const f1 = frequencies[i];
                    const f2 = frequencies[j];
                    
                    console.log(`Analyzing pair: ${f1}Hz -> ${f2}Hz`);
                    
                    try {
                        const analysis = performRationalAnalysis(f1, f2, toleranceCents, eulerFilter);
                        
                        if (analysis) {
                            totalPairs++;
                            if (analysis.accepted) acceptedPairs++;
                            
                            console.log("Analysis result:", analysis);
                            
                            results += formatDetailedAnalysisResult(analysis, analysisMode);
                            
                            analysisLog.push({
                                timestamp,
                                f1: f1.toFixed(2),
                                f2: f2.toFixed(2),
                                floatingRatio: analysis.floatingRatio.toFixed(4),
                                rationalRatio: analysis.rationalRatio.toString(),
                                reducedRatio: analysis.reducedRatio.toString(),
                                intervalName: analysis.interval.name,
                                intervalRatio: analysis.interval.ratio.toString(),
                                eulerGradus: analysis.interval.eulerGradus,
                                category: analysis.interval.category,
                                centsDeviation: analysis.centsDeviation.toFixed(1),
                                confidence: analysis.confidence.toFixed(3),
                                accepted: analysis.accepted,
                                toleranceCents,
                                analysisMode,
                                eulerFilter
                            });
                        } else {
                            console.log("No analysis result for this pair");
                        }
                    } catch (error) {
                        console.error("Error analyzing pair:", error);
                        results += `
                            <div class="result-block error">
                                ERROR analyzing ${f1}Hz -> ${f2}Hz: ${error.message}
                            </div>
                        `;
                    }
                }
            }

            console.log(`Analysis complete: ${acceptedPairs}/${totalPairs} pairs accepted`);

            const successRate = totalPairs > 0 ? (acceptedPairs / totalPairs * 100).toFixed(1) : 0;
            results += `
                <div class="calculation-block">
                    STATISTIK: ${acceptedPairs}/${totalPairs} Paare akzeptiert (${successRate}% Erfolgsquote)
                </div>
            `;

            results += `
                <div class="analysis-header">
                    🌊 OKTAV-REDUKTION VERGLEICH
                </div>
            `;

            frequencies.forEach((freq, index) => {
                try {
                    const ratio = approximateRational(freq / frequencies[0], 100);
                    const reduced = ratio.reduceToOctave();
                    const originalFloat = ratio.toFloat();
                    const reducedFloat = reduced.toFloat();
                    const octaveShifts = Math.floor(Math.log2(originalFloat));
                    
                    results += `
                        <div class="calculation-block">
                            F${index + 1}=${freq}Hz: Original=${ratio}(${originalFloat.toFixed(3)}) → Reduziert=${reduced}(${reducedFloat.toFixed(3)}) | Oktav-Shifts=${octaveShifts}
                        </div>
                    `;
                } catch (error) {
                    console.error("Error in octave reduction for freq", freq, error);
                    results += `
                        <div class="calculation-block">
                            F${index + 1}=${freq}Hz: Error in octave reduction
                        </div>
                    `;
                }
            });

            if (analysisMode === 'both') {
                results += `
                    <div class="analysis-header">
                        ⚖️ GENAUIGKEITS-VERGLEICH: RATIONAL vs FLOATING-POINT
                    </div>
                `;
                
                for (let i = 0; i < frequencies.length; i++) {
                    for (let j = i + 1; j < frequencies.length; j++) {
                        const f1 = frequencies[i];
                        const f2 = frequencies[j];
                        const floatRatio = f2 / f1;
                        const rationalRatio = approximateRational(floatRatio, 1000);
                        const precisionDiff = Math.abs(floatRatio - rationalRatio.toFloat());
                        
                        results += `
                            <div class="calculation-block">
                                ${f1.toFixed(1)}→${f2.toFixed(1)}Hz: Float=${floatRatio.toFixed(6)} vs Rational=${rationalRatio.toFloat().toFixed(6)} | Δ=${precisionDiff.toExponential(2)}
                            </div>
                        `;
                    }
                }
            }

            results += `
                <div class="analysis-header">
                    📊 ERWEITERTE MATHEMATISCHE ANALYSE
                </div>
            `;

            try {
                // Verbesserte GCD-Berechnung für musikalische Analyse
                const gcdResult = calculateMusicalGCD(frequencies);
                
                results += `
                    <div class="calculation-block">
                        MUSIKALISCHER GCD: ${gcdResult.fundamentalFreq.toFixed(2)}Hz | Einfachste Basis: ${gcdResult.simplestBase.toFixed(2)}Hz
                    </div>
                `;

                frequencies.forEach((freq, index) => {
                    const harmonicNumber = Math.round(freq / gcdResult.fundamentalFreq);
                    const exactHarmonic = gcdResult.fundamentalFreq * harmonicNumber;
                    const harmonicDeviation = Math.abs(freq - exactHarmonic);
                    const harmonicDeviation_cents = exactHarmonic > 0 ? 1200 * Math.log2(freq / exactHarmonic) : 0;
                    
                    // Rationale Näherung zur Basis
                    const rationalToBase = approximateRational(freq / gcdResult.simplestBase, 100);
                    
                    results += `
                        <div class="calculation-block">
                            F${index + 1}=${freq}Hz: ${harmonicNumber}.Harm(${exactHarmonic.toFixed(1)}Hz) | Δ=${harmonicDeviation.toFixed(2)}Hz(${harmonicDeviation_cents.toFixed(1)}¢) | Ratio=${rationalToBase}
                        </div>
                    `;
                });
            } catch (error) {
                console.error("Error in mathematical analysis:", error);
                results += `
                    <div class="calculation-block">
                        Fehler in der mathematischen Analyse: ${error.message}
                    </div>
                `;
            }

            console.log("Setting results HTML...");
            document.getElementById('analysisResults').innerHTML = results;
            console.log("Analysis complete!");
        }

        function performRationalAnalysis(f1, f2, toleranceCents, eulerFilter) {
            // Verwende rationale Approximation mit begrenzter Komplexität
            const floatRatio = f2 / f1;
            const approximatedRational = approximateRational(floatRatio, 1000); // Max Denominator 1000
            const reducedRatio = approximatedRational.reduceToOctave();
            
            const interval = findClosestInterval(floatRatio);
            if (!interval) return null;
            
            if (eulerFilter !== 'all') {
                const maxGradus = {
                    perfect: 3,
                    consonant: 4,
                    simple: 6
                }[eulerFilter];
                
                if (interval.eulerGradus > maxGradus) return null;
            }
            
            // Cents-Abweichung berechnen
            const centsDeviation = Math.abs(1200 * Math.log2(floatRatio / interval.ratio.toFloat()));
            const confidence = Math.exp(-centsDeviation * centsDeviation / (4 * toleranceCents));
            
            return {
                f1, f2,
                floatingRatio: floatRatio,
                rationalRatio: approximatedRational,
                reducedRatio,
                interval,
                centsDeviation,
                confidence,
                accepted: centsDeviation <= toleranceCents
            };
        }

        // Rationale Approximation mit Continued Fractions (Kettenbrüche)
        function approximateRational(decimal, maxDenominator = 1000) {
            if (decimal === 0) return new RationalNumber(0, 1);
            
            let sign = decimal < 0 ? -1 : 1;
            decimal = Math.abs(decimal);
            
            let wholePart = Math.floor(decimal);
            let fractionalPart = decimal - wholePart;
            
            if (fractionalPart === 0) {
                return new RationalNumber(sign * wholePart, 1);
            }
            
            // Continued fraction method
            let h1 = 1, k1 = 0;
            let h0 = wholePart, k0 = 1;
            
            let x = fractionalPart;
            while (k0 <= maxDenominator && x !== 0) {
                let a = Math.floor(1 / x);
                let h2 = a * h0 + h1;
                let k2 = a * k0 + k1;
                
                if (k2 > maxDenominator) break;
                
                h1 = h0; k1 = k0;
                h0 = h2; k0 = k2;
                
                x = 1 / x - a;
                if (Math.abs(x) < 1e-10) break;
            }
            
            return new RationalNumber(sign * h0, k0);
        }

        function findClosestInterval(ratio) {
            let bestMatch = null;
            let minDeviation = Infinity;
            
            for (const interval of justIntervals) {
                const intervalRatio = interval.ratio.toFloat();
                const deviation = Math.abs(Math.log2(ratio / intervalRatio));
                
                if (deviation < minDeviation) {
                    minDeviation = deviation;
                    bestMatch = interval;
                }
            }
            
            return bestMatch;
        }

        function calculateCentsDeviation(actualRatio, targetRatio) {
            return Math.abs(1200 * Math.log2(actualRatio / targetRatio));
        }

        // Schwebungs-Erkennung und -Analyse
        function analyzeBeating(f1, f2) {
            const freqDiff = Math.abs(f2 - f1);
            const avgFreq = (f1 + f2) / 2;
            const beatFreq = freqDiff;
            const beatPeriod = beatFreq > 0 ? 1 / beatFreq : 0;
            
            // Klassifiziere Schwebungstyp
            let beatingType = "Keine";
            let beatingIntensity = "Schwach";
            
            if (freqDiff < 0.1) {
                beatingType = "Keine (Unison)";
            } else if (freqDiff <= 1) {
                beatingType = "Sehr langsame Schwebung";
                beatingIntensity = "Sehr schwach";
            } else if (freqDiff <= 5) {
                beatingType = "Langsame Schwebung";
                beatingIntensity = "Schwach";
            } else if (freqDiff <= 15) {
                beatingType = "Mittlere Schwebung";
                beatingIntensity = "Mittel";
            } else if (freqDiff <= 30) {
                beatingType = "Schnelle Schwebung";
                beatingIntensity = "Stark";
            } else if (freqDiff <= 50) {
                beatingType = "Sehr schnelle Schwebung";
                beatingIntensity = "Sehr stark";
            } else {
                beatingType = "Rauigkeit (zu schnell für Schwebung)";
                beatingIntensity = "Dissonant";
            }
            
            // Musikalische Bewertung der Schwebung
            let musicalEffect = "";
            if (freqDiff < 0.5) {
                musicalEffect = "Perfekte Stimmung";
            } else if (freqDiff <= 2) {
                musicalEffect = "Leichte Verstimmung, noch angenehm";
            } else if (freqDiff <= 6) {
                musicalEffect = "Deutliche Schwebung, expressiv";
            } else if (freqDiff <= 20) {
                musicalEffect = "Starke Schwebung, unruhig";
            } else {
                musicalEffect = "Dissonant, unangenehm";
            }
            
            return {
                beatFrequency: beatFreq,
                beatPeriod: beatPeriod,
                beatingType: beatingType,
                beatingIntensity: beatingIntensity,
                musicalEffect: musicalEffect,
                frequencyDifference: freqDiff,
                averageFrequency: avgFreq
            };
        }

        function formatDetailedAnalysisResult(analysis, mode) {
            const status = analysis.accepted ? '✅' : '❌';
            const gradusStars = '★'.repeat(Math.max(1, 6 - analysis.interval.eulerGradus));
            const confidenceColor = analysis.confidence > 0.8 ? 'success' : analysis.confidence > 0.5 ? 'warning' : 'error';
            
            // Zusätzliche Harmonik-Info
            const harmonicSeriesInfo = getHarmonicSeriesInfo(analysis.floatingRatio);
            const complexityScore = getComplexityScore(analysis.rationalRatio);
            
            // Schwebungs-Analyse hinzufügen
            const beatingAnalysis = analyzeBeating(analysis.f1, analysis.f2);
            
            let result = `
                <div class="measurement-block ${analysis.accepted ? 'success' : 'error'}">
                    ${status} MESSUNG: ${analysis.f1.toFixed(1)}Hz → ${analysis.f2.toFixed(1)}Hz | Harmonik: ${harmonicSeriesInfo}
                </div>
                <div class="calculation-block">
                    VERHÄLTNISSE: Float=${analysis.floatingRatio.toFixed(4)} | Rational=${analysis.rationalRatio} | Oktav-Red=${analysis.reducedRatio} | Komplexität=${complexityScore}
                </div>
                <div class="calculation-block">
                    INTERVALL: ${analysis.interval.name} (${analysis.interval.ratio}) | Euler-Gradus=${analysis.interval.eulerGradus}${gradusStars} | Kategorie=${analysis.interval.category}
                </div>
            `;
            
            // Schwebungs-Information hinzufügen
            if (beatingAnalysis.frequencyDifference > 0.1) {
                result += `
                    <div class="calculation-block">
                        SCHWEBUNG: ${beatingAnalysis.beatFrequency.toFixed(2)}Hz (${beatingAnalysis.beatPeriod.toFixed(2)}s Periode) | Typ: ${beatingAnalysis.beatingType} | Intensität: ${beatingAnalysis.beatingIntensity}
                    </div>
                    <div class="calculation-block">
                        MUSIKALISCHE WIRKUNG: ${beatingAnalysis.musicalEffect} | Frequenz-Differenz: ${beatingAnalysis.frequencyDifference.toFixed(2)}Hz
                    </div>
                `;
            }
            
            result += `
                <div class="result-block ${confidenceColor}">
                    RESULTAT: Abweichung=${analysis.centsDeviation.toFixed(1)}¢ | Confidence=${analysis.confidence.toFixed(3)} | Status=${analysis.accepted ? 'AKZEPTIERT' : 'VERWORFEN'}
                </div>
            `;
            
            return result;
        }

        function findClosestInterval(ratio) {
            let bestMatch = null;
            let minDeviation = Infinity;
            
            for (const interval of justIntervals) {
                const intervalRatio = interval.ratio.toFloat();
                const deviation = Math.abs(Math.log2(ratio / intervalRatio));
                
                if (deviation < minDeviation) {
                    minDeviation = deviation;
                    bestMatch = interval;
                }
            }
            
            return bestMatch;
        }

        // Verbesserte musikalische GCD-Berechnung
        function calculateMusicalGCD(frequencies) {
            // Finde den kleinsten sinnvollen musikalischen Grundton
            const minFreq = Math.min(...frequencies);
            const maxFreq = Math.max(...frequencies);
            
            let bestFundamental = minFreq;
            let bestScore = 0;
            let bestDeviations = [];
            
            // Teste verschiedene potentielle Grundtöne
            for (let testFund = minFreq / 16; testFund <= minFreq / 2; testFund += 0.1) {
                let score = 0;
                let deviations = [];
                
                for (const freq of frequencies) {
                    const harmonicNumber = Math.round(freq / testFund);
                    if (harmonicNumber < 1 || harmonicNumber > 32) continue; // Nur sinnvolle Harmonische
                    
                    const exactHarmonic = testFund * harmonicNumber;
                    const deviation = Math.abs(freq - exactHarmonic);
                    const deviation_cents = Math.abs(1200 * Math.log2(freq / exactHarmonic));
                    
                    // Bewerte basierend auf Cents-Abweichung (unter 10 Cents ist sehr gut)
                    if (deviation_cents < 10) score += 3;
                    else if (deviation_cents < 20) score += 2;
                    else if (deviation_cents < 50) score += 1;
                    
                    deviations.push(deviation_cents);
                }
                
                if (score > bestScore) {
                    bestScore = score;
                    bestFundamental = testFund;
                    bestDeviations = deviations;
                }
            }
            
            // Finde auch die einfachste rationale Basis
            let simplestBase = frequencies[0];
            let smallestDenominator = Infinity;
            
            for (const freq of frequencies) {
                for (const other of frequencies) {
                    if (freq === other) continue;
                    const ratio = approximateRational(freq / other, 20); // Sehr einfache Verhältnisse
                    if (ratio.denominator < smallestDenominator) {
                        smallestDenominator = ratio.denominator;
                        simplestBase = other;
                    }
                }
            }
            
            return {
                fundamentalFreq: bestFundamental,
                simplestBase: simplestBase,
                score: bestScore,
                avgDeviation: bestDeviations.reduce((a, b) => a + b, 0) / bestDeviations.length
            };
        }

        // Harmonische Reihen-Information
        function getHarmonicSeriesInfo(ratio) {
            // Prüfe auf einfache harmonische Verhältnisse
            const simpleRatios = [
                {ratio: 1, name: "1:1 Unison"},
                {ratio: 2, name: "2:1 Oktave"},
                {ratio: 3/2, name: "3:2 Quinte"},
                {ratio: 4/3, name: "4:3 Quarte"},
                {ratio: 5/4, name: "5:4 Gr.Terz"},
                {ratio: 6/5, name: "6:5 Kl.Terz"},
                {ratio: 9/8, name: "9:8 Ganzton"},
                {ratio: 16/15, name: "16:15 Halbton"}
            ];
            
            for (const simple of simpleRatios) {
                const deviation = Math.abs(1200 * Math.log2(ratio / simple.ratio));
                if (deviation < 10) {
                    return simple.name;
                }
            }
            
            // Prüfe auf komplexere harmonische Verhältnisse
            for (let n = 1; n <= 16; n++) {
                for (let m = n + 1; m <= 16; m++) {
                    const testRatio = m / n;
                    const deviation = Math.abs(1200 * Math.log2(ratio / testRatio));
                    if (deviation < 5) {
                        return `${m}:${n} Harmonisch`;
                    }
                }
            }
            
            return "Komplex";
        }

        // Komplexitäts-Score für rationale Zahlen
        function getComplexityScore(rational) {
            const complexity = rational.numerator + rational.denominator;
            if (complexity <= 10) return "Einfach";
            else if (complexity <= 30) return "Mittel";
            else if (complexity <= 100) return "Komplex";
            else return "Sehr Komplex";
        }

        // Log-Management Funktionen
        function saveLog() {
            const logContent = document.getElementById('analysisResults').innerText;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `harmonik-analyse-${timestamp}.txt`;
            
            const blob = new Blob([logContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert(`Log gespeichert als: ${filename}`);
        }

        function copyLog() {
            const logContent = document.getElementById('analysisResults').innerText;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(logContent).then(() => {
                    alert('Log in Zwischenablage kopiert!');
                }).catch(err => {
                    console.error('Clipboard API failed:', err);
                    fallbackCopyLog(logContent);
                });
            } else {
                fallbackCopyLog(logContent);
            }
        }

        function fallbackCopyLog(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                alert('Log in Zwischenablage kopiert!');
            } catch (err) {
                alert('Kopieren fehlgeschlagen. Bitte manuell markieren und kopieren.');
            }
            
            document.body.removeChild(textArea);
        }

        function clearLog() {
            if (confirm('Sind Sie sicher, dass Sie das Log löschen möchten?')) {
                analysisLog = [];
                document.getElementById('analysisResults').innerHTML = `
                    <div style="text-align: center; opacity: 0.6; padding: 40px;">
                        Log wurde gelöscht. Klicken Sie auf "Analysieren" um eine neue Analyse zu starten...
                    </div>
                `;
            }
        }

        function exportLogCSV() {
            if (analysisLog.length === 0) {
                alert('Keine Analysedaten zum Export verfügbar. Führen Sie zuerst eine Analyse durch.');
                return;
            }
            
            const headers = [
                'Timestamp', 'F1_Hz', 'F2_Hz', 'Float_Ratio', 'Rational_Ratio', 'Reduced_Ratio',
                'Interval_Name', 'Interval_Ratio', 'Euler_Gradus', 'Category', 'Cents_Deviation',
                'Confidence', 'Accepted', 'Tolerance_Cents', 'Analysis_Mode', 'Euler_Filter'
            ];
            
            let csvContent = headers.join(',') + '\n';
            
            analysisLog.forEach(entry => {
                const row = [
                    entry.timestamp,
                    entry.f1,
                    entry.f2,
                    entry.floatingRatio,
                    `"${entry.rationalRatio}"`,
                    `"${entry.reducedRatio}"`,
                    `"${entry.intervalName}"`,
                    `"${entry.intervalRatio}"`,
                    entry.eulerGradus,
                    entry.category,
                    entry.centsDeviation,
                    entry.confidence,
                    entry.accepted,
                    entry.toleranceCents,
                    entry.analysisMode,
                    entry.eulerFilter
                ];
                csvContent += row.join(',') + '\n';
            });
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `harmonik-analyse-data-${timestamp}.csv`;
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert(`CSV-Export gespeichert als: ${filename}\nEnthält ${analysisLog.length} Analyseergebnisse.`);
        }
    </script>
</body>
</html>