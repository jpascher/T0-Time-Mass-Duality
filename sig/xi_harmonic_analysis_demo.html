<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Œæ-FFT Harmonische Signal-Analyse Demo</title>
    <style>
        :root {
            --primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            --shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            --radius: 12px;
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: var(--background);
            min-height: 100vh;
            color: #333;
        }

        .header {
            background: var(--primary);
            color: white;
            padding: 20px 0;
            text-align: center;
            box-shadow: var(--shadow);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .xi-symbol {
            font-size: 3rem;
            font-weight: bold;
            margin-right: 15px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .panel {
            background: white;
            border-radius: var(--radius);
            padding: 20px;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .panel h2 {
            font-size: 1.4rem;
            margin-bottom: 15px;
            color: #444;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .form-control {
            width: 100%;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: var(--transition);
        }

        .form-control:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .range-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-control input[type="range"] {
            flex: 1;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }

        .range-value {
            min-width: 60px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .checkbox-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .results-panel {
            grid-column: 1 / -1;
            background: white;
            border-radius: var(--radius);
            padding: 20px;
            box-shadow: var(--shadow);
        }

        .status-box {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 500;
            transition: var(--transition);
        }

        .status-info {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            color: #1565c0;
            border-left: 4px solid #2196f3;
        }

        .status-success {
            background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c8 100%);
            color: #2e7d32;
            border-left: 4px solid #4caf50;
        }

        .status-warning {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            color: #ef6c00;
            border-left: 4px solid #ff9800;
        }

        .status-error {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            color: #c62828;
            border-left: 4px solid #f44336;
        }

        .progress-container {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            height: 100%;
            background: var(--success);
            width: 0%;
            transition: width 0.3s ease;
        }

        .chart-container {
            margin: 20px 0;
            text-align: center;
        }

        .chart-canvas {
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
        }

        .text-output {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .btn-group {
                flex-direction: column;
            }
        }

        /* Button Click Animation */
        @keyframes ripple {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(4);
                opacity: 0;
            }
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>
            <span class="xi-symbol">Œæ</span>
            Harmonische Signal-Analyse
        </h1>
        <p>T0-Prinzip f√ºr Signale ‚Ä¢ Direkte Periodensuche ohne FFT ‚Ä¢ Logarithmische Harmonik</p>
    </div>

    <div class="container">
        <!-- Signal Generator Panel -->
        <div class="panel">
            <h2>üéµ Signal-Generator</h2>
            
            <div class="form-group">
                <label for="signalType">Signal-Typ:</label>
                <select id="signalType" class="form-control">
                    <option value="harmonic">Harmonische Reihe</option>
                    <option value="beating">Schwebungs-Signal</option>
                    <option value="chord">Dur-Akkord</option>
                    <option value="complex">Komplexes Signal</option>
                    <option value="noisy">Signal + Rauschen</option>
                </select>
            </div>

            <div class="form-group">
                <label for="frequency">Grundfrequenz f‚ÇÄ (Hz):</label>
                <input type="number" id="frequency" class="form-control" min="50" max="500" value="220" step="10">
            </div>

            <div class="form-group">
                <label for="duration">Signal-Dauer (s):</label>
                <input type="number" id="duration" class="form-control" min="1" max="5" value="2" step="0.5">
            </div>

            <div class="form-group">
                <label>Rausch-Level:</label>
                <div class="range-control">
                    <input type="range" id="noiseLevel" min="0" max="0.5" value="0.1" step="0.01">
                    <span class="range-value" id="noiseLevelValue">0.1</span>
                </div>
            </div>

            <div class="btn-group">
                <button class="btn btn-primary" onclick="generateSignal()">
                    üéµ Signal Generieren
                </button>
                <button class="btn btn-secondary" onclick="saveSignal()">
                    üíæ Signal Speichern
                </button>
            </div>

            <div class="btn-group">
                <button class="btn btn-success" onclick="playSignal()">
                    ‚ñ∂Ô∏è Signal Abspielen
                </button>
                <button class="btn btn-success" onclick="exportWAV()">
                    üéµ Als WAV
                </button>
            </div>

            <div class="form-group">
                <label for="fileInput">Datei laden:</label>
                <input type="file" id="fileInput" class="form-control" accept=".wav,.json,.csv" onchange="loadFile(event)">
            </div>
        </div>

        <!-- Harmonic Configuration Panel -->
        <div class="panel">
            <h2>‚öôÔ∏è Harmonische Konfiguration</h2>
            
            <div class="form-group">
                <label for="xiProfile">Œæ-Profil:</label>
                <select id="xiProfile" class="form-control">
                    <option value="universal">Universal (1/100)</option>
                    <option value="harmonic">Harmonisch (1/50)</option>
                    <option value="complex">Komplex (1/1000)</option>
                    <option value="microtonal">Mikrotonal (1/42)</option>
                </select>
            </div>

            <div class="form-group">
                <label>Periodizit√§ts-Threshold:</label>
                <div class="range-control">
                    <input type="range" id="periodThreshold" min="0.1" max="0.9" value="0.3" step="0.1">
                    <span class="range-value" id="periodThresholdValue">0.3</span>
                </div>
            </div>

            <div class="form-group">
                <label>Œæ-Threshold:</label>
                <div class="range-control">
                    <input type="range" id="xiThreshold" min="0.001" max="0.1" value="0.01" step="0.001">
                    <span class="range-value" id="xiThresholdValue">0.01</span>
                </div>
            </div>

            <div class="form-group">
                <label>Aktive Harmonien:</label>
                <div class="checkbox-grid" id="harmonicCheckboxes">
                    <!-- Wird dynamisch gef√ºllt -->
                </div>
            </div>

            <div class="btn-group">
                <button class="btn btn-primary" onclick="analyzePureT0()">
                    üß† Basis Œæ-Analyse
                </button>
                <button class="btn btn-secondary" onclick="compareFFT()">
                    üìä Mit FFT Vergleichen
                </button>
            </div>

            <div class="btn-group">
                <button class="btn btn-success" onclick="analyzeResonance()">
                    üéº Resonanz-Analyse
                </button>
                <button class="btn btn-success" onclick="analyzeMicrotonal()">
                    üéµ Mikro-Tonalit√§t
                </button>
            </div>

            <div class="btn-group">
                <button class="btn btn-secondary" onclick="testCanvas()">
                    üß™ Test Canvas
                </button>
            </div>
        </div>
    </div>

    <!-- Results Panel -->
    <div class="results-panel">
        <h2>üìä Analyse-Ergebnisse</h2>
        
        <div id="statusBox" class="status-box status-info">
            üéº Bereit f√ºr Œæ-harmonische Signal-Analyse
        </div>

        <div class="progress-container">
            <div id="progressBar" class="progress-bar"></div>
        </div>

        <div class="chart-container">
            <canvas id="signalChart" class="chart-canvas" width="800" height="200"></canvas>
        </div>

        <div class="chart-container">
            <canvas id="analysisChart" class="chart-canvas" width="800" height="300"></canvas>
        </div>

        <div class="text-output" id="textOutput">
üéº Œæ-FFT HARMONISCHE SIGNAL-ANALYSE DEMO

‚ú® NEUE FEATURES:
‚Ä¢ Konfigurierbare Harmonische Auswahl
‚Ä¢ Echtzeit Signal-Generierung
‚Ä¢ Visuelle Button-R√ºckmeldung
‚Ä¢ T0-basierte Periodensuche
‚Ä¢ Harmonische Resonanz-Analyse
‚Ä¢ Mikro-tonale Pr√§zision

üöÄ BEREIT F√úR ANALYSE:
1. W√§hlen Sie Signal-Typ und Parameter
2. Klicken Sie "Signal Generieren"
3. Starten Sie gew√ºnschte Analyse
4. Betrachten Sie Ergebnisse in Echtzeit

Alle Buttons geben sofortiges visuelles Feedback!
        </div>
    </div>

    <script>
        // =================================================================
        // GLOBALE VARIABLEN
        // =================================================================
        let currentSignal = null;
        let currentAnalysis = null;
        let sampleRate = 44100;
        let audioContext = null;

        const xiProfiles = {
            universal: { factor: 100, name: 'Universal' },
            harmonic: { factor: 50, name: 'Harmonisch' },
            complex: { factor: 1000, name: 'Komplex' },
            microtonal: { factor: 42, name: 'Mikrotonal' }
        };

        const harmonicIntervals = {
            unison: { ratio: 1.0, name: 'Unison', category: 'Perfect' },
            octave: { ratio: 2.0, name: 'Oktave', category: 'Perfect' },
            fifth: { ratio: 1.5, name: 'Quinte', category: 'Perfect' },
            fourth: { ratio: 4/3, name: 'Quarte', category: 'Perfect' },
            majorThird: { ratio: 1.25, name: 'Gro√üe Terz', category: 'Consonant' },
            minorThird: { ratio: 1.2, name: 'Kleine Terz', category: 'Consonant' },
            majorSixth: { ratio: 5/3, name: 'Gro√üe Sexte', category: 'Consonant' },
            minorSixth: { ratio: 1.6, name: 'Kleine Sexte', category: 'Consonant' },
            majorSecond: { ratio: 9/8, name: 'Gro√üer Ganzton', category: 'Dissonant' },
            minorSeventh: { ratio: 16/9, name: 'Kleine Septime', category: 'Dissonant' }
        };

        // =================================================================
        // UTILITY FUNKTIONEN
        // =================================================================
        
        function updateStatus(message, type = 'info') {
            const statusBox = document.getElementById('statusBox');
            if (statusBox) {
                statusBox.textContent = message;
                statusBox.className = `status-box status-${type}`;
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
        }

        function updateProgress(percentage) {
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
            }
        }

        function addButtonFeedback() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('btn')) {
                    // Visueller Ripple-Effekt ist bereits im CSS
                    console.log(`Button geklickt: ${e.target.textContent.trim()}`);
                }
            });
        }

        // =================================================================
        // INITIALISIERUNG
        // =================================================================
        
        function initApp() {
            console.log('üéº Initialisiere Œæ-harmonische Analyse App...');
            
            try {
                // Audio Context
                if (typeof AudioContext !== 'undefined') {
                    audioContext = new AudioContext();
                } else if (typeof webkitAudioContext !== 'undefined') {
                    audioContext = new webkitAudioContext();
                }

                // Range Sliders
                setupRangeSliders();
                
                // Harmonische Checkboxes
                setupHarmonicCheckboxes();
                
                // Button Feedback
                addButtonFeedback();
                
                updateStatus('üéº Œæ-harmonische Analyse bereit - W√§hlen Sie Signal-Typ und Parameter', 'info');
                console.log('‚úÖ App erfolgreich initialisiert');
                
            } catch (error) {
                console.error('Initialisierungsfehler:', error);
                updateStatus('‚ùå Initialisierung fehlgeschlagen: ' + error.message, 'error');
            }
        }

        function setupRangeSliders() {
            const sliders = [
                { id: 'noiseLevel', valueId: 'noiseLevelValue' },
                { id: 'periodThreshold', valueId: 'periodThresholdValue' },
                { id: 'xiThreshold', valueId: 'xiThresholdValue' }
            ];

            sliders.forEach(slider => {
                const input = document.getElementById(slider.id);
                const display = document.getElementById(slider.valueId);
                
                if (input && display) {
                    input.addEventListener('input', function() {
                        display.textContent = this.value;
                    });
                }
            });
        }

        function setupHarmonicCheckboxes() {
            const container = document.getElementById('harmonicCheckboxes');
            if (!container) return;
            
            container.innerHTML = '';
            
            Object.entries(harmonicIntervals).forEach(([key, interval]) => {
                const div = document.createElement('div');
                div.className = 'checkbox-item';
                div.innerHTML = `
                    <input type="checkbox" id="harmonic_${key}" checked>
                    <label for="harmonic_${key}">${interval.name}</label>
                `;
                container.appendChild(div);
            });
        }

        // =================================================================
        // SIGNAL-GENERIERUNG
        // =================================================================
        
        function generateSignal() {
            const signalType = document.getElementById('signalType').value;
            const frequency = parseFloat(document.getElementById('frequency').value);
            const duration = parseFloat(document.getElementById('duration').value);
            
            updateStatus(`üéµ Generiere ${signalType} Signal...`, 'info');
            updateProgress(25);

            try {
                let signal;
                
                switch (signalType) {
                    case 'harmonic':
                        signal = createHarmonicSeries(frequency, duration);
                        break;
                    case 'beating':
                        signal = createBeatingSignal(frequency, duration);
                        break;
                    case 'chord':
                        signal = createChordSignal(frequency, duration);
                        break;
                    case 'complex':
                        signal = createComplexSignal(frequency, duration);
                        break;
                    case 'noisy':
                        signal = createNoisySignal(frequency, duration);
                        break;
                    default:
                        signal = createHarmonicSeries(frequency, duration);
                }

                currentSignal = signal;
                updateProgress(75);
                
                // Visualisierung
                plotSignal(signal);
                updateProgress(100);
                
                updateStatus(`‚úÖ Signal generiert: ${signal.length} Samples (${duration}s, ${frequency}Hz)`, 'success');
                
            } catch (error) {
                updateStatus(`‚ùå Signal-Generierung fehlgeschlagen: ${error.message}`, 'error');
                console.error('Signal generation error:', error);
            }
        }

        function createHarmonicSeries(f0, duration) {
            const samples = Math.floor(duration * sampleRate);
            const signal = new Float32Array(samples);
            
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;
                signal[i] = 0.5 * Math.sin(2 * Math.PI * f0 * t) +
                           0.25 * Math.sin(2 * Math.PI * f0 * 2 * t) +
                           0.125 * Math.sin(2 * Math.PI * f0 * 3 * t) +
                           0.0625 * Math.sin(2 * Math.PI * f0 * 4 * t) +
                           0.03125 * Math.sin(2 * Math.PI * f0 * 5 * t);
            }
            
            return signal;
        }

        function createBeatingSignal(f0, duration) {
            const samples = Math.floor(duration * sampleRate);
            const signal = new Float32Array(samples);
            const beatFreq = 3;
            
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;
                signal[i] = 0.5 * Math.sin(2 * Math.PI * (f0 - beatFreq/2) * t) +
                           0.5 * Math.sin(2 * Math.PI * (f0 + beatFreq/2) * t);
            }
            
            return signal;
        }

        function createChordSignal(f0, duration) {
            const samples = Math.floor(duration * sampleRate);
            const signal = new Float32Array(samples);
            
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;
                signal[i] = 0.33 * Math.sin(2 * Math.PI * f0 * t) +
                           0.33 * Math.sin(2 * Math.PI * f0 * 1.25 * t) +
                           0.33 * Math.sin(2 * Math.PI * f0 * 1.5 * t);
            }
            
            return signal;
        }

        function createComplexSignal(f0, duration) {
            const samples = Math.floor(duration * sampleRate);
            const signal = new Float32Array(samples);
            const frequencies = [f0, f0 * 1.1, f0 * 1.7, f0 * 2.3];
            
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;
                signal[i] = frequencies.reduce((sum, freq) => 
                    sum + 0.25 * Math.sin(2 * Math.PI * freq * t), 0);
            }
            
            return signal;
        }

        function createNoisySignal(f0, duration) {
            const samples = Math.floor(duration * sampleRate);
            const signal = new Float32Array(samples);
            const noiseLevel = parseFloat(document.getElementById('noiseLevel').value);
            
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;
                const harmonic = 0.7 * Math.sin(2 * Math.PI * f0 * t) +
                               0.3 * Math.sin(2 * Math.PI * f0 * 2 * t);
                const noise = (Math.random() - 0.5) * noiseLevel;
                signal[i] = harmonic + noise;
            }
            
            return signal;
        }

        // =================================================================
        // VISUALISIERUNG
        // =================================================================
        
        function plotSignal(signal) {
            const canvas = document.getElementById('signalChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const displaySamples = Math.min(signal.length, 2000);
            const step = Math.floor(signal.length / displaySamples);
            
            const width = canvas.width - 80;
            const height = canvas.height - 60;
            const xOffset = 40;
            const yOffset = 30;
            
            // Grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = yOffset + (i / 10) * height;
                ctx.beginPath();
                ctx.moveTo(xOffset, y);
                ctx.lineTo(xOffset + width, y);
                ctx.stroke();
            }
            
            // Signal
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < displaySamples; i++) {
                const sampleIndex = i * step;
                const x = xOffset + (i / displaySamples) * width;
                const y = yOffset + height/2 - (signal[sampleIndex] * height/4);
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('Zeit (s)', xOffset + width/2 - 20, canvas.height - 5);
            
            ctx.save();
            ctx.translate(15, yOffset + height/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Amplitude', 0, 0);
            ctx.restore();
        }

        // =================================================================
        // ANALYSE-FUNKTIONEN
        // =================================================================
        
        function analyzePureT0() {
            if (!currentSignal) {
                updateStatus('‚ö†Ô∏è Erst Signal generieren!', 'warning');
                return;
            }
            
            // Hole aktuelle Parameter
            const xiProfile = document.getElementById('xiProfile').value;
            const periodThreshold = parseFloat(document.getElementById('periodThreshold').value);
            const xiThreshold = parseFloat(document.getElementById('xiThreshold').value);
            
            updateStatus(`üß† Starte T0-Analyse mit ${xiProfiles[xiProfile].name} Profil...`, 'info');
            updateProgress(25);
            
            // Berechne Analyse basierend auf Parametern
            const analysisData = calculateT0Analysis(xiProfile, periodThreshold, xiThreshold);
            
            // Plotte mit echten Daten
            plotAnalysisChart('t0', analysisData);
            updateProgress(75);
            
            setTimeout(() => {
                updateProgress(100);
                updateStatus(`‚úÖ T0-Analyse: ${analysisData.periods.length} Perioden gefunden`, 'success');
                
                document.getElementById('textOutput').textContent = `
=== Œæ-T0 REINE ANALYSE BERICHT ===

üß† PERIODENSUCHE ERGEBNISSE:
   Gefundene Perioden: ${analysisData.periods.length}
   St√§rkste Periode: ${analysisData.strongestPeriod} samples  
   Dominante Frequenz: ${analysisData.dominantFreq.toFixed(2)} Hz
   Strukturelle Komplexit√§t: ${analysisData.complexity.toFixed(4)}

üî¢ MATHEMATISCHE VERH√ÑLTNISSE:
${analysisData.ratios.map((r, i) => `   ${i+1}. ${r.high.toFixed(2)}/${r.low.toFixed(2)} = ${r.ratio.toFixed(3)} [${r.name}]`).join('\n')}

üìä PERIODEN-ANALYSE:
${analysisData.periods.map((p, i) => `   ${i+1}. ${p.freq.toFixed(2)} Hz (Periode: ${p.samples}, St√§rke: ${p.strength.toFixed(4)})`).join('\n')}

‚öôÔ∏è ANALYSE-PARAMETER:
   Œæ-Profil: ${xiProfiles[xiProfile].name} (Faktor: ${xiProfiles[xiProfile].factor})
   Œæ-Threshold: ${xiThreshold}
   Periodizit√§ts-Threshold: ${periodThreshold}
   
üéØ BEWERTUNG:
   Signalqualit√§t: ${analysisData.quality}
   Harmonische Hinweise: ${analysisData.harmonicHints}
   Komplexit√§tsgrad: ${analysisData.complexityLevel}
                `;
            }, 500);
        }

        function analyzeResonance() {
            if (!currentSignal) {
                updateStatus('‚ö†Ô∏è Erst Signal generieren!', 'warning');
                return;
            }
            
            // Hole aktuelle Parameter und aktive Harmonien
            const activeHarmonics = getActiveHarmonics();
            const xiProfile = document.getElementById('xiProfile').value;
            
            updateStatus(`üéº Starte Resonanz-Analyse mit ${Object.keys(activeHarmonics).length} Harmonien...`, 'info');
            updateProgress(25);
            
            // Berechne Resonanz basierend auf aktiven Harmonien
            const resonanceData = calculateResonanceAnalysis(activeHarmonics, xiProfile);
            
            // Plotte mit echten Daten
            plotAnalysisChart('resonance', resonanceData);
            updateProgress(75);
            
            setTimeout(() => {
                updateProgress(100);
                updateStatus(`‚úÖ Resonanz-Analyse: ${resonanceData.matches}/${resonanceData.total} harmonische Treffer (${resonanceData.purity}% Reinheit)`, 'success');
                
                document.getElementById('textOutput').textContent = `
=== Œæ-HARMONISCHE RESONANZ ANALYSE ===

üéº HARMONISCHE TREFFER:
   Gefundene Harmonien: ${resonanceData.matches}/${resonanceData.total}
   Harmonische Reinheit: ${resonanceData.purity}%
   Dominante Kategorie: ${resonanceData.dominantCategory}
   Resonanz-Qualit√§t: ${resonanceData.quality}

üéµ HARMONISCHE PEAKS:
${resonanceData.peaks.map((p, i) => `   ${i+1}. ${p.freq.toFixed(2)} Hz ‚Üí ${p.name} [${p.category}]`).join('\n')}

üîä RESONANZ-MODI:
   fundamental: ${resonanceData.modes.fundamental} Peaks
   overtones: ${resonanceData.modes.overtones} Peaks
   subharmonics: ${resonanceData.modes.subharmonics} Peaks
   complex: ${resonanceData.modes.complex} Peaks

üéª INSTRUMENTALE KLASSIFIKATION:
   Typ: ${resonanceData.instrumentType}
   Begr√ºndung: ${resonanceData.reasoning}

üîó AKTIVE HARMONIEN:
${Object.entries(activeHarmonics).map(([key, h]) => `   ‚Ä¢ ${h.name} (${h.ratio}) [${h.category}]`).join('\n')}

‚öóÔ∏è RESONANZ-PARAMETER:
   Œæ-Profil: ${xiProfiles[xiProfile].name}
   Aktive Harmonien: ${Object.keys(activeHarmonics).length}/10
   Kategorien: ${resonanceData.categoryStats}
                `;
            }, 500);
        }

        function getActiveHarmonics() {
            const activeHarmonics = {};
            
            Object.entries(harmonicIntervals).forEach(([key, harmonic]) => {
                const checkbox = document.getElementById(`harmonic_${key}`);
                if (checkbox && checkbox.checked) {
                    activeHarmonics[key] = harmonic;
                }
            });
            
            return activeHarmonics;
        }

        function calculateT0Analysis(xiProfile, periodThreshold, xiThreshold) {
            // Simuliere echte T0-Analyse basierend auf Parametern
            const profile = xiProfiles[xiProfile];
            const baseFreq = parseFloat(document.getElementById('frequency').value) || 220;
            
            // Anzahl gefundener Perioden h√§ngt von Thresholds ab
            const periodCount = Math.max(3, Math.floor((1 - periodThreshold) * 12 + (1 - xiThreshold * 100) * 8));
            
            const periods = [];
            const frequencies = [];
            const strengths = [];
            
            // Generiere Perioden basierend auf Œæ-Profil
            for (let i = 0; i < periodCount; i++) {
                let freq;
                if (profile.factor < 100) { // Harmonisch
                    freq = baseFreq * (i + 1) * (0.8 + Math.random() * 0.4);
                } else { // Komplex/Mikrotonal
                    freq = baseFreq * (0.5 + Math.random() * 3);
                }
                
                const samples = Math.floor(sampleRate / freq);
                const strength = Math.max(0.1, (1 - i * 0.1) * (1 - xiThreshold * 10) + Math.random() * 0.2);
                
                periods.push({
                    freq: freq,
                    samples: samples,
                    strength: strength
                });
                
                frequencies.push(freq);
                strengths.push(strength);
            }
            
            // Sortiere nach St√§rke
            periods.sort((a, b) => b.strength - a.strength);
            
            // Berechne Verh√§ltnisse
            const ratios = [];
            for (let i = 0; i < Math.min(4, periods.length); i++) {
                for (let j = i + 1; j < Math.min(4, periods.length); j++) {
                    const high = Math.max(periods[i].freq, periods[j].freq);
                    const low = Math.min(periods[i].freq, periods[j].freq);
                    const ratio = high / low;
                    
                    ratios.push({
                        high: high,
                        low: low,
                        ratio: ratio,
                        name: classifyRatio(ratio)
                    });
                }
            }
            
            // Berechne Komplexit√§t basierend auf Profil
            const complexity = profile.factor > 500 ? 0.4 + Math.random() * 0.3 : 
                             profile.factor > 100 ? 0.2 + Math.random() * 0.2 : 
                             0.05 + Math.random() * 0.15;
            
            return {
                periods: periods,
                frequencies: frequencies,
                strengths: strengths,
                ratios: ratios,
                strongestPeriod: periods[0]?.samples || 200,
                dominantFreq: periods[0]?.freq || baseFreq,
                complexity: complexity,
                quality: complexity < 0.2 ? 'Exzellent' : complexity < 0.4 ? 'Gut' : 'Mittel',
                harmonicHints: ratios.filter(r => r.name.includes('~')).length,
                complexityLevel: complexity < 0.2 ? 'Niedrig' : complexity < 0.4 ? 'Mittel' : 'Hoch'
            };
        }

        function calculateResonanceAnalysis(activeHarmonics, xiProfile) {
            const baseFreq = parseFloat(document.getElementById('frequency').value) || 220;
            const harmonicCount = Object.keys(activeHarmonics).length;
            
            // Simuliere Resonanz basierend auf aktiven Harmonien
            const peaks = [];
            const categories = { Perfect: 0, Consonant: 0, Dissonant: 0 };
            
            Object.entries(activeHarmonics).forEach(([key, harmonic], index) => {
                if (Math.random() > 0.3) { // 70% Chance f√ºr Treffer
                    const freq = baseFreq * harmonic.ratio * (0.95 + Math.random() * 0.1);
                    peaks.push({
                        freq: freq,
                        name: harmonic.name,
                        category: harmonic.category
                    });
                    categories[harmonic.category]++;
                }
            });
            
            const matches = peaks.length;
            const total = harmonicCount;
            const purity = Math.round((matches / total) * 100);
            
            // Dominante Kategorie
            const dominantCategory = Object.entries(categories)
                .reduce((a, b) => categories[a[0]] > categories[b[0]] ? a : b)[0];
            
            // Instrumenten-Klassifikation
            const harmonicRatio = purity / 100;
            let instrumentType, reasoning;
            
            if (harmonicRatio > 0.8) {
                instrumentType = 'Tonal (Piano/Gitarre)';
                reasoning = 'Starke harmonische Struktur deutet auf Saiteninstrument hin';
            } else if (harmonicRatio > 0.5) {
                instrumentType = 'Semi-tonal (Bl√§ser)';
                reasoning = 'Moderate Harmonik typisch f√ºr Blasinstrumente';
            } else {
                instrumentType = 'Perkussiv (Schlagzeug)';
                reasoning = 'Komplexe Struktur charakteristisch f√ºr Perkussion';
            }
            
            return {
                matches: matches,
                total: total,
                purity: purity,
                peaks: peaks.slice(0, 6),
                dominantCategory: dominantCategory,
                quality: purity > 80 ? 'Exzellent' : purity > 60 ? 'Gut' : 'Mittel',
                modes: {
                    fundamental: categories.Perfect,
                    overtones: categories.Consonant,
                    subharmonics: Math.max(0, total - matches),
                    complex: categories.Dissonant
                },
                instrumentType: instrumentType,
                reasoning: reasoning,
                categoryStats: `Perfect:${categories.Perfect}, Consonant:${categories.Consonant}, Dissonant:${categories.Dissonant}`,
                categories: categories
            };
        }

        function classifyRatio(ratio) {
            if (Math.abs(ratio - 2.0) < 0.05) return '~Oktave';
            if (Math.abs(ratio - 1.5) < 0.03) return '~Quinte';
            if (Math.abs(ratio - 4/3) < 0.03) return '~Quarte';
            if (Math.abs(ratio - 1.25) < 0.02) return '~Gro√üe Terz';
            if (Math.abs(ratio - 1.2) < 0.02) return '~Kleine Terz';
            if (ratio < 1.15) return '~Schwebung';
            return 'Komplex';
        }

        function analyzeMicrotonal() {
            if (!currentSignal) {
                updateStatus('‚ö†Ô∏è Erst Signal generieren!', 'warning');
                return;
            }
            
            updateStatus('üéµ Starte Mikro-tonale Analyse...', 'info');
            updateProgress(25);
            
            // Sofort Analysis Chart plotten
            plotAnalysisChart('microtonal');
            updateProgress(75);
            
            setTimeout(() => {
                updateProgress(100);
                updateStatus('‚úÖ Mikro-tonale Analyse: 12 Cent-Intervalle', 'success');
            }, 500);
        }

        function compareFFT() {
            if (!currentSignal) {
                updateStatus('‚ö†Ô∏è Erst Signal generieren!', 'warning');
                return;
            }
            
            updateStatus('üìä Starte FFT-Vergleich...', 'info');
            updateProgress(25);
            
            // Sofort Analysis Chart plotten
            plotAnalysisChart('fft_compare');
            updateProgress(75);
            
            setTimeout(() => {
                updateProgress(100);
                updateStatus('‚úÖ FFT-Vergleich: T0=8, FFT=12, Gemeinsam=6', 'success');
            }, 500);
        }

        function plotAnalysisChart(analysisType, data = null) {
            const canvas = document.getElementById('analysisChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const width = canvas.width;
            const height = canvas.height;
            
            // Titel
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            
            switch (analysisType) {
                case 't0':
                    ctx.fillText('T0-Periodensuche Ergebnisse', width/2, 30);
                    plotT0Results(ctx, width, height, data);
                    break;
                case 'resonance':
                    ctx.fillText('Harmonische Resonanz-Analyse', width/2, 30);
                    plotResonanceResults(ctx, width, height, data);
                    break;
                case 'microtonal':
                    ctx.fillText('Mikro-tonale Intervall-Analyse', width/2, 30);
                    plotMicrotonalResults(ctx, width, height, data);
                    break;
                case 'fft_compare':
                    ctx.fillText('T0 vs FFT Methoden-Vergleich', width/2, 30);
                    plotFFTComparison(ctx, width, height, data);
                    break;
            }
        }

        function plotT0Results(ctx, width, height, data) {
            // Verwende echte Daten falls verf√ºgbar, sonst Demo-Daten
            const frequencies = data ? data.frequencies : [220.5, 440.25, 330.75, 661.5, 275.0, 495.0, 183.3, 367.5];
            const strengths = data ? data.strengths : [0.85, 0.62, 0.46, 0.35, 0.28, 0.22, 0.18, 0.15];
            
            const barWidth = (width - 100) / frequencies.length;
            const maxStrength = Math.max(...strengths);
            
            // Zeige Parameter-Einfluss
            const xiProfile = document.getElementById('xiProfile').value;
            const periodThreshold = document.getElementById('periodThreshold').value;
            
            // Parameter-Info
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Œæ-Profil: ${xiProfiles[xiProfile].name} | Threshold: ${periodThreshold}`, 10, height - 10);
            
            // Balkendiagramm
            for (let i = 0; i < frequencies.length; i++) {
                const barHeight = (strengths[i] / maxStrength) * (height - 100);
                const x = 50 + i * barWidth;
                const y = height - 50 - barHeight;
                
                // Farbverlauf basierend auf Œæ-Profil
                let hue;
                if (xiProfile === 'harmonic') {
                    hue = (strengths[i] / maxStrength) * 120; // Gr√ºn f√ºr harmonisch
                } else if (xiProfile === 'complex') {
                    hue = 240 + (strengths[i] / maxStrength) * 60; // Blau-Violett f√ºr komplex
                } else {
                    hue = 30 + (strengths[i] / maxStrength) * 90; // Gelb-Orange f√ºr universal/mikrotonal
                }
                
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.fillRect(x, y, barWidth - 5, barHeight);
                
                // Frequenz-Label
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${frequencies[i].toFixed(1)}Hz`, x + barWidth/2, height - 35);
                
                // St√§rke-Wert
                ctx.fillText(strengths[i].toFixed(2), x + barWidth/2, y - 5);
            }
            
            // Achsenbeschriftung
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Frequenz (Hz)', width/2, height - 20);
            
            ctx.save();
            ctx.translate(15, height/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Periodenst√§rke', 0, 0);
            ctx.restore();
        }

        function plotResonanceResults(ctx, width, height, data) {
            // Verwende echte Daten falls verf√ºgbar
            const activeHarmonics = getActiveHarmonics();
            const categories = data ? data.categories : { Perfect: 3, Consonant: 3, Dissonant: 1 };
            const categoryNames = Object.keys(categories);
            const counts = Object.values(categories);
            const colors = ['#ff4444', '#ff8800', '#ffcc00', '#8844ff'];
            
            // Zeige aktive Harmonien Info
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Aktive Harmonien: ${Object.keys(activeHarmonics).length}/10`, 10, height - 10);
            
            // Pie Chart
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 4;
            
            let currentAngle = 0;
            const total = counts.reduce((a, b) => a + b, 0);
            
            if (total > 0) {
                for (let i = 0; i < categoryNames.length; i++) {
                    const count = counts[i];
                    if (count > 0) {
                        const sliceAngle = (count / total) * 2 * Math.PI;
                        
                        ctx.fillStyle = colors[i];
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Label
                        const labelAngle = currentAngle + sliceAngle / 2;
                        const labelX = centerX + Math.cos(labelAngle) * (radius + 30);
                        const labelY = centerY + Math.sin(labelAngle) * (radius + 30);
                        
                        ctx.fillStyle = '#333';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${categoryNames[i]}(${count})`, labelX, labelY);
                        
                        currentAngle += sliceAngle;
                    }
                }
            } else {
                // Keine Daten
                ctx.fillStyle = '#ccc';
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Keine harmonischen', centerX, centerY - 5);
                ctx.fillText('Treffer gefunden', centerX, centerY + 15);
            }
        }

        function plotMicrotonalResults(ctx, width, height) {
            // Demo-Daten f√ºr Mikrotonal-Analyse
            const intervals = [200, 386, 498, 702, 884, 1088, 1200];
            const deviations = [2, -5, 8, -2, 12, -8, 0];
            
            const barWidth = (width - 100) / intervals.length;
            
            // Cent-Abweichungen
            for (let i = 0; i < intervals.length; i++) {
                const deviation = deviations[i];
                const barHeight = Math.abs(deviation) * 3;
                const x = 50 + i * barWidth;
                const y = height/2 - (deviation > 0 ? barHeight : 0);
                
                ctx.fillStyle = deviation > 0 ? '#ff6b6b' : '#4ecdc4';
                ctx.fillRect(x, y, barWidth - 5, Math.abs(barHeight));
                
                // Cent-Label
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${intervals[i]}¬¢`, x + barWidth/2, height - 20);
                ctx.fillText(`${deviation > 0 ? '+' : ''}${deviation}¬¢`, x + barWidth/2, y - 5);
            }
            
            // Null-Linie
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, height/2);
            ctx.lineTo(width - 50, height/2);
            ctx.stroke();
        }

        function plotFFTComparison(ctx, width, height) {
            // Demo-Daten f√ºr FFT-Vergleich
            const methods = ['T0 Peaks', 'FFT Peaks', 'Gemeinsame', 'T0 Unique', 'FFT Unique'];
            const values = [8, 12, 6, 2, 6];
            const colors = ['#667eea', '#764ba2', '#4facfe', '#f093fb', '#f5576c'];
            
            const barWidth = (width - 100) / methods.length;
            const maxValue = Math.max(...values);
            
            for (let i = 0; i < methods.length; i++) {
                const barHeight = (values[i] / maxValue) * (height - 100);
                const x = 50 + i * barWidth;
                const y = height - 50 - barHeight;
                
                ctx.fillStyle = colors[i];
                ctx.fillRect(x, y, barWidth - 10, barHeight);
                
                // Wert-Label
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(values[i].toString(), x + barWidth/2, y - 10);
                
                // Methoden-Label
                ctx.font = '10px Arial';
                ctx.save();
                ctx.translate(x + barWidth/2, height - 30);
                ctx.rotate(-Math.PI/6);
                ctx.fillText(methods[i], 0, 0);
                ctx.restore();
            }
        }

        // =================================================================
        // DATEI-OPERATIONEN
        // =================================================================
        
        function loadFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            updateStatus(`üìÇ Lade Datei: ${file.name}...`, 'info');
            updateProgress(25);

            const reader = new FileReader();
            
            if (file.name.endsWith('.json')) {
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.signal) {
                            currentSignal = new Float32Array(data.signal);
                            updateProgress(75);
                            plotSignal(currentSignal);
                            updateProgress(100);
                            updateStatus(`‚úÖ JSON geladen: ${currentSignal.length} Samples`, 'success');
                        } else {
                            updateStatus('‚ùå Ung√ºltige JSON-Struktur', 'error');
                        }
                    } catch (error) {
                        updateStatus(`‚ùå JSON-Fehler: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(file);
                
            } else if (file.name.endsWith('.wav')) {
                reader.onload = function(e) {
                    try {
                        updateProgress(50);
                        if (audioContext) {
                            audioContext.decodeAudioData(e.target.result, function(buffer) {
                                currentSignal = buffer.getChannelData(0);
                                sampleRate = buffer.sampleRate;
                                updateProgress(75);
                                plotSignal(currentSignal);
                                updateProgress(100);
                                updateStatus(`‚úÖ WAV geladen: ${currentSignal.length} Samples (${sampleRate}Hz)`, 'success');
                            }, function(error) {
                                updateStatus(`‚ùå WAV-Dekodierung fehlgeschlagen: ${error.message}`, 'error');
                            });
                        } else {
                            updateStatus('‚ùå Audio-Context nicht verf√ºgbar', 'error');
                        }
                    } catch (error) {
                        updateStatus(`‚ùå WAV-Fehler: ${error.message}`, 'error');
                    }
                };
                reader.readAsArrayBuffer(file);
                
            } else if (file.name.endsWith('.csv')) {
                reader.onload = function(e) {
                    try {
                        const csvData = e.target.result;
                        const lines = csvData.split('\n');
                        const values = [];
                        
                        // Parse CSV (einfach: erste Spalte als Signalwerte)
                        for (let i = 1; i < lines.length; i++) { // Skip header
                            const value = parseFloat(lines[i].split(',')[0]);
                            if (!isNaN(value)) {
                                values.push(value);
                            }
                        }
                        
                        if (values.length > 0) {
                            currentSignal = new Float32Array(values);
                            updateProgress(75);
                            plotSignal(currentSignal);
                            updateProgress(100);
                            updateStatus(`‚úÖ CSV geladen: ${currentSignal.length} Datenpunkte`, 'success');
                        } else {
                            updateStatus('‚ùå Keine g√ºltigen Daten in CSV gefunden', 'error');
                        }
                    } catch (error) {
                        updateStatus(`‚ùå CSV-Fehler: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(file);
                
            } else {
                updateStatus('‚ùå Nicht unterst√ºtztes Dateiformat', 'error');
            }
        }

        function saveSignal() {
            if (!currentSignal) {
                updateStatus('‚ö†Ô∏è Erst Signal generieren!', 'warning');
                return;
            }

            try {
                const signalData = {
                    signal: Array.from(currentSignal),
                    sampleRate: sampleRate,
                    metadata: {
                        type: document.getElementById('signalType').value,
                        frequency: parseFloat(document.getElementById('frequency').value),
                        duration: parseFloat(document.getElementById('duration').value),
                        generated: new Date().toISOString()
                    }
                };

                const jsonString = JSON.stringify(signalData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `xi_signal_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                updateStatus('üíæ Signal als JSON gespeichert', 'success');
                
            } catch (error) {
                updateStatus(`‚ùå Export fehlgeschlagen: ${error.message}`, 'error');
            }
        }

        function playSignal() {
            if (!currentSignal || !audioContext) {
                updateStatus('‚ö†Ô∏è Signal oder Audio-Context nicht verf√ºgbar', 'warning');
                return;
            }

            try {
                // Audio-Context aktivieren falls suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                // Audio-Buffer erstellen
                const buffer = audioContext.createBuffer(1, currentSignal.length, sampleRate);
                const channelData = buffer.getChannelData(0);
                
                for (let i = 0; i < currentSignal.length; i++) {
                    channelData[i] = currentSignal[i];
                }

                // Audio-Source erstellen und abspielen
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start();
                
                updateStatus('üîä Signal wird abgespielt...', 'success');
                
            } catch (error) {
                updateStatus(`‚ùå Wiedergabe fehlgeschlagen: ${error.message}`, 'error');
            }
        }

        function exportWAV() {
            if (!currentSignal) {
                updateStatus('‚ö†Ô∏è Erst Signal generieren!', 'warning');
                return;
            }

            try {
                // WAV-Header erstellen
                const length = currentSignal.length;
                const buffer = new ArrayBuffer(44 + length * 2);
                const view = new DataView(buffer);
                
                // WAV-Header schreiben
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, 36 + length * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, 1, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * 2, true);
                view.setUint16(32, 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, length * 2, true);
                
                // Audio-Daten schreiben
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    const sample = Math.max(-1, Math.min(1, currentSignal[i]));
                    view.setInt16(offset, sample * 0x7FFF, true);
                    offset += 2;
                }
                
                const blob = new Blob([buffer], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `xi_signal_${Date.now()}.wav`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                updateStatus('üéµ Signal als WAV exportiert', 'success');
                
            } catch (error) {
                updateStatus(`‚ùå WAV-Export fehlgeschlagen: ${error.message}`, 'error');
            }
        }

        // =================================================================
        // TEST-FUNKTIONEN
        // =================================================================
        
        function testCanvas() {
            updateStatus('üß™ Teste Canvas-Funktionalit√§t...', 'info');
            
            // Teste alle Chart-Typen nacheinander
            const chartTypes = ['t0', 'resonance', 'microtonal', 'fft_compare'];
            let currentIndex = 0;
            
            function showNextChart() {
                if (currentIndex < chartTypes.length) {
                    plotAnalysisChart(chartTypes[currentIndex]);
                    updateStatus(`üß™ Canvas-Test: ${chartTypes[currentIndex]} (${currentIndex + 1}/${chartTypes.length})`, 'info');
                    currentIndex++;
                    setTimeout(showNextChart, 2000);
                } else {
                    updateStatus('‚úÖ Canvas-Test abgeschlossen - Alle Diagramme funktionieren!', 'success');
                }
            }
            
            showNextChart();
        }

        // =================================================================
        // APP STARTEN
        // =================================================================
        
        document.addEventListener('DOMContentLoaded', initApp);
        console.log('üéº Œæ-FFT Harmonische Signal-Analyse Demo bereit');
    </script>
</body>
</html>