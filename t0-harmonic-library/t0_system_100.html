<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎵 T0 Audio System - Vollständige Implementierung</title>
    <style>
        :root {
            --primary-green: #00ff66;
            --primary-blue: #4488ff;
            --primary-orange: #ff6b35;
            --primary-purple: #8b5cf6;
            --bg-dark: #0f0f23;
            --bg-darker: #1a1a3a;
            --glass-bg: rgba(255,255,255,0.1);
            --glass-border: rgba(255,255,255,0.2);
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-dark), var(--bg-darker));
            color: #e0e6ed;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, rgba(0,255,150,0.15), rgba(0,255,150,0.05));
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0,255,150,0.3);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(0,255,150,0.1), transparent);
            animation: rotate 10s linear infinite;
        }

        .header-content {
            position: relative;
            z-index: 1;
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .system-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .status-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            text-align: center;
            transition: all 0.3s ease;
        }

        .status-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,255,102,0.2);
        }

        .section {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            margin: 20px 0;
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            position: relative;
        }

        .section h3 {
            color: var(--primary-green);
            margin-bottom: 20px;
            font-size: 1.4em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }

        .chord-button {
            background: linear-gradient(135deg, #2a2a3a, #3a3a4a);
            color: var(--primary-green);
            border: 2px solid var(--primary-green);
            padding: 15px 12px;
            cursor: pointer;
            border-radius: 12px;
            font-family: inherit;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .chord-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s ease;
        }

        .chord-button:hover::before {
            left: 100%;
        }

        .chord-button:hover {
            background: linear-gradient(135deg, #3a3a4a, #4a4a5a);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,255,102,0.4);
        }

        .chord-button.selected {
            background: linear-gradient(135deg, var(--primary-green), #00cc52);
            color: #000;
            border-color: #fff;
            box-shadow: 0 5px 20px rgba(0,255,102,0.5);
        }

        .audio-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .play-button {
            background: linear-gradient(135deg, var(--primary-orange), #f7931e);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(255,107,53,0.3);
            position: relative;
            overflow: hidden;
        }

        .play-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255,107,53,0.5);
        }

        .play-button:active {
            transform: translateY(0);
        }

        .play-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-box {
            background: rgba(0,0,0,0.4);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid var(--glass-border);
        }

        .frequency-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 15px 0;
        }

        .frequency-tag {
            background: rgba(0,255,102,0.2);
            border: 1px solid rgba(0,255,102,0.5);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .frequency-tag:hover {
            transform: scale(1.05);
            background: rgba(0,255,102,0.3);
        }

        .difference-tag {
            background: rgba(255,170,0,0.2);
            border: 1px solid rgba(255,170,0,0.5);
        }

        .reconstructed-tag {
            background: rgba(68,136,255,0.2);
            border: 1px solid rgba(68,136,255,0.5);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            transition: all 0.3s ease;
        }

        .status-ready { background: var(--success); }
        .status-playing { 
            background: var(--primary-orange); 
            animation: pulse 1s infinite;
            box-shadow: 0 0 10px var(--primary-orange);
        }
        .status-processing { 
            background: var(--warning); 
            animation: pulse 0.5s infinite;
        }
        .status-error { 
            background: var(--error); 
            animation: shake 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.3; transform: scale(1.2); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        .performance-monitor {
            background: linear-gradient(135deg, var(--primary-purple), #7c3aed);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .performance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .performance-item {
            text-align: center;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        .adaptive-controls {
            background: linear-gradient(135deg, rgba(139,92,246,0.2), rgba(139,92,246,0.1));
            border: 1px solid rgba(139,92,246,0.3);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .slider-container {
            margin: 15px 0;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255,255,255,0.2);
            outline: none;
            transition: all 0.3s ease;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-green);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,255,102,0.5);
        }

        .error-boundary {
            background: rgba(239,68,68,0.1);
            border: 1px solid rgba(239,68,68,0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            display: none;
        }

        .cache-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 1000;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-green), var(--primary-blue));
            width: 0%;
            transition: width 0.3s ease;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal {
            background: var(--bg-darker);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .floating-action {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-green), #00cc52);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0,255,102,0.4);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .floating-action:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 30px rgba(0,255,102,0.6);
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .chord-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 8px;
            }
            
            .audio-controls {
                gap: 10px;
            }
            
            .play-button {
                padding: 12px 18px;
                font-size: 12px;
            }
            
            .comparison-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="cache-status" id="cacheStatus">
        🧠 Cache: Leer | ⚡ Performance: Initialisierung...
    </div>

    <div class="container">
        <div class="header">
            <div class="header-content">
                <h1>🎵 T0 AUDIO SYSTEM - 100% VOLLSTÄNDIG</h1>
                <p>Revolutionäre Differenzton-basierte Akkord-Analyse & Rekonstruktion</p>
                <div class="system-status">
                    <div class="status-card">
                        <h4>🎯 System Status</h4>
                        <div id="systemStatus">100% Operational</div>
                    </div>
                    <div class="status-card">
                        <h4>🧮 Akkord-Bibliothek</h4>
                        <div id="chordLibrarySize">Laden...</div>
                    </div>
                    <div class="status-card">
                        <h4>⚡ Performance</h4>
                        <div id="performanceStatus">Optimal</div>
                    </div>
                    <div class="status-card">
                        <h4>🔍 Erkennungsrate</h4>
                        <div id="recognitionRate">Laden...</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h3>🎹 Erweiterte Akkord-Auswahl</h3>
            <div class="chord-grid" id="chordGrid">
                <!-- Wird dynamisch gefüllt -->
            </div>
        </div>

        <div class="section">
            <h3>🔧 Adaptive Systemparameter</h3>
            <div class="adaptive-controls">
                <div class="slider-container">
                    <label>🎚️ Fuzzy-Matching Toleranz: <span id="toleranceValue">3.0 Hz</span></label>
                    <input type="range" id="toleranceSlider" class="slider" min="0.5" max="10" step="0.1" value="3.0">
                </div>
                <div class="slider-container">
                    <label>🔊 Audio-Lautstärke: <span id="volumeValue">50%</span></label>
                    <input type="range" id="volumeSlider" class="slider" min="0" max="100" value="50">
                </div>
                <div class="slider-container">
                    <label>⚡ Harmonische Tiefe: <span id="harmonicValue">3</span></label>
                    <input type="range" id="harmonicSlider" class="slider" min="1" max="8" value="3">
                </div>
                <div class="slider-container">
                    <label>🎯 Erkennungs-Schwelle: <span id="thresholdValue">60%</span></label>
                    <input type="range" id="thresholdSlider" class="slider" min="30" max="95" value="60">
                </div>
            </div>
        </div>

        <div class="section">
            <h3>🎧 Audio-Kontrollen</h3>
            <div class="audio-controls">
                <button class="play-button" id="playOriginal" disabled>
                    <span class="status-indicator status-ready" id="statusOriginal"></span>
                    Original
                </button>
                <button class="play-button" id="playDifferences" disabled>
                    <span class="status-indicator status-ready" id="statusDifferences"></span>
                    Differenztöne
                </button>
                <button class="play-button" id="playReconstructed" disabled>
                    <span class="status-indicator status-ready" id="statusReconstructed"></span>
                    Rekonstruiert
                </button>
                <button class="play-button" id="playComparison" disabled>
                    <span class="status-indicator status-ready" id="statusComparison"></span>
                    A/B Vergleich
                </button>
                <button class="play-button" id="playSequence" disabled>
                    <span class="status-indicator status-ready" id="statusSequence"></span>
                    Sequenz
                </button>
            </div>
        </div>

        <div class="performance-monitor">
            <h3>📊 Performance Monitor</h3>
            <div class="performance-grid">
                <div class="performance-item">
                    <div>Berechnung</div>
                    <div id="calcTime">0ms</div>
                </div>
                <div class="performance-item">
                    <div>Audio-Latenz</div>
                    <div id="audioLatency">0ms</div>
                </div>
                <div class="performance-item">
                    <div>Cache-Hits</div>
                    <div id="cacheHits">0</div>
                </div>
                <div class="performance-item">
                    <div>Speicher</div>
                    <div id="memoryUsage">0MB</div>
                </div>
                <div class="performance-item">
                    <div>Genauigkeit</div>
                    <div id="accuracy">100%</div>
                </div>
            </div>
        </div>

        <div class="comparison-grid">
            <div class="comparison-box">
                <h4>📊 Original-Akkord</h4>
                <div id="originalAnalysis">
                    <p>Wähle einen Akkord aus der erweiterten Bibliothek...</p>
                </div>
            </div>
            <div class="comparison-box">
                <h4>🔄 T0-Rekonstruktion</h4>
                <div id="reconstructionAnalysis">
                    <p>Warte auf Berechnung...</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h4>🧮 Erweiterte Berechnungsdetails</h4>
            <div id="calculationDetails">
                <p>Detaillierte Berechnungen werden hier angezeigt...</p>
            </div>
        </div>

        <div class="section">
            <h4>🎯 Intelligente Testergebnisse</h4>
            <div id="testResults">
                <p>Führe Tests durch um erweiterte Ergebnisse zu sehen...</p>
            </div>
        </div>

        <div class="section">
            <h4>📈 Statistische Analyse</h4>
            <div id="statisticalAnalysis">
                <p>Teste verschiedene Akkorde um Statistiken zu sehen...</p>
            </div>
            <button class="play-button" id="runComprehensiveTest" style="margin: 15px 0;">
                🧪 Umfassender Systemtest
            </button>
            <div class="progress-bar">
                <div class="progress-fill" id="testProgress"></div>
            </div>
        </div>

        <div class="error-boundary" id="errorBoundary">
            <h4>⚠️ Systemfehler</h4>
            <div id="errorMessage"></div>
            <button class="play-button" id="resetSystem" style="margin-top: 10px;">
                🔄 System zurücksetzen
            </button>
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <h3 id="modalTitle">Modal Title</h3>
            <div id="modalContent">Modal Content</div>
            <button class="play-button" onclick="closeModal()" style="margin-top: 20px;">
                ✕ Schließen
            </button>
        </div>
    </div>

    <button class="floating-action" id="floatingAction" title="Erweiterte Optionen">
        ⚙️
    </button>

    <script>
        // ============================================================================
        // VOLLSTÄNDIGE T0-SYSTEM IMPLEMENTIERUNG - 100% COMPLETE
        // ============================================================================

        class T0AudioSystemComplete {
            constructor() {
                this.version = "2.0.0";
                this.completionRate = 100;
                
                // Erweiterte Konfiguration
                this.config = {
                    maxHarmonic: 3,
                    tolerance: 3.0,
                    volume: 0.5,
                    recognitionThreshold: 0.6,
                    cacheSize: 1000,
                    performanceMonitoring: true,
                    adaptiveParameters: true,
                    errorRecovery: true
                };

                // Systemzustand
                this.state = {
                    audioContext: null,
                    currentChord: null,
                    originalFrequencies: [],
                    differenceFrequencies: [],
                    reconstructedFrequencies: [],
                    isPlaying: false,
                    cache: new Map(),
                    performance: {
                        calculations: [],
                        audioLatency: [],
                        cacheHits: 0,
                        memoryUsage: 0
                    },
                    statistics: {
                        testsRun: 0,
                        perfectMatches: 0,
                        goodMatches: 0,
                        errors: 0
                    }
                };

                // Erweiterte Akkord-Bibliothek
                this.chordLibrary = this.generateExtendedChordLibrary();
                this.signatureDatabase = new Map();
                
                this.initializeSystem();
            }

            // Erweiterte Akkord-Bibliothek mit ALLEN Akkordtypen
            generateExtendedChordLibrary() {
                const baseChords = {
                    // Grundakkorde
                    'Major': [0, 4, 7],
                    'Minor': [0, 3, 7],
                    'Diminished': [0, 3, 6],
                    'Augmented': [0, 4, 8],
                    'Sus2': [0, 2, 7],
                    'Sus4': [0, 5, 7],
                    
                    // Septakkorde
                    'Dom7': [0, 4, 7, 10],
                    'Maj7': [0, 4, 7, 11],
                    'Min7': [0, 3, 7, 10],
                    'Dim7': [0, 3, 6, 9],
                    'HalfDim7': [0, 3, 6, 10],
                    'Aug7': [0, 4, 8, 10],
                    'MinMaj7': [0, 3, 7, 11],
                    
                    // Erweiterte Akkorde (9th, 11th, 13th)
                    'Add9': [0, 4, 7, 14],
                    'Add11': [0, 4, 7, 17],
                    'Add13': [0, 4, 7, 21],
                    'Maj9': [0, 4, 7, 11, 14],
                    'Min9': [0, 3, 7, 10, 14],
                    'Dom9': [0, 4, 7, 10, 14],
                    'Maj11': [0, 4, 7, 11, 14, 17],
                    'Min11': [0, 3, 7, 10, 14, 17],
                    'Dom11': [0, 4, 7, 10, 14, 17],
                    'Maj13': [0, 4, 7, 11, 14, 17, 21],
                    'Min13': [0, 3, 7, 10, 14, 17, 21],
                    'Dom13': [0, 4, 7, 10, 14, 17, 21],
                    
                    // Alterierte Akkorde
                    'Dom7b5': [0, 4, 6, 10],
                    'Dom7#5': [0, 4, 8, 10],
                    'Dom7b9': [0, 4, 7, 10, 13],
                    'Dom7#9': [0, 4, 7, 10, 15],
                    'Dom7#11': [0, 4, 7, 10, 18],
                    'Dom7b13': [0, 4, 7, 10, 20],
                    
                    // Spezielle Akkorde
                    'Quartal': [0, 5, 10],
                    'Quintal': [0, 7, 14],
                    'Cluster': [0, 1, 2],
                    'Polychord': [0, 4, 7, 12, 16, 19],
                    
                    // Jazz-Akkorde
                    'Min6': [0, 3, 7, 9],
                    'Maj6': [0, 4, 7, 9],
                    'Min6add9': [0, 3, 7, 9, 14],
                    'Maj6add9': [0, 4, 7, 9, 14],
                    '69': [0, 4, 7, 9, 14],
                    'Alt': [0, 4, 6, 10, 13, 15, 20] // Altered dominant
                };

                const library = new Map();
                const baseFreq = 261.63; // C4

                // Für jeden Akkordtyp
                Object.entries(baseChords).forEach(([chordType, intervals]) => {
                    // Grundstellung
                    const fundamentals = intervals.map(i => baseFreq * Math.pow(2, i/12));
                    library.set(`${chordType}`, fundamentals);

                    // Umkehrungen (bis zu 4 Umkehrungen)
                    const maxInversions = Math.min(intervals.length - 1, 4);
                    for (let inv = 1; inv <= maxInversions; inv++) {
                        const inverted = this.generateInversion(intervals, inv);
                        const invertedFunds = inverted.map(i => baseFreq * Math.pow(2, i/12));
                        library.set(`${chordType} (${inv}. Umk.)`, invertedFunds);
                    }

                    // Transponierte Versionen (F, G, A, Bb, D)
                    [5, 7, 9, 10, 2].forEach(transpose => {
                        const transposed = intervals.map(i => i + transpose);
                        const transposedFunds = transposed.map(i => baseFreq * Math.pow(2, i/12));
                        const rootNote = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'][transpose];
                        library.set(`${rootNote}-${chordType}`, transposedFunds);
                    });
                });

                console.log(`🎵 Erweiterte Akkord-Bibliothek: ${library.size} Akkorde`);
                return library;
            }

            generateInversion(intervals, inversionNumber) {
                const inverted = [...intervals];
                for (let i = 0; i < inversionNumber; i++) {
                    const lowest = inverted.shift();
                    inverted.push(lowest + 12);
                }
                return inverted;
            }

            // Vollständige Signatur-Datenbank generieren
            generateSignatureDatabase() {
                console.log("🔍 Generiere vollständige Signatur-Datenbank...");
                const startTime = performance.now();

                this.signatureDatabase.clear();
                
                for (const [chordName, frequencies] of this.chordLibrary) {
                    try {
                        const signature = this.computeT0Signature(frequencies);
                        this.signatureDatabase.set(signature.hash, {
                            chordName,
                            frequencies,
                            signature
                        });
                    } catch (error) {
                        this.handleError(`Signatur-Generierung für ${chordName}`, error);
                    }
                }

                const endTime = performance.now();
                const duration = endTime - startTime;
                
                console.log(`✅ Signatur-Datenbank: ${this.signatureDatabase.size} Einträge in ${duration.toFixed(1)}ms`);
                this.updatePerformanceMetrics('signatureGeneration', duration);
            }

            // Erweiterte Differenzton-Berechnung
            calculateDifferenceTones(fundamentals) {
                const cacheKey = `diff_${fundamentals.join('_')}`;
                if (this.state.cache.has(cacheKey)) {
                    this.state.performance.cacheHits++;
                    return this.state.cache.get(cacheKey);
                }

                const spectrum = [...fundamentals];
                
                // Harmonische hinzufügen
                fundamentals.forEach(freq => {
                    for (let h = 2; h <= this.config.maxHarmonic; h++) {
                        const harmonic = freq * h;
                        if (harmonic <= 2000) { // Frequenzlimit
                            spectrum.push(harmonic);
                        }
                    }
                });

                // Alle Differenztöne berechnen
                const differences = new Set();
                for (let i = 0; i < spectrum.length; i++) {
                    for (let j = i + 1; j < spectrum.length; j++) {
                        const diff = Math.abs(spectrum[j] - spectrum[i]);
                        if (diff >= 5 && diff <= 500) {
                            differences.add(Math.round(diff * 10) / 10);
                        }
                    }
                }

                const result = Array.from(differences).sort((a, b) => a - b);
                
                // Cache updaten
                if (this.state.cache.size < this.config.cacheSize) {
                    this.state.cache.set(cacheKey, result);
                }

                return result;
            }

            // Erweiterte T0-Signatur mit Fehlererkennung
            computeT0Signature(fundamentals) {
                if (!Array.isArray(fundamentals) || fundamentals.length === 0) {
                    throw new Error("Ungültige Fundamentalfrequenzen");
                }

                const startTime = performance.now();
                
                try {
                    const allDifferences = this.calculateDifferenceTones(fundamentals);
                    const primaryDifferences = allDifferences
                        .filter(d => d >= 20 && d <= 200)
                        .slice(0, 8); // Erweitert auf 8 primäre Frequenzen

                    const signature = {
                        fundamentals: fundamentals.map(f => Math.round(f * 10) / 10),
                        allDifferences,
                        primaryDifferences,
                        hash: primaryDifferences.join(':'),
                        metadata: {
                            noteCount: fundamentals.length,
                            frequencyRange: [Math.min(...fundamentals), Math.max(...fundamentals)],
                            complexity: this.calculateComplexity(fundamentals)
                        }
                    };

                    const endTime = performance.now();
                    this.updatePerformanceMetrics('signatureComputation', endTime - startTime);
                    
                    return signature;
                } catch (error) {
                    this.handleError('T0-Signatur Berechnung', error);
                    throw error;
                }
            }

            calculateComplexity(frequencies) {
                // Komplexitäts-Berechnung basierend auf Frequenzverteilung
                const intervals = [];
                for (let i = 1; i < frequencies.length; i++) {
                    intervals.push(frequencies[i] / frequencies[i-1]);
                }
                
                const variance = this.calculateVariance(intervals);
                return Math.min(100, variance * 10); // Normalisiert auf 0-100
            }

            calculateVariance(values) {
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
                return Math.sqrt(variance);
            }

            // Erweiterte Rekonstruktion mit Fuzzy-Logic
            reconstructFromDifferences(differences) {
                const startTime = performance.now();
                
                try {
                    const inputSignature = this.computeSignatureFromDifferences(differences);
                    
                    // 1. Direkte Hash-Suche
                    if (this.signatureDatabase.has(inputSignature.hash)) {
                        const match = this.signatureDatabase.get(inputSignature.hash);
                        console.log(`🎯 Direkte Erkennung: ${match.chordName}`);
                        return {
                            frequencies: match.frequencies,
                            confidence: 1.0,
                            method: 'direct',
                            chordName: match.chordName
                        };
                    }

                    // 2. Erweiterte Fuzzy-Matching mit adaptiven Parametern
                    let bestMatch = null;
                    let bestScore = 0;

                    for (const [hash, chordData] of this.signatureDatabase) {
                        const score = this.calculateAdvancedSimilarity(
                            inputSignature.primaryDifferences,
                            chordData.signature.primaryDifferences
                        );
                        
                        if (score > bestScore && score > this.config.recognitionThreshold) {
                            bestScore = score;
                            bestMatch = chordData;
                        }
                    }

                    if (bestMatch) {
                        console.log(`🔍 Fuzzy-Match: ${bestMatch.chordName} (${(bestScore * 100).toFixed(1)}%)`);
                        return {
                            frequencies: bestMatch.frequencies,
                            confidence: bestScore,
                            method: 'fuzzy',
                            chordName: bestMatch.chordName
                        };
                    }

                    // 3. Adaptive Rekonstruktion
                    const adaptiveResult = this.adaptiveReconstruction(differences);
                    return {
                        frequencies: adaptiveResult,
                        confidence: 0.5,
                        method: 'adaptive',
                        chordName: 'Unbekannt (Adaptiv)'
                    };

                } catch (error) {
                    this.handleError('Rekonstruktion', error);
                    return {
                        frequencies: [261.63],
                        confidence: 0,
                        method: 'error',
                        chordName: 'Fehler'
                    };
                } finally {
                    const endTime = performance.now();
                    this.updatePerformanceMetrics('reconstruction', endTime - startTime);
                }
            }

            computeSignatureFromDifferences(differences) {
                const sorted = differences.sort((a, b) => a - b);
                const primary = sorted.filter(d => d >= 20 && d <= 200).slice(0, 8);
                
                return {
                    allDifferences: sorted,
                    primaryDifferences: primary,
                    hash: primary.join(':')
                };
            }

            calculateAdvancedSimilarity(set1, set2) {
                if (set1.length === 0 && set2.length === 0) return 1.0;
                if (set1.length === 0 || set2.length === 0) return 0.0;

                let matches = 0;
                let weightedMatches = 0;
                const tolerance = this.config.tolerance;

                set1.forEach((freq1, index1) => {
                    const bestMatch = set2.find(freq2 => Math.abs(freq1 - freq2) <= tolerance);
                    if (bestMatch) {
                        matches++;
                        // Gewichtung basierend auf Position (frühere Frequenzen wichtiger)
                        const weight = 1 / (index1 + 1);
                        weightedMatches += weight;
                    }
                });

                const basicScore = matches / Math.max(set1.length, set2.length);
                const weightedScore = weightedMatches / set1.length;
                
                return (basicScore + weightedScore) / 2;
            }

            adaptiveReconstruction(differences) {
                console.log("🧠 Adaptive Rekonstruktion aktiviert");
                
                const sorted = differences.sort((a, b) => a - b);
                const base = 261.63;
                const result = [base];
                
                // Intelligente Frequenz-Ableitung
                if (sorted.length >= 2) {
                    const firstDiff = sorted[0];
                    const secondDiff = sorted[1];
                    
                    result.push(base + firstDiff);
                    if (secondDiff > firstDiff * 1.5) {
                        result.push(base + secondDiff);
                    }
                }
                
                return result;
            }

            // Performance-Monitoring
            updatePerformanceMetrics(operation, duration) {
                if (!this.config.performanceMonitoring) return;

                this.state.performance.calculations.push({
                    operation,
                    duration,
                    timestamp: Date.now()
                });

                // Nur die letzten 100 Messungen behalten
                if (this.state.performance.calculations.length > 100) {
                    this.state.performance.calculations.shift();
                }

                this.updatePerformanceDisplay();
            }

            updatePerformanceDisplay() {
                const calc = this.state.performance.calculations;
                if (calc.length === 0) return;

                const avgTime = calc.reduce((a, b) => a + b.duration, 0) / calc.length;
                const memUsage = (performance.memory ? performance.memory.usedJSHeapSize / 1024 / 1024 : 0);

                document.getElementById('calcTime').textContent = `${avgTime.toFixed(1)}ms`;
                document.getElementById('memoryUsage').textContent = `${memUsage.toFixed(1)}MB`;
                document.getElementById('cacheHits').textContent = this.state.performance.cacheHits;
                
                // Cache-Status aktualisieren
                document.getElementById('cacheStatus').textContent = 
                    `🧠 Cache: ${this.state.cache.size} | ⚡ Performance: ${avgTime.toFixed(1)}ms`;
            }

            // Fehlerbehandlung
            handleError(context, error) {
                console.error(`❌ Fehler in ${context}:`, error);
                this.state.statistics.errors++;
                
                const errorBoundary = document.getElementById('errorBoundary');
                const errorMessage = document.getElementById('errorMessage');
                
                errorMessage.textContent = `${context}: ${error.message}`;
                errorBoundary.style.display = 'block';
                
                // Auto-Hide nach 5 Sekunden
                setTimeout(() => {
                    errorBoundary.style.display = 'none';
                }, 5000);
            }

            // Audio-Funktionen mit erweiterten Features
            async initAudio() {
                try {
                    if (!this.state.audioContext) {
                        this.state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    if (this.state.audioContext.state === 'suspended') {
                        await this.state.audioContext.resume();
                    }
                    
                    this.updateAudioLatency();
                } catch (error) {
                    this.handleError('Audio-Initialisierung', error);
                }
            }

            updateAudioLatency() {
                if (this.state.audioContext) {
                    const latency = this.state.audioContext.baseLatency * 1000;
                    document.getElementById('audioLatency').textContent = `${latency.toFixed(1)}ms`;
                }
            }

            createAdvancedOscillator(frequency, duration = 2.0, waveform = 'sine') {
                const oscillator = this.state.audioContext.createOscillator();
                const gainNode = this.state.audioContext.createGain();
                const filterNode = this.state.audioContext.createBiquadFilter();
                
                // Audio-Pipeline: Oscillator -> Filter -> Gain -> Destination
                oscillator.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(this.state.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.state.audioContext.currentTime);
                oscillator.type = waveform;
                
                // Erweiterte Envelope
                const fadeTime = 0.1;
                const sustainLevel = this.config.volume * 0.15;
                
                gainNode.gain.setValueAtTime(0, this.state.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(sustainLevel, this.state.audioContext.currentTime + fadeTime);
                gainNode.gain.setValueAtTime(sustainLevel, this.state.audioContext.currentTime + duration - fadeTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.state.audioContext.currentTime + duration);
                
                // Filter-Modulation für reicheren Klang
                filterNode.type = 'lowpass';
                filterNode.frequency.setValueAtTime(frequency * 4, this.state.audioContext.currentTime);
                filterNode.Q.setValueAtTime(1, this.state.audioContext.currentTime);
                
                return { oscillator, gainNode, filterNode };
            }

            async playFrequencies(frequencies, duration = 2.0, label = "", waveform = 'sine') {
                if (this.state.isPlaying) return;
                
                await this.initAudio();
                this.state.isPlaying = true;
                
                const startTime = performance.now();
                console.log(`🎵 Spiele ${label}:`, frequencies.map(f => f.toFixed(1)));
                
                try {
                    const oscillators = frequencies.map(freq => 
                        this.createAdvancedOscillator(freq, duration, waveform)
                    );
                    
                    oscillators.forEach(({ oscillator }) => {
                        oscillator.start(this.state.audioContext.currentTime);
                        oscillator.stop(this.state.audioContext.currentTime + duration);
                    });
                    
                    return new Promise(resolve => {
                        setTimeout(() => {
                            this.state.isPlaying = false;
                            const endTime = performance.now();
                            this.updatePerformanceMetrics('audioPlayback', endTime - startTime);
                            resolve();
                        }, duration * 1000 + 100);
                    });
                } catch (error) {
                    this.state.isPlaying = false;
                    this.handleError('Audio-Wiedergabe', error);
                }
            }

            // Erweiterte Sequenz-Wiedergabe
            async playSequence() {
                this.updateStatus('statusSequence', 'playing');
                
                const sequences = [
                    { frequencies: this.state.originalFrequencies, label: "Original", duration: 1.0 },
                    { frequencies: this.state.differenceFrequencies, label: "Differenztöne", duration: 1.0 },
                    { frequencies: this.state.reconstructedFrequencies, label: "Rekonstruiert", duration: 1.0 }
                ];
                
                for (const seq of sequences) {
                    await this.playFrequencies(seq.frequencies, seq.duration, seq.label);
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                this.updateStatus('statusSequence', 'ready');
            }

            // System-Initialisierung
            async initializeSystem() {
                console.log("🚀 Initialisiere T0-System 100%...");
                
                try {
                    // Datenbank generieren
                    this.generateSignatureDatabase();
                    
                    // UI initialisieren
                    this.initializeUI();
                    
                    // Performance-Monitoring starten
                    this.startPerformanceMonitoring();
                    
                    // System-Status aktualisieren
                    this.updateSystemStatus();
                    
                    console.log("✅ T0-System vollständig initialisiert");
                } catch (error) {
                    this.handleError('System-Initialisierung', error);
                }
            }

            initializeUI() {
                // Akkord-Grid erstellen
                this.createChordGrid();
                
                // Event-Listener
                this.setupEventListeners();
                
                // Adaptive Parameter
                this.setupAdaptiveControls();
            }

            createChordGrid() {
                const grid = document.getElementById('chordGrid');
                grid.innerHTML = '';
                
                // Gruppiere Akkorde nach Typ
                const groups = {
                    'Grundakkorde': ['Major', 'Minor', 'Diminished', 'Augmented', 'Sus2', 'Sus4'],
                    'Septakkorde': ['Dom7', 'Maj7', 'Min7', 'Dim7', 'HalfDim7', 'Aug7', 'MinMaj7'],
                    'Erweiterte': ['Add9', 'Add11', 'Add13', 'Maj9', 'Min9', 'Dom9', 'Maj11', 'Min11', 'Dom11'],
                    '13th-Akkorde': ['Maj13', 'Min13', 'Dom13'],
                    'Alterierte': ['Dom7b5', 'Dom7#5', 'Dom7b9', 'Dom7#9', 'Dom7#11', 'Dom7b13'],
                    'Spezielle': ['Quartal', 'Quintal', 'Cluster', 'Polychord', 'Min6', 'Maj6', '69', 'Alt']
                };

                Object.entries(groups).forEach(([groupName, chords]) => {
                    const groupDiv = document.createElement('div');
                    groupDiv.innerHTML = `<h4 style="grid-column: 1/-1; color: var(--primary-blue); margin: 10px 0 5px 0;">${groupName}</h4>`;
                    grid.appendChild(groupDiv);

                    chords.forEach(chordType => {
                        if (this.chordLibrary.has(chordType)) {
                            const button = document.createElement('button');
                            button.className = 'chord-button';
                            button.textContent = chordType;
                            button.onclick = () => this.selectChord(chordType);
                            grid.appendChild(button);
                        }
                    });
                });
            }

            setupEventListeners() {
                // Adaptive Parameter
                document.getElementById('toleranceSlider').addEventListener('input', (e) => {
                    this.config.tolerance = parseFloat(e.target.value);
                    document.getElementById('toleranceValue').textContent = `${this.config.tolerance} Hz`;
                    this.regenerateSignaturesIfNeeded();
                });

                document.getElementById('volumeSlider').addEventListener('input', (e) => {
                    this.config.volume = e.target.value / 100;
                    document.getElementById('volumeValue').textContent = `${e.target.value}%`;
                });

                document.getElementById('harmonicSlider').addEventListener('input', (e) => {
                    this.config.maxHarmonic = parseInt(e.target.value);
                    document.getElementById('harmonicValue').textContent = this.config.maxHarmonic;
                    this.regenerateSignaturesIfNeeded();
                });

                document.getElementById('thresholdSlider').addEventListener('input', (e) => {
                    this.config.recognitionThreshold = e.target.value / 100;
                    document.getElementById('thresholdValue').textContent = `${e.target.value}%`;
                });

                // Audio-Kontrollen
                document.getElementById('playOriginal').onclick = () => this.playOriginal();
                document.getElementById('playDifferences').onclick = () => this.playDifferences();
                document.getElementById('playReconstructed').onclick = () => this.playReconstructed();
                document.getElementById('playComparison').onclick = () => this.playComparison();
                document.getElementById('playSequence').onclick = () => this.playSequence();

                // Erweiterte Tests
                document.getElementById('runComprehensiveTest').onclick = () => this.runComprehensiveTest();
                document.getElementById('resetSystem').onclick = () => this.resetSystem();
                document.getElementById('floatingAction').onclick = () => this.showAdvancedOptions();
            }

            setupAdaptiveControls() {
                // Adaptive Parameter-Anpassung basierend auf Performance
                setInterval(() => {
                    if (this.config.adaptiveParameters) {
                        this.adaptParameters();
                    }
                }, 5000);
            }

            adaptParameters() {
                const avgCalcTime = this.getAverageCalculationTime();
                
                if (avgCalcTime > 100) { // Zu langsam
                    this.config.maxHarmonic = Math.max(1, this.config.maxHarmonic - 1);
                    console.log("🔄 Adaptive Anpassung: Harmonische reduziert");
                } else if (avgCalcTime < 20 && this.config.maxHarmonic < 5) { // Zu schnell, kann erweitert werden
                    this.config.maxHarmonic++;
                    console.log("🔄 Adaptive Anpassung: Harmonische erweitert");
                }
                
                // UI aktualisieren
                document.getElementById('harmonicSlider').value = this.config.maxHarmonic;
                document.getElementById('harmonicValue').textContent = this.config.maxHarmonic;
            }

            getAverageCalculationTime() {
                const calcs = this.state.performance.calculations;
                if (calcs.length === 0) return 0;
                
                return calcs.reduce((sum, calc) => sum + calc.duration, 0) / calcs.length;
            }

            regenerateSignaturesIfNeeded() {
                // Regeneriere Signaturen bei wichtigen Parameter-Änderungen
                clearTimeout(this.regenerateTimer);
                this.regenerateTimer = setTimeout(() => {
                    this.generateSignatureDatabase();
                }, 1000);
            }

            async selectChord(chordName) {
                try {
                    // UI Update
                    document.querySelectorAll('.chord-button').forEach(btn => {
                        btn.classList.remove('selected');
                        if (btn.textContent === chordName) btn.classList.add('selected');
                    });

                    this.state.currentChord = chordName;
                    this.state.originalFrequencies = [...this.chordLibrary.get(chordName)];

                    // Status auf Processing setzen
                    this.updateAllStatus('processing');

                    // T0-Berechnung mit Performance-Monitoring
                    const startTime = performance.now();
                    
                    this.state.differenceFrequencies = this.calculateDifferenceTones(this.state.originalFrequencies);
                    const reconstructionResult = this.reconstructFromDifferences(this.state.differenceFrequencies);
                    this.state.reconstructedFrequencies = reconstructionResult.frequencies;

                    const endTime = performance.now();
                    this.updatePerformanceMetrics('fullCalculation', endTime - startTime);

                    // UI Updates
                    this.enableAllButtons();
                    this.updateAnalysisDisplay();
                    this.updateCalculationDetails();
                    this.updateTestResults(reconstructionResult);
                    this.updateStatistics();

                    // Status auf Ready setzen
                    this.updateAllStatus('ready');
                    
                    console.log(`✅ Akkord ${chordName} analysiert`);
                } catch (error) {
                    this.handleError('Akkord-Auswahl', error);
                    this.updateAllStatus('error');
                }
            }

            updateAllStatus(status) {
                ['statusOriginal', 'statusDifferences', 'statusReconstructed', 'statusComparison', 'statusSequence']
                    .forEach(id => this.updateStatus(id, status));
            }

            updateStatus(elementId, status) {
                const el = document.getElementById(elementId);
                if (el) {
                    el.className = `status-indicator status-${status}`;
                }
            }

            enableAllButtons() {
                document.querySelectorAll('.play-button').forEach(btn => {
                    btn.disabled = false;
                });
            }

            // Erweiterte Analyse-Anzeige
            updateAnalysisDisplay() {
                // Original
                document.getElementById('originalAnalysis').innerHTML = `
                    <div class="frequency-list">
                        ${this.state.originalFrequencies.map(f => 
                            `<span class="frequency-tag">${f.toFixed(1)} Hz</span>`
                        ).join('')}
                    </div>
                    <p><strong>Akkord:</strong> ${this.state.currentChord}</p>
                    <p><strong>Töne:</strong> ${this.state.originalFrequencies.length}</p>
                    <p><strong>Frequenzbereich:</strong> ${this.state.originalFrequencies[0].toFixed(1)} - ${this.state.originalFrequencies[this.state.originalFrequencies.length-1].toFixed(1)} Hz</p>
                `;

                // Rekonstruktion
                const accuracy = this.calculateAccuracy();
                document.getElementById('reconstructionAnalysis').innerHTML = `
                    <div class="frequency-list">
                        ${this.state.reconstructedFrequencies.map(f => 
                            `<span class="frequency-tag reconstructed-tag">${f.toFixed(1)} Hz</span>`
                        ).join('')}
                    </div>
                    <p><strong>Rekonstruiert:</strong> ${this.state.reconstructedFrequencies.length} Töne</p>
                    <p><strong>Genauigkeit:</strong> ${accuracy.toFixed(1)}%</p>
                    <p><strong>Komplexität:</strong> ${this.calculateComplexity(this.state.reconstructedFrequencies).toFixed(1)}</p>
                `;
            }

            updateCalculationDetails() {
                const signature = this.computeT0Signature(this.state.originalFrequencies);
                
                document.getElementById('calculationDetails').innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div>
                            <h5>🔢 Frequenz-Analyse:</h5>
                            <p><strong>Original-Frequenzen:</strong></p>
                            <div class="frequency-list">
                                ${this.state.originalFrequencies.map(f => 
                                    `<span class="frequency-tag">${f.toFixed(1)} Hz</span>`
                                ).join('')}
                            </div>
                            
                            <p><strong>Alle Differenztöne (${this.state.differenceFrequencies.length}):</strong></p>
                            <div class="frequency-list" style="max-height: 100px; overflow-y: auto;">
                                ${this.state.differenceFrequencies.map(f => 
                                    `<span class="frequency-tag difference-tag">${f} Hz</span>`
                                ).join('')}
                            </div>
                        </div>
                        
                        <div>
                            <h5>🎯 T0-Signatur:</h5>
                            <p><strong>Primäre Differenztöne:</strong></p>
                            <div class="frequency-list">
                                ${signature.primaryDifferences.map(f => 
                                    `<span class="frequency-tag difference-tag">${f} Hz</span>`
                                ).join('')}
                            </div>
                            
                            <p><strong>Signatur-Hash:</strong></p>
                            <code style="background: rgba(0,0,0,0.5); padding: 5px; border-radius: 5px; font-size: 11px;">
                                ${signature.hash}
                            </code>
                            
                            <p><strong>Metadaten:</strong></p>
                            <ul style="font-size: 12px; margin-left: 20px;">
                                <li>Ton-Anzahl: ${signature.metadata.noteCount}</li>
                                <li>Frequenzbereich: ${signature.metadata.frequencyRange[0].toFixed(1)} - ${signature.metadata.frequencyRange[1].toFixed(1)} Hz</li>
                                <li>Komplexität: ${signature.metadata.complexity.toFixed(1)}</li>
                            </ul>
                        </div>
                    </div>
                `;
            }

            updateTestResults(reconstructionResult) {
                const analysis = this.analyzeReconstruction();
                
                document.getElementById('testResults').innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div>
                            <h5>📊 Rekonstruktions-Analyse:</h5>
                            <p>• <strong>Methode:</strong> ${reconstructionResult.method}</p>
                            <p>• <strong>Konfidenz:</strong> ${(reconstructionResult.confidence * 100).toFixed(1)}%</p>
                            <p>• <strong>Erkannter Akkord:</strong> ${reconstructionResult.chordName}</p>
                            <p>• <strong>Frequenz-Genauigkeit:</strong> ${analysis.accuracy.toFixed(1)}%</p>
                            <p>• <strong>Qualitätsbewertung:</strong> ${analysis.quality}</p>
                            <p>• <strong>Ton-Matching:</strong> ${this.state.originalFrequencies.length} → ${this.state.reconstructedFrequencies.length}</p>
                        </div>
                        
                        <div>
                            <h5>🎧 Erwartete Hör-Erfahrung:</h5>
                            <p style="color: ${analysis.isIdentical ? 'var(--success)' : analysis.accuracy > 70 ? 'var(--warning)' : 'var(--error)'}">
                                ${analysis.isIdentical 
                                    ? '✅ IDENTISCH: Kein hörbarer Unterschied erwartet'
                                    : analysis.accuracy > 70
                                    ? '⚠️ ÄHNLICH: Leichte Unterschiede möglich'
                                    : '❌ UNTERSCHIEDLICH: Deutliche Abweichungen hörbar'
                                }
                            </p>
                            <p><strong>Harmonie-Erhaltung:</strong> ${analysis.harmonyPreserved ? '✅' : '❌'}</p>
                            <p><strong>Klangfarbe:</strong> ${analysis.timbreMatch ? 'Ähnlich' : 'Unterschiedlich'}</p>
                            <p><strong>Dissonanz-Level:</strong> ${analysis.dissonanceLevel}</p>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 15px; background: rgba(${analysis.isIdentical ? '16,185,129' : analysis.accuracy > 70 ? '245,158,11' : '239,68,68'},0.1); border-radius: 10px;">
                        <strong>🎯 System-Empfehlung:</strong> 
                        ${analysis.isIdentical 
                            ? 'PERFEKTE REKONSTRUKTION - Das T0-System hat den Akkord vollständig erfasst!'
                            : analysis.accuracy > 70
                            ? 'GUTE REKONSTRUKTION - Haupt-Harmonien erkannt, kleine Abweichungen normal.'
                            : 'VERBESSERUNG MÖGLICH - Akkord wurde nur teilweise erfasst, Parameter anpassen empfohlen.'
                        }
                    </div>
                `;
            }

            // Umfassende Rekonstruktions-Analyse
            analyzeReconstruction() {
                const accuracy = this.calculateFrequencyAccuracy();
                const harmonyPreserved = this.analyzeHarmonyPreservation();
                const timbreMatch = this.analyzeTimbreMatch();
                const dissonanceLevel = this.calculateDissonanceLevel();
                
                return {
                    accuracy,
                    quality: accuracy > 95 ? 'Perfekt' : accuracy > 85 ? 'Exzellent' : accuracy > 70 ? 'Sehr gut' : accuracy > 50 ? 'Gut' : 'Mangelhaft',
                    isIdentical: accuracy > 95,
                    harmonyPreserved,
                    timbreMatch,
                    dissonanceLevel
                };
            }

            calculateFrequencyAccuracy() {
                if (this.state.originalFrequencies.length === 0) return 0;
                
                let matches = 0;
                this.state.originalFrequencies.forEach(origFreq => {
                    if (this.state.reconstructedFrequencies.some(reconFreq => 
                        Math.abs(origFreq - reconFreq) <= this.config.tolerance)) {
                        matches++;
                    }
                });
                
                return (matches / this.state.originalFrequencies.length) * 100;
            }

            analyzeHarmonyPreservation() {
                // Prüfe ob die Grundharmonie erhalten bleibt
                const originalIntervals = this.calculateIntervals(this.state.originalFrequencies);
                const reconstructedIntervals = this.calculateIntervals(this.state.reconstructedFrequencies);
                
                if (originalIntervals.length === 0) return true;
                
                let preservedIntervals = 0;
                originalIntervals.forEach(interval => {
                    if (reconstructedIntervals.some(reconInterval => 
                        Math.abs(interval - reconInterval) <= 0.1)) {
                        preservedIntervals++;
                    }
                });
                
                return preservedIntervals / originalIntervals.length > 0.7;
            }

            calculateIntervals(frequencies) {
                if (frequencies.length < 2) return [];
                
                const intervals = [];
                for (let i = 1; i < frequencies.length; i++) {
                    intervals.push(frequencies[i] / frequencies[0]);
                }
                return intervals;
            }

            analyzeTimbreMatch() {
                // Vereinfachte Klangfarben-Analyse basierend auf Frequenzverteilung
                const originalSpread = this.calculateFrequencySpread(this.state.originalFrequencies);
                const reconstructedSpread = this.calculateFrequencySpread(this.state.reconstructedFrequencies);
                
                return Math.abs(originalSpread - reconstructedSpread) < 0.3;
            }

            calculateFrequencySpread(frequencies) {
                if (frequencies.length < 2) return 0;
                return (Math.max(...frequencies) - Math.min(...frequencies)) / Math.min(...frequencies);
            }

            calculateDissonanceLevel() {
                // Berechne Dissonanz-Level basierend auf Frequenz-Verhältnissen
                let dissonance = 0;
                
                for (let i = 0; i < this.state.reconstructedFrequencies.length; i++) {
                    for (let j = i + 1; j < this.state.reconstructedFrequencies.length; j++) {
                        const ratio = this.state.reconstructedFrequencies[j] / this.state.reconstructedFrequencies[i];
                        dissonance += this.calculateDissonanceForRatio(ratio);
                    }
                }
                
                const avgDissonance = dissonance / Math.max(1, this.state.reconstructedFrequencies.length * (this.state.reconstructedFrequencies.length - 1) / 2);
                
                return avgDissonance < 0.2 ? 'Niedrig' : avgDissonance < 0.5 ? 'Mittel' : 'Hoch';
            }

            calculateDissonanceForRatio(ratio) {
                // Vereinfachte Dissonanz-Berechnung basierend auf harmonischen Verhältnissen
                const simpleRatios = [1, 1.25, 1.33, 1.5, 1.67, 2]; // Perfekte Verhältnisse
                
                let minDissonance = 1;
                simpleRatios.forEach(simpleRatio => {
                    const dissonance = Math.abs(ratio - simpleRatio) / simpleRatio;
                    minDissonance = Math.min(minDissonance, dissonance);
                });
                
                return minDissonance;
            }

            calculateAccuracy() {
                return this.calculateFrequencyAccuracy();
            }

            updateStatistics() {
                this.state.statistics.testsRun++;
                const accuracy = this.calculateAccuracy();
                
                if (accuracy > 95) {
                    this.state.statistics.perfectMatches++;
                } else if (accuracy > 70) {
                    this.state.statistics.goodMatches++;
                }
                
                this.updateSystemStatus();
            }

            updateSystemStatus() {
                const stats = this.state.statistics;
                const successRate = stats.testsRun > 0 ? 
                    ((stats.perfectMatches + stats.goodMatches) / stats.testsRun * 100).toFixed(1) : 100;
                
                document.getElementById('chordLibrarySize').textContent = `${this.chordLibrary.size} Akkorde`;
                document.getElementById('recognitionRate').textContent = `${successRate}%`;
                document.getElementById('accuracy').textContent = `${successRate}%`;
                
                // Performance-Status
                const avgTime = this.getAverageCalculationTime();
                const performanceStatus = avgTime < 20 ? 'Exzellent' : avgTime < 50 ? 'Gut' : 'Langsam';
                document.getElementById('performanceStatus').textContent = performanceStatus;
            }

            // Audio-Wiedergabe-Funktionen
            async playOriginal() {
                this.updateStatus('statusOriginal', 'playing');
                await this.playFrequencies(this.state.originalFrequencies, 2.0, "Original");
                this.updateStatus('statusOriginal', 'ready');
            }

            async playDifferences() {
                this.updateStatus('statusDifferences', 'playing');
                await this.playFrequencies(this.state.differenceFrequencies, 2.0, "Differenztöne", 'triangle');
                this.updateStatus('statusDifferences', 'ready');
            }

            async playReconstructed() {
                this.updateStatus('statusReconstructed', 'playing');
                await this.playFrequencies(this.state.reconstructedFrequencies, 2.0, "Rekonstruiert");
                this.updateStatus('statusReconstructed', 'ready');
            }

            async playComparison() {
                this.updateStatus('statusComparison', 'playing');
                
                // Original
                await this.playFrequencies(this.state.originalFrequencies, 1.5, "Original");
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Rekonstruiert
                await this.playFrequencies(this.state.reconstructedFrequencies, 1.5, "Rekonstruiert");
                
                this.updateStatus('statusComparison', 'ready');
            }

            // Umfassender Systemtest
            async runComprehensiveTest() {
                console.log("🧪 Starte umfassenden T0-Systemtest...");
                
                const progressBar = document.getElementById('testProgress');
                const testButton = document.getElementById('runComprehensiveTest');
                testButton.disabled = true;
                
                const results = [];
                const totalTests = Math.min(50, this.chordLibrary.size); // Begrenze Tests
                let currentTest = 0;
                
                const chordNames = Array.from(this.chordLibrary.keys()).slice(0, totalTests);
                
                for (const chordName of chordNames) {
                    try {
                        const frequencies = this.chordLibrary.get(chordName);
                        const signature = this.computeT0Signature(frequencies);
                        const reconstructionResult = this.reconstructFromDifferences(signature.allDifferences);
                        const analysis = {
                            accuracy: this.calculateFrequencyAccuracyForFreqs(frequencies, reconstructionResult.frequencies),
                            confidence: reconstructionResult.confidence,
                            method: reconstructionResult.method
                        };
                        
                        results.push({
                            chord: chordName,
                            ...analysis,
                            quality: analysis.accuracy > 95 ? 'Perfekt' : analysis.accuracy > 85 ? 'Exzellent' : analysis.accuracy > 70 ? 'Gut' : 'Mangelhaft',
                            isIdentical: analysis.accuracy > 95
                        });
                        
                        currentTest++;
                        const progress = (currentTest / totalTests) * 100;
                        progressBar.style.width = `${progress}%`;
                        
                        // Yield für UI-Updates
                        if (currentTest % 5 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                        
                    } catch (error) {
                        console.error(`Test für ${chordName} fehlgeschlagen:`, error);
                        this.state.statistics.errors++;
                    }
                }
                
                this.displayComprehensiveResults(results);
                testButton.disabled = false;
                progressBar.style.width = '0%';
            }

            calculateFrequencyAccuracyForFreqs(original, reconstructed) {
                if (original.length === 0) return 0;
                
                let matches = 0;
                original.forEach(origFreq => {
                    if (reconstructed.some(reconFreq => 
                        Math.abs(origFreq - reconFreq) <= this.config.tolerance)) {
                        matches++;
                    }
                });
                
                return (matches / original.length) * 100;
            }

            displayComprehensiveResults(results) {
                const perfectMatches = results.filter(r => r.isIdentical).length;
                const goodMatches = results.filter(r => r.accuracy > 70 && !r.isIdentical).length;
                const totalTests = results.length;
                
                const perfectRate = (perfectMatches / totalTests * 100).toFixed(1);
                const successRate = ((perfectMatches + goodMatches) / totalTests * 100).toFixed(1);
                
                // Gruppiere Ergebnisse nach Qualität
                const byQuality = {
                    'Perfekt': results.filter(r => r.quality === 'Perfekt'),
                    'Exzellent': results.filter(r => r.quality === 'Exzellent'),
                    'Gut': results.filter(r => r.quality === 'Gut'),
                    'Mangelhaft': results.filter(r => r.quality === 'Mangelhaft')
                };
                
                document.getElementById('statisticalAnalysis').innerHTML = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                        <div style="background: rgba(16,185,129,0.2); padding: 15px; border-radius: 10px; text-align: center;">
                            <h4>✅ Perfekte Erkennungen</h4>
                            <div style="font-size: 24px; font-weight: bold;">${perfectMatches}/${totalTests}</div>
                            <div style="font-size: 18px; color: var(--success);">${perfectRate}%</div>
                        </div>
                        <div style="background: rgba(245,158,11,0.2); padding: 15px; border-radius: 10px; text-align: center;">
                            <h4>⚠️ Gesamt-Erfolgsrate</h4>
                            <div style="font-size: 24px; font-weight: bold;">${perfectMatches + goodMatches}/${totalTests}</div>
                            <div style="font-size: 18px; color: var(--warning);">${successRate}%</div>
                        </div>
                        <div style="background: rgba(139,92,246,0.2); padding: 15px; border-radius: 10px; text-align: center;">
                            <h4>🧠 Durchschnittliche Konfidenz</h4>
                            <div style="font-size: 24px; font-weight: bold;">${(results.reduce((sum, r) => sum + r.confidence, 0) / results.length * 100).toFixed(1)}%</div>
                        </div>
                        <div style="background: rgba(68,136,255,0.2); padding: 15px; border-radius: 10px; text-align: center;">
                            <h4>⚡ Performance</h4>
                            <div style="font-size: 24px; font-weight: bold;">${this.getAverageCalculationTime().toFixed(1)}ms</div>
                            <div style="font-size: 14px;">Durchschnitt</div>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div>
                            <h5>📊 Qualitäts-Verteilung:</h5>
                            ${Object.entries(byQuality).map(([quality, items]) => `
                                <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.05); margin: 5px 0; border-radius: 5px;">
                                    <span>${quality}</span>
                                    <span style="color: var(--primary-green);">${items.length} (${(items.length/totalTests*100).toFixed(1)}%)</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div>
                            <h5>🎯 Methoden-Verteilung:</h5>
                            ${Object.entries(this.groupBy(results, 'method')).map(([method, items]) => `
                                <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.05); margin: 5px 0; border-radius: 5px;">
                                    <span>${method}</span>
                                    <span style="color: var(--primary-blue);">${items.length} (${(items.length/totalTests*100).toFixed(1)}%)</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                        <h5>📝 Detaillierte Testergebnisse:</h5>
                        <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr; gap: 10px; font-size: 12px; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.3); font-weight: bold;">
                            <div>Akkord</div>
                            <div>Qualität</div>
                            <div>Genauigkeit</div>
                            <div>Methode</div>
                        </div>
                        ${results.slice(0, 20).map(result => `
                            <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr; gap: 10px; padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 11px;">
                                <div>${result.chord}</div>
                                <div style="color: ${result.isIdentical ? 'var(--success)' : result.accuracy > 70 ? 'var(--warning)' : 'var(--error)'}">
                                    ${result.quality}
                                </div>
                                <div>${result.accuracy.toFixed(1)}%</div>
                                <div>${result.method}</div>
                            </div>
                        `).join('')}
                        ${results.length > 20 ? `<div style="text-align: center; padding: 10px; opacity: 0.7;">... und ${results.length - 20} weitere</div>` : ''}
                    </div>
                    
                    <div style="margin-top: 20px; padding: 20px; background: rgba(${perfectRate > 90 ? '16,185,129' : successRate > 80 ? '245,158,11' : '239,68,68'},0.1); border-radius: 15px;">
                        <h5>🎯 System-Bewertung:</h5>
                        <p><strong>Gesamt-Performance:</strong> ${
                            perfectRate > 90 ? 'EXZELLENT - T0-System funktioniert hervorragend!' :
                            successRate > 80 ? 'SEHR GUT - Hohe Erkennungsrate mit geringen Abweichungen.' :
                            successRate > 60 ? 'GUT - Solide Performance, Optimierungspotential vorhanden.' :
                            'VERBESSERUNGSBEDÜRFTIG - Parameter-Tuning oder Algorithmus-Anpassungen empfohlen.'
                        }</p>
                        
                        <p><strong>Empfehlungen:</strong></p>
                        <ul style="margin-left: 20px; font-size: 14px;">
                            ${perfectRate < 80 ? '<li>Toleranz-Parameter anpassen für bessere Fuzzy-Matching-Ergebnisse</li>' : ''}
                            ${this.getAverageCalculationTime() > 50 ? '<li>Harmonische-Tiefe reduzieren für bessere Performance</li>' : ''}
                            ${successRate < 70 ? '<li>Signatur-Datenbank erweitern oder Algorithmus überarbeiten</li>' : ''}
                            <li>Kontinuierliche Tests mit verschiedenen Parameter-Kombinationen durchführen</li>
                        </ul>
                    </div>
                `;
                
                console.log(`🎯 Umfassender Test abgeschlossen: ${successRate}% Erfolgsrate`);
            }

            groupBy(array, key) {
                return array.reduce((groups, item) => {
                    const group = item[key];
                    groups[group] = groups[group] || [];
                    groups[group].push(item);
                    return groups;
                }, {});
            }

            // System-Verwaltung
            resetSystem() {
                console.log("🔄 System wird zurückgesetzt...");
                
                // Zustand zurücksetzen
                this.state.currentChord = null;
                this.state.originalFrequencies = [];
                this.state.differenceFrequencies = [];
                this.state.reconstructedFrequencies = [];
                this.state.cache.clear();
                this.state.statistics = {
                    testsRun: 0,
                    perfectMatches: 0,
                    goodMatches: 0,
                    errors: 0
                };
                
                // UI zurücksetzen
                document.querySelectorAll('.chord-button').forEach(btn => {
                    btn.classList.remove('selected');
                });
                
                document.querySelectorAll('.play-button').forEach(btn => {
                    btn.disabled = true;
                });
                
                this.updateAllStatus('ready');
                
                // Displays zurücksetzen
                document.getElementById('originalAnalysis').innerHTML = '<p>Wähle einen Akkord aus der erweiterten Bibliothek...</p>';
                document.getElementById('reconstructionAnalysis').innerHTML = '<p>Warte auf Berechnung...</p>';
                document.getElementById('calculationDetails').innerHTML = '<p>Detaillierte Berechnungen werden hier angezeigt...</p>';
                document.getElementById('testResults').innerHTML = '<p>Führe Tests durch um erweiterte Ergebnisse zu sehen...</p>';
                
                // Fehler-Boundary verstecken
                document.getElementById('errorBoundary').style.display = 'none';
                
                console.log("✅ System erfolgreich zurückgesetzt");
            }

            showAdvancedOptions() {
                document.getElementById('modalTitle').textContent = '⚙️ Erweiterte Systemoptionen';
                document.getElementById('modalContent').innerHTML = `
                    <div style="display: grid; gap: 20px;">
                        <div>
                            <h4>🎛️ Algorithmus-Parameter</h4>
                            <div style="display: grid; gap: 10px;">
                                <label>
                                    Cache-Größe: <input type="number" id="cacheSize" value="${this.config.cacheSize}" min="100" max="5000" step="100">
                                </label>
                                <label>
                                    Performance-Monitoring: <input type="checkbox" id="perfMonitoring" ${this.config.performanceMonitoring ? 'checked' : ''}>
                                </label>
                                <label>
                                    Adaptive Parameter: <input type="checkbox" id="adaptiveParams" ${this.config.adaptiveParameters ? 'checked' : ''}>
                                </label>
                                <label>
                                    Fehler-Recovery: <input type="checkbox" id="errorRecovery" ${this.config.errorRecovery ? 'checked' : ''}>
                                </label>
                            </div>
                        </div>
                        
                        <div>
                            <h4>📊 System-Statistiken</h4>
                            <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px;">
                                <p>Laufzeit: ${this.calculateUptime()}</p>
                                <p>Cache-Größe: ${this.state.cache.size} Einträge</p>
                                <p>Speicher-Nutzung: ${this.getMemoryUsage().toFixed(1)} MB</p>
                                <p>Durchgeführte Tests: ${this.state.statistics.testsRun}</p>
                                <p>Fehler: ${this.state.statistics.errors}</p>
                            </div>
                        </div>
                        
                        <div>
                            <h4>🔧 Aktionen</h4>
                            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                <button class="play-button" onclick="t0System.clearCache()">🗑️ Cache leeren</button>
                                <button class="play-button" onclick="t0System.exportResults()">💾 Ergebnisse exportieren</button>
                                <button class="play-button" onclick="t0System.runDiagnostics()">🔍 Diagnose</button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.getElementById('modalOverlay').style.display = 'flex';
            }

            calculateUptime() {
                const uptime = Date.now() - this.startTime;
                const minutes = Math.floor(uptime / 60000);
                const seconds = Math.floor((uptime % 60000) / 1000);
                return `${minutes}m ${seconds}s`;
            }

            getMemoryUsage() {
                return performance.memory ? performance.memory.usedJSHeapSize / 1024 / 1024 : 0;
            }

            clearCache() {
                this.state.cache.clear();
                this.state.performance.cacheHits = 0;
                console.log("🗑️ Cache geleert");
                closeModal();
            }

            exportResults() {
                const results = {
                    version: this.version,
                    timestamp: new Date().toISOString(),
                    statistics: this.state.statistics,
                    configuration: this.config,
                    performance: {
                        averageCalculationTime: this.getAverageCalculationTime(),
                        cacheHits: this.state.performance.cacheHits,
                        memoryUsage: this.getMemoryUsage()
                    }
                };
                
                const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `t0-system-results-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log("💾 Ergebnisse exportiert");
                closeModal();
            }

            runDiagnostics() {
                console.log("🔍 Starte System-Diagnose...");
                
                const diagnostics = {
                    audioContext: this.state.audioContext ? 'Verfügbar' : 'Nicht verfügbar',
                    chordLibrary: `${this.chordLibrary.size} Akkorde`,
                    signatureDatabase: `${this.signatureDatabase.size} Signaturen`,
                    cache: `${this.state.cache.size}/${this.config.cacheSize}`,
                    performance: this.getAverageCalculationTime() < 50 ? 'Gut' : 'Langsam',
                    errors: this.state.statistics.errors === 0 ? 'Keine' : `${this.state.statistics.errors} Fehler`
                };
                
                console.log("📊 Diagnose-Ergebnisse:", diagnostics);
                
                document.getElementById('modalContent').innerHTML = `
                    <h4>🔍 System-Diagnose</h4>
                    <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px;">
                        ${Object.entries(diagnostics).map(([key, value]) => `
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span>${key}:</span>
                                <span style="color: var(--primary-green);">${value}</span>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <h5>System-Status: ${this.state.statistics.errors === 0 ? '✅ Gesund' : '⚠️ Probleme erkannt'}</h5>
                        ${this.state.statistics.errors > 0 ? '<p style="color: var(--error);">Fehler im System-Log überprüfen.</p>' : ''}
                    </div>
                `;
            }

            startPerformanceMonitoring() {
                if (!this.config.performanceMonitoring) return;
                
                this.startTime = Date.now();
                
                setInterval(() => {
                    this.updatePerformanceDisplay();
                }, 2000);
            }
        }

        // Globale Funktionen
        function closeModal() {
            document.getElementById('modalOverlay').style.display = 'none';
        }

        // System initialisieren
        let t0System;
        
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("🚀 Initialisiere T0-System 100%...");
            t0System = new T0AudioSystemComplete();
            
            // Warte auf vollständige Initialisierung
            await new Promise(resolve => setTimeout(resolve, 100));
            
            console.log("✅ T0-System vollständig geladen!");
        });

        // Keyboard-Shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
            }
            
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'r':
                        e.preventDefault();
                        if (t0System) t0System.resetSystem();
                        break;
                    case 't':
                        e.preventDefault();
                        if (t0System) t0System.runComprehensiveTest();
                        break;
                }
            }
        });

        // Error-Recovery
        window.addEventListener('error', (e) => {
            console.error('Globaler Fehler:', e.error);
            if (t0System && t0System.config.errorRecovery) {
                t0System.handleError('Globaler Fehler', e.error);
            }
        });

        // Unhandled Promise Rejections
        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unbehandelte Promise-Rejection:', e.reason);
            if (t0System && t0System.config.errorRecovery) {
                t0System.handleError('Promise-Rejection', new Error(e.reason));
            }
        });
    </script>
</body>
</html>