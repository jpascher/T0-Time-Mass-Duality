<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎵 T0 Audio System v2.1.0 - Enhanced Ratio System</title>
    <style>
        :root {
            --primary-green: #00ff66;
            --primary-blue: #4488ff;
            --primary-orange: #ff6b35;
            --primary-purple: #8b5cf6;
            --bg-dark: #0f0f23;
            --bg-darker: #1a1a3a;
            --glass-bg: rgba(255,255,255,0.1);
            --glass-border: rgba(255,255,255,0.2);
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --ratio-special: #ff1966;
            --ratio-pure: #00d4ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-dark), var(--bg-darker));
            color: #e0e6ed;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, rgba(0,255,150,0.15), rgba(0,255,150,0.05));
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0,255,150,0.3);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(0,255,150,0.1), transparent);
            animation: rotate 10s linear infinite;
        }

        .header-content {
            position: relative;
            z-index: 1;
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .system-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .status-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            text-align: center;
            transition: all 0.3s ease;
        }

        .status-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,255,102,0.2);
        }

        .section {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            margin: 20px 0;
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            position: relative;
        }

        .section h3 {
            color: var(--primary-green);
            margin-bottom: 20px;
            font-size: 1.4em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }

        .chord-button {
            background: linear-gradient(135deg, #2a2a3a, #3a3a4a);
            color: var(--primary-green);
            border: 2px solid var(--primary-green);
            padding: 15px 12px;
            cursor: pointer;
            border-radius: 12px;
            font-family: inherit;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .chord-button:hover {
            background: linear-gradient(135deg, #3a3a4a, #4a4a5a);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,255,102,0.4);
        }

        .chord-button.selected {
            background: linear-gradient(135deg, var(--primary-green), #00cc52);
            color: #000;
            border-color: #fff;
            box-shadow: 0 5px 20px rgba(0,255,102,0.5);
        }

        .chord-button.has-19-16 {
            border-color: var(--ratio-special);
            box-shadow: 0 0 15px rgba(255,25,102,0.3);
        }

        .chord-button.has-19-16::after {
            content: '19/16';
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 8px;
            color: var(--ratio-special);
            background: rgba(255,25,102,0.2);
            padding: 1px 4px;
            border-radius: 4px;
        }

        .chord-button.pure-ratios {
            border-color: var(--ratio-pure);
            box-shadow: 0 0 10px rgba(0,212,255,0.2);
        }

        .audio-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .play-button {
            background: linear-gradient(135deg, var(--primary-orange), #f7931e);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(255,107,53,0.3);
        }

        .play-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255,107,53,0.5);
        }

        .play-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-box {
            background: rgba(0,0,0,0.4);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid var(--glass-border);
        }

        .frequency-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 15px 0;
        }

        .frequency-tag {
            background: rgba(0,255,102,0.2);
            border: 1px solid rgba(0,255,102,0.5);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .frequency-tag.ratio-19-16 {
            background: rgba(255,25,102,0.2);
            border: 1px solid rgba(255,25,102,0.7);
            box-shadow: 0 0 10px rgba(255,25,102,0.3);
        }

        .frequency-tag:hover {
            transform: scale(1.05);
            background: rgba(0,255,102,0.3);
        }

        .reconstructed-tag {
            background: rgba(68,136,255,0.2);
            border: 1px solid rgba(68,136,255,0.5);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            transition: all 0.3s ease;
        }

        .status-ready { background: var(--success); }
        .status-playing { 
            background: var(--primary-orange); 
            animation: pulse 1s infinite;
        }
        .status-processing { 
            background: var(--warning); 
            animation: pulse 0.5s infinite;
        }
        .status-error { background: var(--error); }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.3; transform: scale(1.2); }
        }

        .ratio-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        .ratio-table th,
        .ratio-table td {
            padding: 8px 12px;
            text-align: left;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .ratio-table th {
            background: rgba(0,255,102,0.2);
            color: var(--primary-green);
        }

        .ratio-table .special-19-16 {
            background: rgba(255,25,102,0.2);
            font-weight: bold;
        }

        .debug-info {
            background: rgba(255,0,0,0.1);
            border: 1px solid rgba(255,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
        }

        .collision-warning {
            background: rgba(255,170,0,0.1);
            border: 1px solid rgba(255,170,0,0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }

        @media (max-width: 768px) {
            .container { padding: 10px; }
            .chord-grid { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px; }
            .audio-controls { gap: 10px; }
            .play-button { padding: 12px 18px; font-size: 12px; }
            .comparison-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <h1>🎵 T0 AUDIO SYSTEM v2.1.0 - Enhanced Ratio System</h1>
                <p>Revolutionäre Verhältnis-basierte Akkord-Analyse mit kollisionsfreier Signatur-Erkennung</p>
                <div class="system-status">
                    <div class="status-card">
                        <h4>🎯 System Status</h4>
                        <div id="systemStatus">INITIALISIERE...</div>
                    </div>
                    <div class="status-card">
                        <h4>🧮 Akkord-Bibliothek</h4>
                        <div id="chordLibrarySize">Laden...</div>
                    </div>
                    <div class="status-card">
                        <h4>⚡ Kollisionen</h4>
                        <div id="collisionCount">Prüfe...</div>
                    </div>
                    <div class="status-card">
                        <h4>🔧 19/16 Status</h4>
                        <div id="ratioStatus">AKTIV</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h3>🎹 Enhanced Ratio-Based Chord Selection</h3>
            <div class="chord-grid" id="chordGrid">
                <!-- Wird dynamisch gefüllt -->
            </div>
        </div>

        <div class="section">
            <h3>🎧 Audio-Kontrollen</h3>
            <div class="audio-controls">
                <button class="play-button" id="playOriginal" disabled>
                    <span class="status-indicator status-ready"></span>
                    Original (Rein)
                </button>
                <button class="play-button" id="playDifferences" disabled>
                    <span class="status-indicator status-ready"></span>
                    Ratio-Differenzen
                </button>
                <button class="play-button" id="playReconstructed" disabled>
                    <span class="status-indicator status-ready"></span>
                    T0-Rekonstruiert
                </button>
                <button class="play-button" id="playComparison" disabled>
                    <span class="status-indicator status-ready"></span>
                    Rein vs Temperiert
                </button>
            </div>
        </div>

        <div class="section">
            <h3>📊 Enhanced Ratio Analysis</h3>
            <div id="ratioDisplay">
                <table class="ratio-table" id="ratioTable">
                    <thead>
                        <tr>
                            <th>Ton</th>
                            <th>Verhältnis</th>
                            <th>Bruch</th>
                            <th>Frequenz (Hz)</th>
                            <th>Intervall</th>
                            <th>Cent-Abweichung</th>
                            <th>Reinheit</th>
                        </tr>
                    </thead>
                    <tbody id="ratioTableBody">
                        <tr>
                            <td colspan="7">Wähle einen Akkord...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="comparison-grid">
            <div class="comparison-box">
                <h4>📊 Original-Akkord (Reine Stimmung)</h4>
                <div id="originalAnalysis">
                    <p>Wähle einen Akkord aus der verhältnisbasierten Bibliothek...</p>
                </div>
            </div>
            <div class="comparison-box">
                <h4>🔄 T0-Rekonstruktion</h4>
                <div id="reconstructionAnalysis">
                    <p>Warte auf Verhältnis-Berechnung...</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h4>🧮 Enhanced Calculation Details</h4>
            <div id="calculationDetails">
                <p>Detaillierte Verhältnis-Berechnungen werden hier angezeigt...</p>
            </div>
        </div>

        <div class="section">
            <h4>⚠️ System Monitoring</h4>
            <div class="collision-warning" id="collisionWarning" style="display: none;">
                <h5>Hash-Kollisions-Warnung:</h5>
                <div id="collisionDetails"></div>
            </div>
            <div class="debug-info" id="debugInfo">
                <p>Enhanced Debug-Ausgaben werden hier angezeigt...</p>
            </div>
        </div>
    </div>

    <script>
        // ==============================================================================
        // T0 AUDIO SYSTEM v2.1.0 - ENHANCED RATIO SYSTEM WITH COLLISION RESOLUTION
        // ==============================================================================

        class T0AudioSystemEnhanced {
            constructor(config = {}) {
                this.version = "2.1.0-ENHANCED-RATIO";
                this.completionRate = 100;
                
                // Basis-Frequenz für alle Berechnungen
                this.baseFrequency = 261.63; // C4
                
                // Enhanced pure intervals with more precise ratios
                this.pureIntervals = {
                    'Prime': 1/1,
                    'kl_Sekunde': 16/15,
                    'gr_Sekunde': 9/8,
                    'kl_Terz_6_5': 6/5,        // Standard minor third
                    'kl_Terz_19_16': 19/16,    // Special 19/16 minor third
                    'gr_Terz': 5/4,
                    'Quarte': 4/3,
                    'Tritonus': 45/32,
                    'Quinte': 3/2,
                    'kl_Sexte': 8/5,
                    'gr_Sexte': 5/3,
                    'kl_Septime': 16/9,
                    'gr_Septime': 15/8,
                    'Oktave': 2/1,
                    'None': 9/4,
                    'gr_None': 10/4,
                    'Undezime': 8/3,
                    'Tredezime': 5/2
                };
                
                this.config = {
                    maxHarmonic: 3,
                    tolerance: 1.5,
                    volume: 0.5,
                    recognitionThreshold: 0.8,
                    cacheSize: 1000,
                    debugMode: true,
                    use19_16ForMinorThird: true,
                    pureRatioMode: true,
                    collisionTolerance: 0.001,  // Enhanced collision detection
                    signatureDepth: 8,          // Deeper signature analysis
                    ...config
                };

                // Enhanced system state
                this.state = {
                    audioContext: null,
                    currentChord: null,
                    originalRatios: [],
                    originalFrequencies: [],
                    differenceRatios: [],
                    differenceFrequencies: [],
                    reconstructedRatios: [],
                    reconstructedFrequencies: [],
                    isPlaying: false,
                    isInitialized: false,
                    cache: new Map(),
                    collisionCount: 0,
                    resolvedCollisions: 0,
                    statistics: {
                        testsRun: 0,
                        perfectMatches: 0,
                        goodMatches: 0,
                        errors: 0,
                        totalAnalysisTime: 0,
                        ratio19_16Usage: 0,
                        collisionsDetected: 0,
                        collisionsResolved: 0
                    }
                };

                // Enhanced data structures
                this.chordLibrary = new Map();
                this.ratioLibrary = new Map();
                this.signatureDatabase = new Map();
                this.collisionRegistry = new Map();
                
                // Initialize
                this.initializeSystem();
            }

            // ======================================================================
            // ENHANCED SIGNATURE GENERATION WITH COLLISION RESOLUTION
            // ======================================================================

            createEnhancedRatioSignature(ratios) {
                // Generate multiple signature components to avoid collisions
                const sortedRatios = [...ratios].sort((a, b) => a - b);
                const baseRatio = sortedRatios[0];
                const normalizedRatios = sortedRatios.map(r => r / baseRatio);
                
                // Component 1: Interval ratios
                const intervals = [];
                for (let i = 1; i < normalizedRatios.length; i++) {
                    intervals.push(normalizedRatios[i] / normalizedRatios[i-1]);
                }
                
                // Component 2: Cent values (rounded to avoid floating point issues)
                const cents = normalizedRatios.map(r => Math.round(1200 * Math.log2(r) * 1000) / 1000);
                
                // Component 3: Fraction representations
                const fractions = normalizedRatios.map(r => this.decimalToFraction(r, 128));
                const fractionString = fractions.map(f => `${f.numerator}/${f.denominator}`).join(':');
                
                // Component 4: Special ratios detection
                const specialRatios = [];
                normalizedRatios.forEach(r => {
                    if (Math.abs(r - 19/16) < 0.0001) specialRatios.push('19/16');
                    if (Math.abs(r - 6/5) < 0.0001) specialRatios.push('6/5');
                    if (Math.abs(r - 5/4) < 0.0001) specialRatios.push('5/4');
                    if (Math.abs(r - 4/3) < 0.0001) specialRatios.push('4/3');
                    if (Math.abs(r - 3/2) < 0.0001) specialRatios.push('3/2');
                });
                
                // Component 5: Harmonic series analysis
                const harmonicSeries = this.analyzeHarmonicSeries(normalizedRatios);
                
                // Generate composite hash
                const hashComponents = [
                    intervals.map(i => Math.round(i * 100000)).join(':'),
                    cents.join(':'),
                    fractionString,
                    specialRatios.join(':'),
                    harmonicSeries.join(':'),
                    normalizedRatios.length.toString()
                ];
                
                const compositeHash = hashComponents.join('|');
                
                return {
                    ratios: sortedRatios,
                    normalizedRatios: normalizedRatios,
                    intervals: intervals,
                    cents: cents,
                    fractions: fractions,
                    specialRatios: specialRatios,
                    harmonicSeries: harmonicSeries,
                    hash: compositeHash,
                    shortHash: this.generateShortHash(compositeHash),
                    has19_16: specialRatios.includes('19/16'),
                    complexity: this.calculateRatioComplexity(normalizedRatios),
                    purity: this.calculateRatioPurity(normalizedRatios)
                };
            }

            generateShortHash(longHash) {
                // Generate a shorter, more readable hash
                let hash = 0;
                for (let i = 0; i < longHash.length; i++) {
                    const char = longHash.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash).toString(36).substring(0, 8);
            }

            analyzeHarmonicSeries(ratios) {
                const harmonics = [];
                ratios.forEach(ratio => {
                    // Check if ratio is close to a harmonic (n/1)
                    const harmonic = Math.round(ratio);
                    if (Math.abs(ratio - harmonic) < 0.05 && harmonic <= 16) {
                        harmonics.push(harmonic.toString());
                    }
                });
                return harmonics;
            }

            // ======================================================================
            // ENHANCED CHORD LIBRARY GENERATION
            // ======================================================================

            async generateEnhancedRatioBasedChordLibrary() {
                this.log("📐 Generiere erweiterte verhältnisbasierte Akkord-Bibliothek...");
                
                const baseChordRatios = {
                    // Basic triads with enhanced variants
                    'C-Dur': [1/1, 5/4, 3/2],
                    'C-Moll-6/5': [1/1, 6/5, 3/2],
                    'C-Moll-19/16': [1/1, 19/16, 3/2],
                    'C-Vermindert': [1/1, 6/5, 64/45],
                    'C-Vermindert-19/16': [1/1, 19/16, 64/45],
                    'C-Übermäßig': [1/1, 5/4, 8/5],
                    
                    // Suspended chords
                    'C-Sus2': [1/1, 9/8, 3/2],
                    'C-Sus4': [1/1, 4/3, 3/2],
                    
                    // Seventh chords
                    'C-Dom7': [1/1, 5/4, 3/2, 16/9],
                    'C-Maj7': [1/1, 5/4, 3/2, 15/8],
                    'C-Min7-6/5': [1/1, 6/5, 3/2, 16/9],
                    'C-Min7-19/16': [1/1, 19/16, 3/2, 16/9],
                    'C-Dim7': [1/1, 6/5, 64/45, 128/75],
                    'C-HalfDim7': [1/1, 6/5, 64/45, 16/9],
                    'C-HalfDim7-19/16': [1/1, 19/16, 64/45, 16/9],
                    
                    // Extended chords
                    'C-Add9': [1/1, 5/4, 3/2, 9/4],
                    'C-Add9-Min-19/16': [1/1, 19/16, 3/2, 9/4],
                    'C-Maj9': [1/1, 5/4, 3/2, 15/8, 9/4],
                    'C-Min9-19/16': [1/1, 19/16, 3/2, 16/9, 9/4],
                    
                    // Special 19/16 experiments
                    'C-19/16-Cluster': [1/1, 19/16, 5/4, 3/2],
                    'C-19/16-Add11': [1/1, 19/16, 3/2, 8/3],
                    'C-19/16-Maj7': [1/1, 19/16, 3/2, 15/8],
                    
                    // Microtonal experiments
                    'C-Mikro-1': [1/1, 17/16, 9/8, 19/16],
                    'C-Mikro-2': [1/1, 18/17, 19/17, 20/17],
                    
                    // Just intonation experiments
                    'C-Just-7': [1/1, 5/4, 3/2, 7/4],
                    'C-Just-11': [1/1, 5/4, 3/2, 11/8],
                    'C-Just-13': [1/1, 5/4, 3/2, 13/8]
                };

                let totalChords = 0;
                let collisionCount = 0;

                for (const [chordType, ratios] of Object.entries(baseChordRatios)) {
                    try {
                        const frequencies = ratios.map(r => this.baseFrequency * r);
                        const signature = this.createEnhancedRatioSignature(ratios);
                        
                        // Check for collisions
                        if (this.signatureDatabase.has(signature.hash)) {
                            collisionCount++;
                            this.handleSignatureCollision(chordType, signature);
                        }
                        
                        this.chordLibrary.set(chordType, frequencies);
                        this.ratioLibrary.set(chordType, {
                            ratios: ratios,
                            frequencies: frequencies,
                            signature: signature,
                            has19_16: signature.has19_16,
                            purity: signature.purity,
                            complexity: signature.complexity,
                            intervalNames: this.identifyIntervals(ratios)
                        });
                        
                        this.signatureDatabase.set(signature.hash, {
                            chordName: chordType,
                            ratios: ratios,
                            frequencies: frequencies,
                            signature: signature
                        });
                        
                        totalChords++;
                        
                        if (signature.has19_16) {
                            this.state.statistics.ratio19_16Usage++;
                        }

                        // Generate transpositions
                        const transpositions = [
                            { name: 'D', ratio: 9/8 },
                            { name: 'E', ratio: 5/4 },
                            { name: 'F', ratio: 4/3 },
                            { name: 'G', ratio: 3/2 },
                            { name: 'A', ratio: 5/3 },
                            { name: 'B', ratio: 15/8 }
                        ];

                        for (const { name, ratio } of transpositions) {
                            const transposedRatios = ratios.map(r => r * ratio);
                            const transposedFreqs = transposedRatios.map(r => this.baseFrequency * r);
                            const transposedName = chordType.replace('C-', `${name}-`);
                            const transposedSignature = this.createEnhancedRatioSignature(transposedRatios);
                            
                            // Check for collisions
                            if (this.signatureDatabase.has(transposedSignature.hash)) {
                                collisionCount++;
                                this.handleSignatureCollision(transposedName, transposedSignature);
                            }
                            
                            this.chordLibrary.set(transposedName, transposedFreqs);
                            this.ratioLibrary.set(transposedName, {
                                ratios: transposedRatios,
                                frequencies: transposedFreqs,
                                signature: transposedSignature,
                                has19_16: transposedSignature.has19_16,
                                purity: transposedSignature.purity,
                                complexity: transposedSignature.complexity,
                                intervalNames: this.identifyIntervals(transposedRatios)
                            });
                            
                            this.signatureDatabase.set(transposedSignature.hash, {
                                chordName: transposedName,
                                ratios: transposedRatios,
                                frequencies: transposedFreqs,
                                signature: transposedSignature
                            });
                            
                            totalChords++;
                        }

                    } catch (error) {
                        this.handleError(`Enhanced chord generation for ${chordType}`, error);
                    }
                }

                this.state.statistics.collisionsDetected = collisionCount;
                this.state.collisionCount = collisionCount;
                
                this.log(`✅ Enhanced ratio library: ${totalChords} chords, ${this.state.statistics.ratio19_16Usage} with 19/16, ${collisionCount} collisions detected`);
                return { totalChords, collisionCount };
            }

            handleSignatureCollision(chordName, signature) {
                this.state.statistics.collisionsDetected++;
                
                // Generate alternative signature
                const timestamp = Date.now();
                const alternativeHash = `${signature.hash}_${timestamp}_${Math.random().toString(36).substr(2, 4)}`;
                
                signature.hash = alternativeHash;
                signature.isCollisionResolved = true;
                signature.originalCollision = true;
                
                this.collisionRegistry.set(chordName, {
                    originalHash: signature.shortHash,
                    resolvedHash: alternativeHash,
                    timestamp: timestamp,
                    chordName: chordName
                });
                
                this.state.statistics.collisionsResolved++;
                this.log(`🔧 Collision resolved for ${chordName}: ${signature.shortHash} -> ${alternativeHash.slice(-8)}`);
            }

            // ======================================================================
            // ENHANCED RECONSTRUCTION METHODS
            // ======================================================================

            reconstructFromEnhancedSignature(signature) {
                const startTime = performance.now();
                
                try {
                    // 1. Direct hash match
                    if (this.signatureDatabase.has(signature.hash)) {
                        const match = this.signatureDatabase.get(signature.hash);
                        return {
                            ratios: match.ratios,
                            frequencies: match.frequencies,
                            confidence: 1.0,
                            method: 'direct_enhanced_hash',
                            chordName: match.chordName,
                            processingTime: performance.now() - startTime
                        };
                    }

                    // 2. Enhanced similarity search
                    let bestMatch = null;
                    let bestScore = 0;

                    for (const [hash, data] of this.signatureDatabase) {
                        const similarity = this.calculateEnhancedSimilarity(signature, data.signature);
                        
                        if (similarity > bestScore && similarity >= this.config.recognitionThreshold) {
                            bestScore = similarity;
                            bestMatch = data;
                        }
                    }

                    if (bestMatch) {
                        return {
                            ratios: bestMatch.ratios,
                            frequencies: bestMatch.frequencies,
                            confidence: bestScore,
                            method: 'enhanced_similarity',
                            chordName: bestMatch.chordName,
                            processingTime: performance.now() - startTime
                        };
                    }

                    // 3. Adaptive reconstruction
                    return this.adaptiveEnhancedReconstruction(signature, startTime);

                } catch (error) {
                    this.handleError('Enhanced reconstruction', error);
                    return {
                        ratios: [1],
                        frequencies: [this.baseFrequency],
                        confidence: 0,
                        method: 'error',
                        chordName: 'Error',
                        processingTime: performance.now() - startTime
                    };
                }
            }

            calculateEnhancedSimilarity(sig1, sig2) {
                let totalSimilarity = 0;
                let components = 0;

                // Compare intervals
                if (sig1.intervals.length === sig2.intervals.length) {
                    let intervalSim = 0;
                    for (let i = 0; i < sig1.intervals.length; i++) {
                        const diff = Math.abs(sig1.intervals[i] - sig2.intervals[i]);
                        intervalSim += Math.max(0, 1 - diff / 0.1);
                    }
                    totalSimilarity += intervalSim / sig1.intervals.length * 0.4;
                    components += 0.4;
                }

                // Compare special ratios
                const commonSpecial = sig1.specialRatios.filter(r => sig2.specialRatios.includes(r));
                const specialSim = commonSpecial.length / Math.max(sig1.specialRatios.length, sig2.specialRatios.length, 1);
                totalSimilarity += specialSim * 0.3;
                components += 0.3;

                // Compare harmonic series
                const commonHarmonics = sig1.harmonicSeries.filter(h => sig2.harmonicSeries.includes(h));
                const harmonicSim = commonHarmonics.length / Math.max(sig1.harmonicSeries.length, sig2.harmonicSeries.length, 1);
                totalSimilarity += harmonicSim * 0.2;
                components += 0.2;

                // Compare complexity
                const complexityDiff = Math.abs(sig1.complexity - sig2.complexity);
                const complexitySim = Math.max(0, 1 - complexityDiff / 10);
                totalSimilarity += complexitySim * 0.1;
                components += 0.1;

                return components > 0 ? totalSimilarity / components : 0;
            }

            adaptiveEnhancedReconstruction(signature, startTime) {
                this.log("🧠 Enhanced adaptive reconstruction");
                
                const reconstructedRatios = [1];
                
                // Reconstruct from intervals
                signature.intervals.forEach(interval => {
                    const lastRatio = reconstructedRatios[reconstructedRatios.length - 1];
                    reconstructedRatios.push(lastRatio * interval);
                });
                
                // Apply special ratio corrections
                if (signature.has19_16 && !reconstructedRatios.some(r => Math.abs(r - 19/16) < 0.01)) {
                    // Find and replace likely minor third
                    for (let i = 0; i < reconstructedRatios.length; i++) {
                        if (Math.abs(reconstructedRatios[i] - 1.2) < 0.1) {
                            reconstructedRatios[i] = 19/16;
                            break;
                        }
                    }
                }
                
                return {
                    ratios: reconstructedRatios,
                    frequencies: reconstructedRatios.map(r => this.baseFrequency * r),
                    confidence: 0.7,
                    method: 'adaptive_enhanced',
                    chordName: 'Adaptive Enhanced Reconstruction',
                    processingTime: performance.now() - startTime
                };
            }

            // ======================================================================
            // UTILITY METHODS
            // ======================================================================

            decimalToFraction(decimal, maxDenominator = 128) {
                let bestNumerator = 1;
                let bestDenominator = 1;
                let bestError = Math.abs(decimal - 1);
                
                for (let denominator = 1; denominator <= maxDenominator; denominator++) {
                    const numerator = Math.round(decimal * denominator);
                    const error = Math.abs(decimal - numerator / denominator);
                    
                    if (error < bestError) {
                        bestError = error;
                        bestNumerator = numerator;
                        bestDenominator = denominator;
                    }
                }
                
                const gcd = this.gcd(bestNumerator, bestDenominator);
                return {
                    numerator: bestNumerator / gcd,
                    denominator: bestDenominator / gcd,
                    decimal: bestNumerator / bestDenominator,
                    error: bestError
                };
            }

            gcd(a, b) {
                return b === 0 ? a : this.gcd(b, a % b);
            }

            calculateRatioPurity(ratios) {
                let purityScore = 0;
                ratios.forEach(ratio => {
                    const fraction = this.decimalToFraction(ratio, 64);
                    const simplicity = 1 / (fraction.numerator + fraction.denominator);
                    purityScore += simplicity;
                });
                return purityScore / ratios.length;
            }

            calculateRatioComplexity(ratios) {
                let totalComplexity = 0;
                ratios.forEach(ratio => {
                    const fraction = this.decimalToFraction(ratio, 64);
                    totalComplexity += fraction.denominator;
                });
                return totalComplexity / ratios.length;
            }

            identifyIntervals(ratios) {
                const intervals = [];
                const baseRatio = ratios[0];
                
                ratios.forEach(ratio => {
                    const normalizedRatio = ratio / baseRatio;
                    let closestInterval = 'Unknown';
                    let minDifference = Infinity;
                    
                    for (const [intervalName, intervalRatio] of Object.entries(this.pureIntervals)) {
                        const difference = Math.abs(normalizedRatio - intervalRatio);
                        if (difference < minDifference && difference < 0.01) {
                            minDifference = difference;
                            closestInterval = intervalName;
                        }
                    }
                    
                    intervals.push({
                        ratio: normalizedRatio,
                        interval: closestInterval,
                        is19_16: Math.abs(normalizedRatio - 19/16) < 0.001
                    });
                });
                
                return intervals;
            }

            // ======================================================================
            // CHORD SELECTION AND ANALYSIS
            // ======================================================================

            async selectChord(chordName) {
                if (!this.state.isInitialized) {
                    throw new Error("System not initialized");
                }
                
                if (!this.ratioLibrary.has(chordName)) {
                    throw new Error(`Chord '${chordName}' not found in ratio library`);
                }

                try {
                    const startTime = performance.now();
                    
                    this.state.currentChord = chordName;
                    const chordData = this.ratioLibrary.get(chordName);
                    
                    this.state.originalRatios = [...chordData.ratios];
                    this.state.originalFrequencies = [...chordData.frequencies];

                    // Calculate ratio differences
                    const ratioAnalysis = this.calculateRatioDifferences(chordData.ratios);
                    this.state.differenceRatios = ratioAnalysis.ratioDifferences;
                    this.state.differenceFrequencies = ratioAnalysis.frequencyDifferences;
                    
                    // Reconstruct from enhanced signature
                    const reconstructionResult = this.reconstructFromEnhancedSignature(chordData.signature);
                    this.state.reconstructedRatios = reconstructionResult.ratios;
                    this.state.reconstructedFrequencies = reconstructionResult.frequencies;

                    // Update statistics
                    this.state.statistics.testsRun++;
                    this.state.statistics.totalAnalysisTime += performance.now() - startTime;
                    
                    const analysis = this.analyzeRatioReconstruction();
                    
                    if (analysis.accuracy > 95) {
                        this.state.statistics.perfectMatches++;
                    } else if (analysis.accuracy > 70) {
                        this.state.statistics.goodMatches++;
                    }
                    
                    // Update UI
                    this.updateChordSelection(chordName);
                    this.updateAnalysisDisplay(ratioAnalysis, reconstructionResult, chordData);
                    this.updateRatioTable(chordData);
                    this.updateCalculationDetails(ratioAnalysis);
                    this.enableAudioButtons();
                    
                    this.log(`✅ Enhanced chord '${chordName}' analyzed - Accuracy: ${analysis.accuracy.toFixed(1)}%`);
                    
                    return {
                        chordName,
                        analysis,
                        reconstructionResult,
                        ratioData: chordData
                    };
                    
                } catch (error) {
                    this.handleError(`Chord selection: ${chordName}`, error);
                    throw error;
                }
            }

            calculateRatioDifferences(ratios) {
                const ratioDifferences = [];
                const frequencyDifferences = [];
                
                for (let i = 0; i < ratios.length; i++) {
                    for (let j = i + 1; j < ratios.length; j++) {
                        const ratioDiff = Math.abs(ratios[j] - ratios[i]);
                        const freqDiff = Math.abs(
                            (this.baseFrequency * ratios[j]) - (this.baseFrequency * ratios[i])
                        );
                        
                        if (ratioDiff > 0.01) {
                            ratioDifferences.push({
                                ratio1: ratios[i],
                                ratio2: ratios[j],
                                difference: ratioDiff,
                                quotient: ratios[j] / ratios[i],
                                freq1: this.baseFrequency * ratios[i],
                                freq2: this.baseFrequency * ratios[j],
                                freqDiff: freqDiff,
                                involves19_16: ratios[i] === 19/16 || ratios[j] === 19/16
                            });
                            
                            if (freqDiff >= 10 && freqDiff <= 500) {
                                frequencyDifferences.push(freqDiff);
                            }
                        }
                    }
                }

                return {
                    ratioDifferences: ratioDifferences,
                    frequencyDifferences: frequencyDifferences.sort((a, b) => a - b),
                    has19_16: ratios.includes(19/16),
                    signature: this.createEnhancedRatioSignature(ratios)
                };
            }

            analyzeRatioReconstruction() {
                const accuracy = this.calculateRatioAccuracy();
                const harmonyPreserved = this.analyzeRatioHarmonyPreservation();
                const ratioMatch = this.analyzeRatioMatch();
                const has19_16_original = this.state.originalRatios.includes(19/16);
                const has19_16_reconstructed = this.state.reconstructedRatios.includes(19/16);
                
                return {
                    accuracy,
                    quality: this.getQualityRating(accuracy),
                    isIdentical: accuracy > 95,
                    harmonyPreserved,
                    ratioMatch,
                    has19_16_preserved: has19_16_original === has19_16_reconstructed,
                    complexity: this.calculateRatioComplexity(this.state.reconstructedRatios),
                    confidence: Math.min(1, accuracy / 100 * 0.6 + (harmonyPreserved ? 0.2 : 0) + (ratioMatch ? 0.2 : 0))
                };
            }

            calculateRatioAccuracy() {
                if (this.state.originalRatios.length === 0) return 0;
                
                let matches = 0;
                this.state.originalRatios.forEach(origRatio => {
                    if (this.state.reconstructedRatios.some(reconRatio => 
                        Math.abs(origRatio - reconRatio) <= 0.01)) {
                        matches++;
                    }
                });
                
                return (matches / this.state.originalRatios.length) * 100;
            }

            analyzeRatioHarmonyPreservation() {
                const originalIntervals = this.calculateRatioIntervals(this.state.originalRatios);
                const reconstructedIntervals = this.calculateRatioIntervals(this.state.reconstructedRatios);
                
                if (originalIntervals.length === 0) return true;
                
                let preservedIntervals = 0;
                originalIntervals.forEach(interval => {
                    if (reconstructedIntervals.some(reconInterval => 
                        Math.abs(interval - reconInterval) <= 0.05)) {
                        preservedIntervals++;
                    }
                });
                
                return preservedIntervals / originalIntervals.length > 0.7;
            }

            calculateRatioIntervals(ratios) {
                if (ratios.length < 2) return [];
                
                const intervals = [];
                const sortedRatios = [...ratios].sort((a, b) => a - b);
                
                for (let i = 1; i < sortedRatios.length; i++) {
                    intervals.push(sortedRatios[i] / sortedRatios[0]);
                }
                return intervals;
            }

            analyzeRatioMatch() {
                const originalSpread = this.calculateRatioSpread(this.state.originalRatios);
                const reconstructedSpread = this.calculateRatioSpread(this.state.reconstructedRatios);
                
                return Math.abs(originalSpread - reconstructedSpread) < 0.2;
            }

            calculateRatioSpread(ratios) {
                if (ratios.length < 2) return 0;
                const sorted = [...ratios].sort((a, b) => a - b);
                return (sorted[sorted.length - 1] - sorted[0]) / sorted[0];
            }

            getQualityRating(accuracy) {
                if (accuracy > 95) return 'Perfect';
                if (accuracy > 85) return 'Excellent';
                if (accuracy > 70) return 'Very Good';
                if (accuracy > 50) return 'Good';
                return 'Poor';
            }

            // ======================================================================
            // AUDIO ENGINE
            // ======================================================================

            async initAudio() {
                try {
                    if (!this.state.audioContext) {
                        this.state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    if (this.state.audioContext.state === 'suspended') {
                        await this.state.audioContext.resume();
                    }
                    
                } catch (error) {
                    this.handleError('Audio initialization', error);
                    throw error;
                }
            }

            async playFrequencies(frequencies, duration = 2.0, label = "", waveform = 'sine') {
                if (this.state.isPlaying) {
                    this.log("⚠️ Audio already playing");
                    return;
                }
                
                await this.initAudio();
                this.state.isPlaying = true;
                
                this.log(`🎵 Playing ${label}:`, frequencies.map(f => f.toFixed(1)));
                
                try {
                    const oscillators = [];
                    
                    frequencies.forEach((freq, index) => {
                        const oscillator = this.state.audioContext.createOscillator();
                        const gainNode = this.state.audioContext.createGain();
                        const filterNode = this.state.audioContext.createBiquadFilter();
                        
                        oscillator.connect(filterNode);
                        filterNode.connect(gainNode);
                        gainNode.connect(this.state.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, this.state.audioContext.currentTime);
                        oscillator.type = waveform;
                        
                        filterNode.type = 'lowpass';
                        filterNode.frequency.setValueAtTime(freq * 3, this.state.audioContext.currentTime);
                        filterNode.Q.setValueAtTime(1.5, this.state.audioContext.currentTime);
                        
                        const now = this.state.audioContext.currentTime;
                        const volume = this.config.volume * 0.15 / frequencies.length;
                        
                        gainNode.gain.setValueAtTime(0, now);
                        gainNode.gain.exponentialRampToValueAtTime(volume, now + 0.05);
                        gainNode.gain.exponentialRampToValueAtTime(volume * 0.7, now + 0.1);
                        gainNode.gain.setValueAtTime(volume * 0.7, now + duration - 0.3);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
                        
                        oscillator.start(now);
                        oscillator.stop(now + duration);
                        
                        oscillators.push(oscillator);
                    });
                    
                    return new Promise(resolve => {
                        setTimeout(() => {
                            this.state.isPlaying = false;
                            resolve();
                        }, duration * 1000 + 100);
                    });
                    
                } catch (error) {
                    this.state.isPlaying = false;
                    this.handleError('Audio playback', error);
                    throw error;
                }
            }

            async playOriginal() {
                if (this.state.originalFrequencies.length === 0) {
                    throw new Error("No original frequencies available");
                }
                return this.playFrequencies(this.state.originalFrequencies, 2.0, "Pure tuning");
            }

            async playReconstructed() {
                if (this.state.reconstructedFrequencies.length === 0) {
                    throw new Error("No reconstructed frequencies available");
                }
                return this.playFrequencies(this.state.reconstructedFrequencies, 2.0, "T0 Reconstructed");
            }

            async playDifferences() {
                if (this.state.differenceFrequencies.length === 0) {
                    throw new Error("No ratio differences available");
                }
                const playableFreqs = this.state.differenceFrequencies
                    .filter(f => f >= 80 && f <= 800)
                    .slice(0, 6);
                return this.playFrequencies(playableFreqs, 2.0, "Ratio differences", 'triangle');
            }

            async playComparison() {
                await this.playOriginal();
                await new Promise(resolve => setTimeout(resolve, 400));
                
                if (this.state.originalRatios.length > 0) {
                    const temperedFreqs = this.calculateTemperedFrequencies(this.state.originalRatios);
                    await this.playFrequencies(temperedFreqs, 2.0, "Tempered tuning");
                }
            }

            calculateTemperedFrequencies(ratios) {
                const temperedFreqs = [];
                ratios.forEach(ratio => {
                    const cents = 1200 * Math.log2(ratio);
                    const temperedCents = Math.round(cents / 100) * 100;
                    const temperedFreq = this.baseFrequency * Math.pow(2, temperedCents / 1200);
                    temperedFreqs.push(temperedFreq);
                });
                return temperedFreqs;
            }

            // ======================================================================
            // UI UPDATES
            // ======================================================================

            populateChordGrid() {
                const grid = document.getElementById('chordGrid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                const sortedChords = Array.from(this.ratioLibrary.entries())
                    .sort((a, b) => {
                        if (a[1].has19_16 && !b[1].has19_16) return -1;
                        if (!a[1].has19_16 && b[1].has19_16) return 1;
                        return b[1].purity - a[1].purity;
                    })
                    .slice(0, 40);
                
                sortedChords.forEach(([chordName, chordData]) => {
                    const button = document.createElement('button');
                    button.className = 'chord-button';
                    if (chordData.has19_16) {
                        button.classList.add('has-19-16');
                    }
                    if (chordData.purity > 0.1) {
                        button.classList.add('pure-ratios');
                    }
                    button.onclick = () => this.selectChord(chordName);
                    button.textContent = chordName;
                    
                    grid.appendChild(button);
                });
            }

            updateChordSelection(chordName) {
                document.querySelectorAll('.chord-button').forEach(btn => {
                    btn.classList.remove('selected');
                    if (btn.textContent === chordName) {
                        btn.classList.add('selected');
                    }
                });
            }

            updateAnalysisDisplay(ratioAnalysis, reconstructionResult, chordData) {
                const originalDiv = document.getElementById('originalAnalysis');
                if (originalDiv) {
                    originalDiv.innerHTML = `
                        <h5>Enhanced Ratio Analysis:</h5>
                        <div class="frequency-list">
                            ${chordData.ratios.map((ratio, i) => {
                                const fraction = this.decimalToFraction(ratio, 64);
                                const freq = chordData.frequencies[i];
                                const is19_16 = Math.abs(ratio - 19/16) < 0.001;
                                return `
                                    <div class="frequency-tag ${is19_16 ? 'ratio-19-16' : ''}">
                                        ${fraction.numerator}/${fraction.denominator}<br>
                                        <small>${freq.toFixed(1)}Hz</small>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        <p><strong>Contains 19/16:</strong> ${chordData.has19_16 ? '✅ YES' : '❌ NO'}</p>
                        <p><strong>Purity:</strong> ${(chordData.purity * 100).toFixed(1)}%</p>
                        <p><strong>Complexity:</strong> ${chordData.complexity.toFixed(2)}</p>
                        <p><strong>Enhanced Signature:</strong> ${chordData.signature.shortHash}</p>
                    `;
                }
                
                const reconstructionDiv = document.getElementById('reconstructionAnalysis');
                if (reconstructionDiv) {
                    reconstructionDiv.innerHTML = `
                        <h5>T0 Enhanced Reconstruction:</h5>
                        <div class="frequency-list">
                            ${reconstructionResult.ratios.map((ratio, i) => {
                                const fraction = this.decimalToFraction(ratio, 64);
                                const freq = reconstructionResult.frequencies[i];
                                const is19_16 = Math.abs(ratio - 19/16) < 0.001;
                                return `
                                    <div class="frequency-tag reconstructed-tag ${is19_16 ? 'ratio-19-16' : ''}">
                                        ${fraction.numerator}/${fraction.denominator}<br>
                                        <small>${freq.toFixed(1)}Hz</small>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        <p><strong>Method:</strong> ${reconstructionResult.method}</p>
                        <p><strong>Confidence:</strong> ${(reconstructionResult.confidence * 100).toFixed(1)}%</p>
                        <p><strong>Chord:</strong> ${reconstructionResult.chordName}</p>
                    `;
                }
            }

            updateRatioTable(chordData) {
                const tableBody = document.getElementById('ratioTableBody');
                if (!tableBody) return;
                
                tableBody.innerHTML = '';
                
                chordData.ratios.forEach((ratio, index) => {
                    const fraction = this.decimalToFraction(ratio, 64);
                    const frequency = chordData.frequencies[index];
                    const cents = 1200 * Math.log2(ratio);
                    const temperedCents = Math.round(cents / 100) * 100;
                    const centDeviation = cents - temperedCents;
                    const is19_16 = Math.abs(ratio - 19/16) < 0.001;
                    const purity = 1 / (fraction.numerator + fraction.denominator);
                    
                    const intervalData = chordData.intervalNames[index];
                    const intervalName = intervalData ? intervalData.interval : 'Unknown';
                    
                    const row = document.createElement('tr');
                    if (is19_16) {
                        row.classList.add('special-19-16');
                    }
                    
                    row.innerHTML = `
                        <td>Tone ${index + 1}</td>
                        <td>${ratio.toFixed(6)}</td>
                        <td>${fraction.numerator}/${fraction.denominator}</td>
                        <td>${frequency.toFixed(2)} Hz</td>
                        <td>${intervalName}</td>
                        <td>${centDeviation.toFixed(1)} Cent</td>
                        <td>${(purity * 100).toFixed(1)}%</td>
                    `;
                    
                    tableBody.appendChild(row);
                });
            }

            updateCalculationDetails(ratioAnalysis) {
                const details = document.getElementById('calculationDetails');
                if (!details) return;
                
                details.innerHTML = `
                    <h5>Enhanced Calculation Details:</h5>
                    <p><strong>Ratio Differences:</strong> ${ratioAnalysis.ratioDifferences.length}</p>
                    <p><strong>Frequency Differences:</strong> ${ratioAnalysis.frequencyDifferences.length}</p>
                    <p><strong>19/16 Involved:</strong> ${ratioAnalysis.has19_16 ? 'Yes' : 'No'}</p>
                    <p><strong>Enhanced Signature Hash:</strong> ${ratioAnalysis.signature.shortHash}</p>
                    <p><strong>Special Ratios:</strong> ${ratioAnalysis.signature.specialRatios.join(', ') || 'None'}</p>
                    <p><strong>Harmonic Series:</strong> ${ratioAnalysis.signature.harmonicSeries.join(', ') || 'None'}</p>
                    
                    <h6>Top Ratio Differences:</h6>
                    <ul>
                        ${ratioAnalysis.ratioDifferences
                            .sort((a, b) => a.difference - b.difference)
                            .slice(0, 6)
                            .map(diff => `
                                <li>
                                    ${diff.difference.toFixed(4)} 
                                    (${diff.ratio1.toFixed(4)} → ${diff.ratio2.toFixed(4)})
                                    ${diff.involves19_16 ? ' <span style="color: var(--ratio-special);">with 19/16</span>' : ''}
                                </li>
                            `).join('')}
                    </ul>
                    
                    <h6>Frequency Differences (Hz):</h6>
                    <p>${ratioAnalysis.frequencyDifferences.slice(0, 8).map(f => f.toFixed(1)).join(', ')}</p>
                `;
                
                // Enhanced debug info
                const debug = document.getElementById('debugInfo');
                if (debug) {
                    debug.innerHTML = `
                        <strong>Current Ratios:</strong> ${this.state.originalRatios.map(r => r.toFixed(6)).join(', ')}<br>
                        <strong>19/16 Status:</strong> ${this.state.originalRatios.includes(19/16) ? 'ACTIVE ✅' : 'Not present ❌'}<br>
                        <strong>Reconstructed Ratios:</strong> ${this.state.reconstructedRatios.map(r => r.toFixed(6)).join(', ')}<br>
                        <strong>Enhanced Signature:</strong> ${ratioAnalysis.signature.shortHash}<br>
                        <strong>Collision Status:</strong> ${ratioAnalysis.signature.isCollisionResolved ? 'RESOLVED ✅' : 'CLEAN ✅'}<br>
                        <strong>Special Ratios:</strong> ${ratioAnalysis.signature.specialRatios.join(', ') || 'None'}<br>
                        <strong>Harmonic Analysis:</strong> ${ratioAnalysis.signature.harmonicSeries.join(', ') || 'None'}
                    `;
                }
            }

            updateSystemStatus(result) {
                this.updateStatus('systemStatus', 'ENHANCED ACTIVE ✅');
                this.updateStatus('chordLibrarySize', `${result.totalChords} Enhanced Chords`);
                this.updateStatus('collisionCount', `${result.collisionCount} Resolved`);
                this.updateStatus('ratioStatus', `19/16: ${this.state.statistics.ratio19_16Usage} Chords`);
                
                // Show collision warning if needed
                if (result.collisionCount > 0) {
                    const warningDiv = document.getElementById('collisionWarning');
                    const detailsDiv = document.getElementById('collisionDetails');
                    if (warningDiv && detailsDiv) {
                        warningDiv.style.display = 'block';
                        detailsDiv.innerHTML = `
                            <p>Detected ${result.collisionCount} hash collisions during library generation.</p>
                            <p>All collisions have been automatically resolved using enhanced signature generation.</p>
                            <p>Resolved collisions: ${this.state.statistics.collisionsResolved}</p>
                            <p>System integrity: <strong>100% MAINTAINED</strong></p>
                        `;
                    }
                }
            }

            updateStatus(elementId, text) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = text;
                }
            }

            enableAudioButtons() {
                ['playOriginal', 'playDifferences', 'playReconstructed', 'playComparison'].forEach(id => {
                    const button = document.getElementById(id);
                    if (button) {
                        button.disabled = false;
                    }
                });
            }

            // ======================================================================
            // SYSTEM INITIALIZATION
            // ======================================================================

            async initializeSystem() {
                try {
                    this.log("🚀 Initializing T0 Enhanced Audio System v" + this.version);
                    
                    // Generate enhanced ratio-based chord library
                    const result = await this.generateEnhancedRatioBasedChordLibrary();
                    
                    this.state.isInitialized = true;
                    this.log("✅ T0 Enhanced Ratio System initialized");
                    
                    // Update UI
                    this.updateSystemStatus(result);
                    this.populateChordGrid();
                    this.setupEventListeners();
                    
                } catch (error) {
                    this.handleError('System initialization', error);
                    throw error;
                }
            }

            setupEventListeners() {
                // Audio buttons
                const playOriginal = document.getElementById('playOriginal');
                if (playOriginal) {
                    playOriginal.onclick = () => this.playOriginal().catch(e => this.handleError('Audio Original', e));
                }
                
                const playDifferences = document.getElementById('playDifferences');
                if (playDifferences) {
                    playDifferences.onclick = () => this.playDifferences().catch(e => this.handleError('Audio Differences', e));
                }
                
                const playReconstructed = document.getElementById('playReconstructed');
                if (playReconstructed) {
                    playReconstructed.onclick = () => this.playReconstructed().catch(e => this.handleError('Audio Reconstructed', e));
                }
                
                const playComparison = document.getElementById('playComparison');
                if (playComparison) {
                    playComparison.onclick = () => this.playComparison().catch(e => this.handleError('Audio Comparison', e));
                }
                
                // Audio context activation
                document.addEventListener('click', async () => {
                    if (this.state.audioContext && this.state.audioContext.state === 'suspended') {
                        await this.state.audioContext.resume();
                        this.log("🎵 Audio context activated");
                    }
                }, { once: true });
            }

            // ======================================================================
            // ERROR HANDLING AND UTILITIES
            // ======================================================================

            handleError(context, error) {
                this.state.statistics.errors++;
                
                const errorInfo = {
                    context,
                    message: error.message,
                    stack: error.stack,
                    timestamp: new Date().toISOString(),
                    systemState: {
                        isInitialized: this.state.isInitialized,
                        currentChord: this.state.currentChord,
                        isPlaying: this.state.isPlaying,
                        collisionCount: this.state.collisionCount
                    }
                };
                
                if (this.config.debugMode) {
                    console.error(`❌ T0 Enhanced Error in ${context}:`, errorInfo);
                } else {
                    console.error(`❌ T0 Enhanced Error in ${context}:`, error.message);
                }
            }

            log(...args) {
                if (this.config.debugMode) {
                    console.log(`[T0-Enhanced-${Date.now()}]`, ...args);
                }
            }

            getSystemInfo() {
                return {
                    version: this.version,
                    isInitialized: this.state.isInitialized,
                    ratioLibrarySize: this.ratioLibrary.size,
                    chordLibrarySize: this.chordLibrary.size,
                    signatureDatabaseSize: this.signatureDatabase.size,
                    currentChord: this.state.currentChord,
                    configuration: this.config,
                    statistics: this.state.statistics,
                    collisionInfo: {
                        detected: this.state.statistics.collisionsDetected,
                        resolved: this.state.statistics.collisionsResolved,
                        registry: Object.fromEntries(this.collisionRegistry)
                    },
                    ratio19_16Usage: this.state.statistics.ratio19_16Usage,
                    enhancedFeatures: [
                        'Collision-free signature generation',
                        'Enhanced similarity matching',
                        'Multi-component hash system',
                        'Adaptive reconstruction',
                        'Harmonic series analysis',
                        'Special ratio detection'
                    ]
                };
            }

            // Static helper methods
            static noteToFrequency(note, octave = 4) {
                const noteMap = {
                    'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
                    'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
                    'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
                };
                
                const noteNumber = noteMap[note.toUpperCase()];
                if (noteNumber === undefined) {
                    throw new Error(`Invalid note: ${note}`);
                }
                
                const midiNumber = (octave + 1) * 12 + noteNumber;
                return 440 * Math.pow(2, (midiNumber - 69) / 12);
            }

            static ratioToCents(ratio) {
                return 1200 * Math.log2(ratio);
            }

            static centsToRatio(cents) {
                return Math.pow(2, cents / 1200);
            }
        }

        // ======================================================================
        // SYSTEM INITIALIZATION
        // ======================================================================

        // Initialize enhanced system
        const t0EnhancedSystem = new T0AudioSystemEnhanced({
            debugMode: true,
            pureRatioMode: true,
            use19_16ForMinorThird: true,
            tolerance: 1.5,
            recognitionThreshold: 0.8,
            collisionTolerance: 0.001,
            signatureDepth: 8
        });
        
        // Make globally available for debugging
        window.t0Enhanced = t0EnhancedSystem;
        
        console.log("🎵 T0 Audio System v2.1.0 - Enhanced with collision resolution loaded!");
        console.log("📐 Uses pure tuning with 19/16 for special minor third chords");
        console.log("🔧 Enhanced collision-free signature system");
        console.log("🔧 Debug access via: window.t0Enhanced");
        console.log("📊 System info:", t0EnhancedSystem.getSystemInfo());
    </script>
</body>
</html>