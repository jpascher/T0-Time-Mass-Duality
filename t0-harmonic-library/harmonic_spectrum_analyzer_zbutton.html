<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harmonische Spektrum-Analyse - Rationale Methode</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            text-align: center;
            margin-bottom: 40px;
            font-size: 1.2em;
            opacity: 0.9;
        }

        .panel {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .panel h2 {
            color: #ffd700;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #fff;
            font-size: 12px;
        }

        input, select, button {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        input, select {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            cursor: pointer;
            font-weight: bold;
            margin: 3px 0;
            padding: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .harmonic-spectrum {
            position: relative;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }

        .spectrum-canvas {
            width: 100%;
            height: 400px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .harmonic-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .rational-analyzer {
            background: rgba(255, 100, 100, 0.1);
            border: 2px solid rgba(255, 100, 100, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .xi-controls {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
        }

        .analysis-method {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .harmonic-bar {
            position: absolute;
            bottom: 0;
            background: linear-gradient(to top, #ff4444, #ffff44, #44ff44);
            border-radius: 2px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .harmonic-bar:hover {
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        .harmonic-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #ffd700;
            font-weight: bold;
        }

        .ratio-label {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .fundamental-line {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to top, #ffd700, #ffed4e);
            border-radius: 2px;
            box-shadow: 0 0 8px #ffd700;
        }

        .octave-marker {
            position: absolute;
            bottom: 0;
            width: 2px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 1px;
        }

        .interval-detector {
            background: rgba(128, 0, 128, 0.1);
            border: 2px solid rgba(128, 0, 128, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .detected-intervals {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .interval-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 12px;
        }

        .interval-ratio {
            font-weight: bold;
            color: #ffd700;
        }

        .interval-name {
            color: #ff8c00;
        }

        .interval-deviation {
            color: #00ff00;
        }

        .harmonic-series-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-height: 300px;
            overflow-y: auto;
        }

        .mic-controls {
            background: rgba(255, 100, 100, 0.1);
            border: 2px solid rgba(255, 100, 100, 0.3);
            border-radius: 10px;
            padding: 15px;
        }

        .mic-level {
            height: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            margin: 10px 0;
        }

        .mic-level-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            width: 0%;
            transition: width 0.1s ease;
        }

        .analysis-log {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .log-rational { background: rgba(0, 255, 0, 0.1); }
        .log-detection { background: rgba(255, 255, 0, 0.1); }
        .log-analysis { background: rgba(0, 0, 255, 0.1); }
        .log-error { background: rgba(255, 0, 0, 0.1); }

        .spectrum-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
            align-items: center;
        }

        .spectrum-controls label {
            margin: 0;
            font-size: 11px;
        }

        .spectrum-controls input, .spectrum-controls select {
            width: auto;
            min-width: 80px;
            padding: 5px;
            font-size: 11px;
        }

        .harmonic-info {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        .preset-btn {
            background: linear-gradient(45deg, #9c27b0, #7b1fa2);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .preset-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        .freq-input-group {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .freq-input-group label {
            font-size: 11px;
            margin-bottom: 4px;
        }

        .freq-input-group input {
            padding: 4px;
            font-size: 12px;
        }

        .freq-display {
            color: #ffd700;
            font-weight: bold;
            font-size: 12px;
            margin-top: 3px;
        }

        .interval-display {
            color: #ff8c00;
            font-size: 10px;
            margin-top: 2px;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .spectrum-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎵 Harmonische Spektrum-Analyse</h1>
        <p class="subtitle">
            Rationale Harmonik-Analyse mit ξ-Parameter basierter Spektrumdarstellung<br>
            <em>Alternative zur FFT: Direkte Berechnung harmonischer Verhältnisse</em><br>
            <button id="homeButton" style="margin-top: 10px; padding: 8px 16px; background: linear-gradient(45deg, #667eea, #764ba2); color: white; border: none; border-radius: 20px; cursor: pointer; font-size: 14px; transition: all 0.3s ease;" 
                    onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 15px rgba(0,0,0,0.3)'" 
                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                🏠 Zurück zur T0-Theory Hauptseite
            </button>
        </p>

        <div class="controls-grid">
            <!-- Audio-Eingabe -->
            <div class="panel">
                <h2>🎤 Audio-Eingabe</h2>
                
                <div class="control-group">
                    <label for="audioSource">Audio-Quelle</label>
                    <select id="audioSource">
                        <option value="microphone">Mikrofon</option>
                        <option value="generator" selected>Frequenz-Generator</option>
                        <option value="file">Audio-Datei</option>
                    </select>
                </div>

                <!-- Mikrofon-Kontrollen -->
                <div class="mic-controls" id="micControls" style="display: none;">
                    <button id="micButton">🎤 Mikrofon Starten</button>
                    <div class="mic-level">
                        <div class="mic-level-bar" id="micLevelBar"></div>
                    </div>
                    <div class="control-group">
                        <label for="micSensitivity">Empfindlichkeit</label>
                        <input type="range" id="micSensitivity" min="0.01" max="2" step="0.01" value="0.1">
                        <span id="micSensitivityValue">0.1</span>
                    </div>
                    <div class="control-group">
                        <label for="noiseThreshold">Rausch-Schwelle</label>
                        <input type="range" id="noiseThreshold" min="0" max="50" step="1" value="5">
                        <span id="noiseThresholdValue">5</span>
                    </div>
                    <div class="control-group">
                        <label for="micGain">Mikrofon-Verstärkung</label>
                        <input type="range" id="micGain" min="0.1" max="10" step="0.1" value="1">
                        <span id="micGainValue">1.0</span>
                    </div>
                </div>

                <!-- Generator-Kontrollen -->
                <div class="mic-controls" id="generatorControls">
                    <div class="control-group">
                        <label for="generatorMode">Generator-Modus</label>
                        <select id="generatorMode">
                            <option value="single">Einzelfrequenz</option>
                            <option value="chord">Akkord (3 Frequenzen)</option>
                            <option value="harmonic" selected>Harmonische Reihe</option>
                            <option value="beating">Beat-Frequenzen</option>
                            <option value="custom">Benutzerdefiniert</option>
                            <option value="test_intervals">Test: Just Intonation</option>
                            <option value="test_scales">Test: Musikalische Skalen</option>
                            <option value="test_rationals">Test: Rationale Reihe</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="masterVolume">Lautstärke</label>
                        <input type="range" id="masterVolume" min="0" max="100" value="20">
                        <span id="volumeValue">20%</span>
                    </div>
                    
                    <button id="playButton">▶️ Generator Starten</button>
                    <button id="stopButton">⏹️ Generator Stoppen</button>
                </div>

                <!-- Datei-Kontrollen -->
                <div class="mic-controls" id="fileControls" style="display: none;">
                    <div class="control-group">
                        <button id="loadFileButton">📁 Audio-Datei auswählen</button>
                        <input type="file" id="audioFileInput" accept="audio/*" style="display: none;">
                    </div>
                    
                    <div class="control-group">
                        <button id="playFileButton" disabled>▶️ Datei Abspielen</button>
                        <button id="stopFileButton" disabled>⏹️ Stoppen</button>
                    </div>
                    
                    <div class="control-group">
                        <label for="fileVolume">Datei-Lautstärke</label>
                        <input type="range" id="fileVolume" min="0" max="100" value="50">
                        <span id="fileVolumeValue">50%</span>
                    </div>
                    
                    <div id="fileInfo" style="font-size: 12px; margin-top: 10px; opacity: 0.8; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 5px;">
                        Keine Datei geladen
                    </div>
                </div>

                <div class="control-group">
                    <label for="fundamentalFreq">Grundfrequenz (Hz)</label>
                    <input type="number" id="fundamentalFreq" value="440" min="20" max="2000" step="0.1">
                </div>

                <div class="control-group">
                    <label for="harmonicRange">Harmonik-Bereich</label>
                    <input type="range" id="harmonicRange" min="8" max="64" value="32">
                    <span id="harmonicRangeValue">32</span>
                </div>
            </div>

            <!-- Frequenz-Eingaben -->
            <div class="panel">
                <h2>🎛️ Frequenz-Kontrollen</h2>
                
                <div id="frequencyInputs" style="max-height: 300px; overflow-y: auto;">
                    <!-- Dynamisch generiert -->
                </div>
                
                <div class="control-group" style="margin-top: 15px;">
                    <label for="waveform">Wellenform</label>
                    <select id="waveform">
                        <option value="sine" selected>Sinus</option>
                        <option value="triangle">Dreieck</option>
                        <option value="square">Rechteck</option>
                        <option value="sawtooth">Sägezahn</option>
                    </select>
                </div>
            </div>

            <!-- Test-Presets -->
            <div class="panel">
                <h2>🧪 Test-Presets</h2>
                
                <div class="control-group">
                    <label>Oktav-Kombinationen</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 5px;">
                        <button class="preset-btn" data-preset="unison">Unison</button>
                        <button class="preset-btn" data-preset="octave">Oktave</button>
                        <button class="preset-btn" data-preset="fifth">Quinte</button>
                        <button class="preset-btn" data-preset="fourth">Quarte</button>
                        <button class="preset-btn" data-preset="major3rd">Gr.Terz</button>
                        <button class="preset-btn" data-preset="minor3rd">Kl.Terz</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Akkorde</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 5px;">
                        <button class="preset-btn" data-preset="major_chord">Dur</button>
                        <button class="preset-btn" data-preset="minor_chord">Moll</button>
                        <button class="preset-btn" data-preset="dim_chord">Vermindert</button>
                        <button class="preset-btn" data-preset="aug_chord">Übermäßig</button>
                        <button class="preset-btn" data-preset="sus2_chord">Sus2</button>
                        <button class="preset-btn" data-preset="sus4_chord">Sus4</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Harmonische Tests</label>
                    <div style="display: grid; grid-template-columns: 1fr; gap: 5px; margin-top: 5px;">
                        <button class="preset-btn" data-preset="harmonic_series">Harmonische Reihe</button>
                        <button class="preset-btn" data-preset="prime_ratios">Primzahl-Verhältnisse</button>
                        <button class="preset-btn" data-preset="euler_simple">Euler Einfach (≤3)</button>
                        <button class="preset-btn" data-preset="xi_test">ξ-Parameter Test</button>
                    </div>
                </div>
            </div>

            <!-- ξ-Parameter Kontrollen -->
            <div class="panel">
                <h2>⚡ ξ-Parameter</h2>
                
                <div class="xi-controls">
                    <div class="control-group">
                        <label for="xiTolerance">ξ-Toleranz (Cents)</label>
                        <input type="range" id="xiTolerance" min="1" max="200" value="50">
                        <span id="xiToleranceValue">50¢</span>
                    </div>
                    
                    <div class="control-group">
                        <label for="xiProfile">ξ-Profil</label>
                        <select id="xiProfile">
                            <option value="strict">Strict (10¢)</option>
                            <option value="standard" selected>Standard (50¢)</option>
                            <option value="loose">Loose (100¢)</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <label for="rationalLimit">Rationale Grenze</label>
                    <input type="range" id="rationalLimit" min="10" max="1000" value="100">
                    <span id="rationalLimitValue">100</span>
                </div>

                <div class="control-group">
                    <label for="eulerLimit">Euler-Gradus Limit</label>
                    <input type="range" id="eulerLimit" min="3" max="10" value="6">
                    <span id="eulerLimitValue">6</span>
                </div>
            </div>

            <!-- Analyse-Methode -->
            <div class="panel">
                <h2>🔬 Analyse-Methode</h2>
                
                <div class="analysis-method">
                    <div class="control-group">
                        <label for="analysisType">Analyse-Typ</label>
                        <select id="analysisType">
                            <option value="harmonic" selected>Harmonische Analyse</option>
                            <option value="rational">Rationale Approximation</option>
                            <option value="hybrid">Hybrid (Harmonik + FFT)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="detectionMethod">Erkennungsmethode</label>
                        <select id="detectionMethod">
                            <option value="goertzel">Goertzel-Algorithmus</option>
                            <option value="autocorrelation" selected>Autokorrelation</option>
                            <option value="rational_filter">Rationale Filter</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <label for="updateRate">Update-Rate (ms)</label>
                    <input type="range" id="updateRate" min="10" max="500" value="50">
                    <span id="updateRateValue">50ms</span>
                </div>

                <div class="control-group">
                    <button id="startAnalysis">🚀 Analyse Starten</button>
                    <button id="stopAnalysis">⏹️ Analyse Stoppen</button>
                </div>
            </div>
        </div>

        <!-- Harmonisches Spektrum -->
        <div class="panel">
            <h2>📊 Harmonisches Spektrum</h2>
            
            <div class="spectrum-controls">
                <label for="spectrumScale">Skalierung:</label>
                <select id="spectrumScale">
                    <option value="linear">Linear</option>
                    <option value="log" selected>Logarithmisch</option>
                    <option value="rational">Rational</option>
                </select>
                
                <label for="showRatios">Verhältnisse anzeigen:</label>
                <input type="checkbox" id="showRatios" checked>
                
                <label for="showOctaves">Oktaven markieren:</label>
                <input type="checkbox" id="showOctaves" checked>
                
                <label for="colorCoding">Farbkodierung:</label>
                <select id="colorCoding">
                    <option value="frequency">Frequenz</option>
                    <option value="ratio" selected>Verhältnis</option>
                    <option value="euler">Euler-Gradus</option>
                    <option value="deviation">Abweichung</option>
                </select>
            </div>
            
            <div class="harmonic-spectrum">
                <div class="spectrum-canvas" id="spectrumCanvas">
                    <canvas id="harmonicCanvas" width="800" height="400"></canvas>
                    <div class="harmonic-grid" id="harmonicGrid"></div>
                </div>
                <div class="harmonic-info" id="harmonicInfo"></div>
            </div>
        </div>

        <!-- Erkannte Intervalle -->
        <div class="panel">
            <h2>🎼 Erkannte Intervalle</h2>
            
            <div class="interval-detector">
                <div class="control-group">
                    <label for="intervalSensitivity">Intervall-Empfindlichkeit</label>
                    <input type="range" id="intervalSensitivity" min="1" max="100" value="20">
                    <span id="intervalSensitivityValue">20</span>
                </div>
                
                <div class="detected-intervals" id="detectedIntervals">
                    <div style="text-align: center; opacity: 0.6; grid-column: 1/-1;">
                        Keine Intervalle erkannt - Starten Sie die Analyse
                    </div>
                </div>
            </div>
        </div>

        <!-- Harmonische Reihen-Analyse -->
        <div class="panel">
            <h2>🌊 Harmonische Reihen-Analyse</h2>
            
            <div class="harmonic-series-display" id="harmonicSeriesDisplay">
                <div style="text-align: center; opacity: 0.6;">
                    Harmonische Analyse wird hier angezeigt...
                </div>
            </div>
        </div>

        <!-- Analyse-Log -->
        <div class="panel">
            <h2>📋 Analyse-Log</h2>
            
            <div style="margin-bottom: 10px;">
                <button id="clearLog" style="width: auto; padding: 5px 10px; font-size: 12px;">🗑️ Log Löschen</button>
                <button id="exportLog" style="width: auto; padding: 5px 10px; font-size: 12px;">💾 Export</button>
            </div>
            
            <div class="analysis-log" id="analysisLog">
                <div class="log-entry">System bereit - Wählen Sie eine Audio-Quelle</div>
            </div>
        </div>

        <!-- Datei-Management -->
        <div class="panel">
            <h2>💾 Datei-Management</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div>
                    <h3 style="color: #00ff00; font-size: 14px; margin-bottom: 10px;">📥 Laden</h3>
                    <div class="control-group">
                        <button id="loadConfigButton" style="width: 100%; padding: 8px; font-size: 12px;">⚙️ Konfiguration Laden</button>
                        <input type="file" id="configFileInput" accept=".json" style="display: none;">
                    </div>
                    <div class="control-group">
                        <button id="loadAnalysisButton" style="width: 100%; padding: 8px; font-size: 12px;">📊 Analyse Laden</button>
                        <input type="file" id="analysisFileInput" accept=".json" style="display: none;">
                    </div>
                </div>
                
                <div>
                    <h3 style="color: #ff8c00; font-size: 14px; margin-bottom: 10px;">📤 Speichern</h3>
                    <div class="control-group">
                        <button id="saveConfigButton" style="width: 100%; padding: 8px; font-size: 12px;">⚙️ Konfiguration Speichern</button>
                    </div>
                    <div class="control-group">
                        <button id="saveAnalysisButton" style="width: 100%; padding: 8px; font-size: 12px;">📊 Analyse Speichern</button>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 15px;">
                <h3 style="color: #ffd700; font-size: 14px; margin-bottom: 10px;">📋 Aktuelle Konfiguration</h3>
                <div id="configPreview" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; font-family: monospace; font-size: 11px; max-height: 150px; overflow-y: auto;">
                    Konfiguration wird hier angezeigt...
                </div>
            </div>
        </div>
    </div>

    <script>
        // Globale Variablen
        let audioContext;
        let micStream;
        let micSource;
        let micAnalyser;
        let analysisActive = false;
        let analysisInterval;
        let harmonicData = [];
        let rationalCache = new Map();
        let canvas, ctx;
        
        // Generator-Variablen
        let oscillators = [];
        let gainNode;
        let generatorActive = false;
        let currentFrequencies = [];
        
        // Datei-Variablen
        let audioBuffer;
        let audioSource;
        let fileGainNode;
        let fileActive = false;

        // Rationale Arithmetik Klasse
        class RationalNumber {
            constructor(num, den = 1) {
                if (den === 0) throw new Error("Denominator cannot be zero");
                
                const gcd = this.gcd(Math.abs(num), Math.abs(den));
                this.numerator = Math.floor(num / gcd);
                this.denominator = Math.floor(den / gcd);
                
                if (this.denominator < 0) {
                    this.numerator = -this.numerator;
                    this.denominator = -this.denominator;
                }
            }
            
            gcd(a, b) {
                while (b !== 0) {
                    [a, b] = [b, a % b];
                }
                return a;
            }
            
            toFloat() {
                return this.numerator / this.denominator;
            }
            
            toString() {
                return this.denominator === 1 ? this.numerator.toString() : `${this.numerator}/${this.denominator}`;
            }
            
            equals(other) {
                return this.numerator === other.numerator && this.denominator === other.denominator;
            }
        }

        // Harmonische Analyse Klasse
        class HarmonicAnalyzer {
            constructor() {
                this.fundamentalFreq = 440;
                this.harmonicRange = 32;
                this.xiTolerance = 50;
                this.rationalLimit = 100;
                this.eulerLimit = 6;
                this.detectedHarmonics = [];
                this.intervals = [];
            }

            // Rationale Approximation mit Kettenbrüchen
            approximateRational(decimal, maxDenominator = 1000) {
                const cacheKey = `${decimal.toFixed(6)}_${maxDenominator}`;
                if (rationalCache.has(cacheKey)) {
                    return rationalCache.get(cacheKey);
                }

                if (decimal === 0) {
                    const result = new RationalNumber(0, 1);
                    rationalCache.set(cacheKey, result);
                    return result;
                }
                
                let sign = decimal < 0 ? -1 : 1;
                decimal = Math.abs(decimal);
                
                let wholePart = Math.floor(decimal);
                let fractionalPart = decimal - wholePart;
                
                if (fractionalPart === 0) {
                    const result = new RationalNumber(sign * wholePart, 1);
                    rationalCache.set(cacheKey, result);
                    return result;
                }
                
                // Continued fraction method
                let h1 = 1, k1 = 0;
                let h0 = wholePart, k0 = 1;
                
                let x = fractionalPart;
                let iterations = 0;
                while (k0 <= maxDenominator && x !== 0 && iterations < 50) {
                    let a = Math.floor(1 / x);
                    let h2 = a * h0 + h1;
                    let k2 = a * k0 + k1;
                    
                    if (k2 > maxDenominator) break;
                    
                    h1 = h0; k1 = k0;
                    h0 = h2; k0 = k2;
                    
                    x = 1 / x - a;
                    if (Math.abs(x) < 1e-10) break;
                    iterations++;
                }
                
                const result = new RationalNumber(sign * h0, k0);
                rationalCache.set(cacheKey, result);
                return result;
            }

            // Euler Gradus Berechnung
            calculateEulerGradus(rational) {
                const factors = (n) => {
                    let count = 0;
                    let factor = 2;
                    let temp = Math.abs(n);
                    
                    while (factor * factor <= temp) {
                        while (temp % factor === 0) {
                            count++;
                            temp = temp / factor;
                        }
                        factor++;
                    }
                    
                    if (temp > 1) count++;
                    return count;
                };
                
                return factors(rational.numerator) + factors(rational.denominator) + 1;
            }

            // Goertzel-Algorithmus für spezifische Frequenzen
            goertzelDetection(audioData, targetFreq, sampleRate) {
                const N = audioData.length;
                const k = Math.round(N * targetFreq / sampleRate);
                const omega = 2 * Math.PI * k / N;
                const cosine = Math.cos(omega);
                const sine = Math.sin(omega);
                const coeff = 2 * cosine;
                
                let q0 = 0, q1 = 0, q2 = 0;
                
                for (let i = 0; i < N; i++) {
                    q0 = coeff * q1 - q2 + audioData[i];
                    q2 = q1;
                    q1 = q0;
                }
                
                const real = q1 - q2 * cosine;
                const imag = q2 * sine;
                const magnitude = Math.sqrt(real * real + imag * imag);
                
                return magnitude;
            }

            // Autokorrelation für Pitch-Detection
            autocorrelation(audioData) {
                const length = audioData.length;
                const result = new Array(length).fill(0);
                
                for (let lag = 0; lag < length; lag++) {
                    let sum = 0;
                    for (let i = 0; i < length - lag; i++) {
                        sum += audioData[i] * audioData[i + lag];
                    }
                    result[lag] = sum / (length - lag);
                }
                
                return result;
            }

            // Harmonische Analyse des Audio-Signals
            analyzeHarmonics(audioData, sampleRate) {
                const detectionMethod = document.getElementById('detectionMethod').value;
                this.detectedHarmonics = [];
                
                if (detectionMethod === 'autocorrelation') {
                    this.analyzeWithAutocorrelation(audioData, sampleRate);
                } else if (detectionMethod === 'goertzel') {
                    this.analyzeWithGoertzel(audioData, sampleRate);
                } else if (detectionMethod === 'rational_filter') {
                    this.analyzeWithRationalFilter(audioData, sampleRate);
                }
                
                this.detectIntervals();
                return this.detectedHarmonics;
            }

            analyzeWithAutocorrelation(audioData, sampleRate) {
                const correlation = this.autocorrelation(audioData);
                
                // Finde Fundamental-Frequenz
                let maxCorr = 0;
                let bestPeriod = 0;
                
                const minPeriod = Math.floor(sampleRate / 2000); // Max 2kHz
                const maxPeriod = Math.floor(sampleRate / 50);   // Min 50Hz
                
                for (let period = minPeriod; period < maxPeriod; period++) {
                    if (correlation[period] > maxCorr) {
                        maxCorr = correlation[period];
                        bestPeriod = period;
                    }
                }
                
                if (bestPeriod > 0) {
                    this.fundamentalFreq = sampleRate / bestPeriod;
                    
                    // Analysiere Harmonische
                    for (let harmonic = 1; harmonic <= this.harmonicRange; harmonic++) {
                        const targetFreq = this.fundamentalFreq * harmonic;
                        const magnitude = this.goertzelDetection(audioData, targetFreq, sampleRate);
                        
                        if (magnitude > 0.01) { // Threshold
                            const rational = this.approximateRational(harmonic, this.rationalLimit);
                            const eulerGradus = this.calculateEulerGradus(rational);
                            
                            if (eulerGradus <= this.eulerLimit) {
                                this.detectedHarmonics.push({
                                    frequency: targetFreq,
                                    harmonic: harmonic,
                                    magnitude: magnitude,
                                    rational: rational,
                                    eulerGradus: eulerGradus
                                });
                            }
                        }
                    }
                }
            }

            analyzeWithGoertzel(audioData, sampleRate) {
                const baseFreq = parseFloat(document.getElementById('fundamentalFreq').value);
                
                for (let harmonic = 1; harmonic <= this.harmonicRange; harmonic++) {
                    const targetFreq = baseFreq * harmonic;
                    const magnitude = this.goertzelDetection(audioData, targetFreq, sampleRate);
                    
                    if (magnitude > 0.01) {
                        const rational = this.approximateRational(harmonic, this.rationalLimit);
                        const eulerGradus = this.calculateEulerGradus(rational);
                        
                        if (eulerGradus <= this.eulerLimit) {
                            this.detectedHarmonics.push({
                                frequency: targetFreq,
                                harmonic: harmonic,
                                magnitude: magnitude,
                                rational: rational,
                                eulerGradus: eulerGradus
                            });
                        }
                    }
                }
            }

            analyzeWithRationalFilter(audioData, sampleRate) {
                // Implementiere rationale Filter-Analyse
                const baseFreq = parseFloat(document.getElementById('fundamentalFreq').value);
                
                // Teste alle rationalen Verhältnisse bis zum Limit
                for (let num = 1; num <= this.rationalLimit; num++) {
                    for (let den = 1; den <= this.rationalLimit; den++) {
                        const rational = new RationalNumber(num, den);
                        const ratio = rational.toFloat();
                        
                        if (ratio > this.harmonicRange) break;
                        
                        const targetFreq = baseFreq * ratio;
                        const magnitude = this.goertzelDetection(audioData, targetFreq, sampleRate);
                        
                        if (magnitude > 0.01) {
                            const eulerGradus = this.calculateEulerGradus(rational);
                            
                            if (eulerGradus <= this.eulerLimit) {
                                this.detectedHarmonics.push({
                                    frequency: targetFreq,
                                    harmonic: ratio,
                                    magnitude: magnitude,
                                    rational: rational,
                                    eulerGradus: eulerGradus
                                });
                            }
                        }
                    }
                }
                
                // Sortiere nach Magnitude
                this.detectedHarmonics.sort((a, b) => b.magnitude - a.magnitude);
            }

            detectIntervals() {
                this.intervals = [];
                
                for (let i = 0; i < this.detectedHarmonics.length; i++) {
                    for (let j = i + 1; j < this.detectedHarmonics.length; j++) {
                        const h1 = this.detectedHarmonics[i];
                        const h2 = this.detectedHarmonics[j];
                        
                        const ratio = h2.frequency / h1.frequency;
                        const rationalRatio = this.approximateRational(ratio, this.rationalLimit);
                        
                        const cents = Math.abs(1200 * Math.log2(ratio / rationalRatio.toFloat()));
                        
                        if (cents <= this.xiTolerance) {
                            this.intervals.push({
                                freq1: h1.frequency,
                                freq2: h2.frequency,
                                ratio: ratio,
                                rational: rationalRatio,
                                cents: cents,
                                name: this.getIntervalName(rationalRatio)
                            });
                        }
                    }
                }
            }

            getIntervalName(rational) {
                const intervalNames = {
                    '1/1': 'Unison',
                    '2/1': 'Oktave',
                    '3/2': 'Quinte',
                    '4/3': 'Quarte',
                    '5/4': 'Große Terz',
                    '6/5': 'Kleine Terz',
                    '9/8': 'Ganzton',
                    '16/15': 'Halbton',
                    '5/3': 'Große Sexte',
                    '8/5': 'Kleine Sexte',
                    '15/8': 'Große Septime',
                    '16/9': 'Kleine Septime'
                };
                
                return intervalNames[rational.toString()] || `${rational.toString()} (${rational.toFloat().toFixed(3)})`;
            }
        }

        // Globaler Harmonischer Analyzer
        const harmonicAnalyzer = new HarmonicAnalyzer();

        // Initialisierung
        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('harmonicCanvas');
            ctx = canvas.getContext('2d');
            
            setupEventListeners();
            
            // Initialisiere mit Generator-Modus
            document.getElementById('audioSource').value = 'generator';
            handleAudioSourceChange();
            updateFrequencyInputs();
            
            logMessage('System initialisiert - Generator-Modus aktiv', 'analysis');
        });

        function setupEventListeners() {
            // Audio-Kontrollen
            document.getElementById('audioSource').addEventListener('change', handleAudioSourceChange);
            document.getElementById('micButton').addEventListener('click', toggleMicrophone);
            
            // Mikrofon-Parameter Event Listeners
            document.getElementById('micSensitivity').addEventListener('input', function(e) {
                document.getElementById('micSensitivityValue').textContent = e.target.value;
            });
            
            document.getElementById('noiseThreshold').addEventListener('input', function(e) {
                document.getElementById('noiseThresholdValue').textContent = e.target.value;
            });
            
            document.getElementById('micGain').addEventListener('input', function(e) {
                document.getElementById('micGainValue').textContent = e.target.value;
            });
            
            // Generator-Kontrollen
            document.getElementById('generatorMode').addEventListener('change', updateFrequencyInputs);
            document.getElementById('playButton').addEventListener('click', startGenerator);
            document.getElementById('stopButton').addEventListener('click', stopGenerator);
            document.getElementById('masterVolume').addEventListener('input', function(e) {
                const volume = e.target.value / 100 * 0.3;
                document.getElementById('volumeValue').textContent = e.target.value + '%';
                if (gainNode) {
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                }
            });
            
            // Preset-Buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    loadPreset(this.dataset.preset);
                });
            });
            
            // Datei-Management
            document.getElementById('loadConfigButton').addEventListener('click', () => {
                document.getElementById('configFileInput').click();
            });
            document.getElementById('configFileInput').addEventListener('change', loadConfiguration);
            
            document.getElementById('loadAnalysisButton').addEventListener('click', () => {
                document.getElementById('analysisFileInput').click();
            });
            document.getElementById('analysisFileInput').addEventListener('change', loadAnalysisData);
            
            document.getElementById('saveConfigButton').addEventListener('click', saveConfiguration);
            document.getElementById('saveAnalysisButton').addEventListener('click', saveAnalysisData);
            
            // Datei-Kontrollen
            document.getElementById('loadFileButton').addEventListener('click', () => {
                document.getElementById('audioFileInput').click();
            });
            document.getElementById('audioFileInput').addEventListener('change', loadAudioFile);
            document.getElementById('playFileButton').addEventListener('click', playAudioFile);
            document.getElementById('stopFileButton').addEventListener('click', stopAudioFile);
            document.getElementById('fileVolume').addEventListener('input', function(e) {
                const volume = e.target.value / 100;
                document.getElementById('fileVolumeValue').textContent = e.target.value + '%';
                if (fileGainNode) {
                    fileGainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                }
            });
            
            // Home-Button
            document.getElementById('homeButton').addEventListener('click', function() {
                window.open('https://jpascher.github.io/T0-Time-Mass-Duality/index.html', '_blank');
            });
            
            // Konfiguration-Preview aktualisieren
            setInterval(updateConfigPreview, 2000);
            
            // Parameter-Kontrollen
            document.getElementById('harmonicRange').addEventListener('input', function(e) {
                harmonicAnalyzer.harmonicRange = parseInt(e.target.value);
                document.getElementById('harmonicRangeValue').textContent = e.target.value;
            });
            
            document.getElementById('xiTolerance').addEventListener('input', function(e) {
                harmonicAnalyzer.xiTolerance = parseFloat(e.target.value);
                document.getElementById('xiToleranceValue').textContent = e.target.value + '¢';
            });
            
            document.getElementById('rationalLimit').addEventListener('input', function(e) {
                harmonicAnalyzer.rationalLimit = parseInt(e.target.value);
                document.getElementById('rationalLimitValue').textContent = e.target.value;
            });
            
            document.getElementById('eulerLimit').addEventListener('input', function(e) {
                harmonicAnalyzer.eulerLimit = parseInt(e.target.value);
                document.getElementById('eulerLimitValue').textContent = e.target.value;
            });
            
            document.getElementById('updateRate').addEventListener('input', function(e) {
                document.getElementById('updateRateValue').textContent = e.target.value + 'ms';
            });
            
            // Analyse-Kontrollen
            document.getElementById('startAnalysis').addEventListener('click', startAnalysis);
            document.getElementById('stopAnalysis').addEventListener('click', stopAnalysis);
            
            // Spektrum-Kontrollen
            document.getElementById('spectrumScale').addEventListener('change', updateSpectrum);
            document.getElementById('showRatios').addEventListener('change', updateSpectrum);
            document.getElementById('showOctaves').addEventListener('change', updateSpectrum);
            document.getElementById('colorCoding').addEventListener('change', updateSpectrum);
            
            // Log-Kontrollen
            document.getElementById('clearLog').addEventListener('click', clearLog);
            document.getElementById('exportLog').addEventListener('click', exportLog);
            
            // Canvas-Events
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseleave', hideHarmonicInfo);
        }

        function handleAudioSourceChange() {
            const source = document.getElementById('audioSource').value;
            const micControls = document.getElementById('micControls');
            const generatorControls = document.getElementById('generatorControls');
            const fileControls = document.getElementById('fileControls');
            
            // Alle Kontrollen verstecken
            micControls.style.display = 'none';
            generatorControls.style.display = 'none';
            fileControls.style.display = 'none';
            
            // Alle Audio-Quellen stoppen
            stopMicrophone();
            stopGenerator();
            stopAudioFile();
            
            if (source === 'microphone') {
                micControls.style.display = 'block';
            } else if (source === 'generator') {
                generatorControls.style.display = 'block';
                updateFrequencyInputs();
            } else if (source === 'file') {
                fileControls.style.display = 'block';
            }
        }

        async function toggleMicrophone() {
            if (micStream) {
                stopMicrophone();
            } else {
                await startMicrophone();
            }
        }

        async function startMicrophone() {
            try {
                logMessage('Mikrofon-Zugriff wird angefordert...', 'analysis');
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100
                    }
                });
                
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                micStream = stream;
                micSource = audioContext.createMediaStreamSource(stream);
                micAnalyser = audioContext.createAnalyser();
                micAnalyser.fftSize = 2048;
                micAnalyser.smoothingTimeConstant = 0.8;
                
                micSource.connect(micAnalyser);
                
                document.getElementById('micButton').textContent = '🔴 Mikrofon Stoppen';
                document.getElementById('micButton').style.background = 'linear-gradient(45deg, #ff4444, #cc0000)';
                
                logMessage('Mikrofon erfolgreich gestartet', 'analysis');
                
                // Starte Pegel-Anzeige
                updateMicLevel();
                
            } catch (error) {
                logMessage('Fehler beim Mikrofon-Zugriff: ' + error.message, 'error');
            }
        }

        function stopMicrophone() {
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
                micStream = null;
            }
            
            if (micSource) {
                micSource.disconnect();
                micSource = null;
            }
            
            micAnalyser = null;
            
            document.getElementById('micButton').textContent = '🎤 Mikrofon Starten';
            document.getElementById('micButton').style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
            
            document.getElementById('micLevelBar').style.width = '0%';
            
            logMessage('Mikrofon gestoppt', 'analysis');
        }

        function updateMicLevel() {
            if (!micAnalyser) return;
            
            const bufferLength = micAnalyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            micAnalyser.getByteFrequencyData(dataArray);
            
            // Berechne RMS mit verbesserter Rauschfilterung
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i] * dataArray[i];
            }
            let rms = Math.sqrt(sum / bufferLength);
            
            // Empfindlichkeits- und Rausch-Parameter anwenden
            const sensitivity = parseFloat(document.getElementById('micSensitivity').value);
            const noiseThreshold = parseFloat(document.getElementById('noiseThreshold').value);
            const micGain = parseFloat(document.getElementById('micGain').value);
            
            // Rauschunterdrückung anwenden
            if (rms < noiseThreshold) {
                rms = 0;
            } else {
                rms = Math.max(0, rms - noiseThreshold);
            }
            
            // Verstärkung und Empfindlichkeit anwenden
            rms = rms * micGain * sensitivity;
            
            // Pegel begrenzen und glätten
            const level = Math.min(100, Math.max(0, (rms / 128) * 100));
            
            document.getElementById('micLevelBar').style.width = level + '%';
            
            requestAnimationFrame(updateMicLevel);
        }

        function startAnalysis() {
            if (analysisActive) return;
            
            const audioSource = document.getElementById('audioSource').value;
            
            if (audioSource === 'microphone' && !micAnalyser) {
                logMessage('Mikrofon nicht verfügbar - bitte zuerst starten', 'error');
                return;
            }
            
            analysisActive = true;
            document.getElementById('startAnalysis').textContent = '🔄 Analyse läuft...';
            document.getElementById('startAnalysis').disabled = true;
            
            const updateRate = parseInt(document.getElementById('updateRate').value);
            
            logMessage('Harmonische Analyse gestartet', 'analysis');
            
            analysisInterval = setInterval(() => {
                performHarmonicAnalysis();
            }, updateRate);
        }

        function stopAnalysis() {
            if (!analysisActive) return;
            
            analysisActive = false;
            
            if (analysisInterval) {
                clearInterval(analysisInterval);
                analysisInterval = null;
            }
            
            document.getElementById('startAnalysis').textContent = '🚀 Analyse Starten';
            document.getElementById('startAnalysis').disabled = false;
            
            logMessage('Harmonische Analyse gestoppt', 'analysis');
        }

        function performHarmonicAnalysis() {
            const audioSource = document.getElementById('audioSource').value;
            
            if (audioSource === 'microphone' && micAnalyser) {
                const bufferLength = micAnalyser.fftSize;
                const timeData = new Float32Array(bufferLength);
                micAnalyser.getFloatTimeDomainData(timeData);
                
                // Verbesserte Rauschfilterung für Mikrofon-Daten
                const sensitivity = parseFloat(document.getElementById('micSensitivity').value);
                const noiseThreshold = parseFloat(document.getElementById('noiseThreshold').value) / 1000; // Normalisiert
                const micGain = parseFloat(document.getElementById('micGain').value);
                
                // Anwenden der Mikrofon-Parameter auf die Zeitdaten
                const processedData = new Float32Array(bufferLength);
                for (let i = 0; i < bufferLength; i++) {
                    let sample = timeData[i] * micGain * sensitivity;
                    // Rauschunterdrückung
                    if (Math.abs(sample) < noiseThreshold) {
                        sample = 0;
                    }
                    processedData[i] = sample;
                }
                
                const sampleRate = audioContext.sampleRate;
                const detectedHarmonics = harmonicAnalyzer.analyzeHarmonics(processedData, sampleRate);
                
                updateSpectrum();
                updateIntervalDisplay();
                updateHarmonicSeriesDisplay();
                
                if (detectedHarmonics.length > 0) {
                    logMessage(`${detectedHarmonics.length} Harmonische erkannt (Mikrofon, Sens: ${sensitivity}, Rausch: ${noiseThreshold.toFixed(3)})`, 'detection');
                }
            } else if (audioSource === 'file' && fileActive && micAnalyser) {
                const bufferLength = micAnalyser.fftSize;
                const timeData = new Float32Array(bufferLength);
                micAnalyser.getFloatTimeDomainData(timeData);
                
                const sampleRate = audioContext.sampleRate;
                const detectedHarmonics = harmonicAnalyzer.analyzeHarmonics(timeData, sampleRate);
                
                updateSpectrum();
                updateIntervalDisplay();
                updateHarmonicSeriesDisplay();
                
                if (detectedHarmonics.length > 0) {
                    logMessage(`${detectedHarmonics.length} Harmonische erkannt (Datei)`, 'detection');
                }
            } else if (audioSource === 'generator' && generatorActive) {
                // Simuliere Harmonik-Erkennung für Generator-Signale
                harmonicAnalyzer.detectedHarmonics = [];
                
                currentFrequencies.forEach((freq, index) => {
                    const rational = harmonicAnalyzer.approximateRational(freq / currentFrequencies[0], 100);
                    const eulerGradus = harmonicAnalyzer.calculateEulerGradus(rational);
                    
                    harmonicAnalyzer.detectedHarmonics.push({
                        frequency: freq,
                        harmonic: freq / currentFrequencies[0],
                        magnitude: 1.0 - (index * 0.1), // Simulierte Magnitude
                        rational: rational,
                        eulerGradus: eulerGradus
                    });
                });
                
                harmonicAnalyzer.detectIntervals();
                
                updateSpectrum();
                updateIntervalDisplay();
                updateHarmonicSeriesDisplay();
                
                logMessage(`${currentFrequencies.length} Generator-Frequenzen analysiert`, 'detection');
            }
        }

        function updateSpectrum() {
            if (!ctx || !canvas) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            // Lösche Canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, width, height);
            
            const harmonics = harmonicAnalyzer.detectedHarmonics;
            if (harmonics.length === 0) return;
            
            const scale = document.getElementById('spectrumScale').value;
            const showRatios = document.getElementById('showRatios').checked;
            const showOctaves = document.getElementById('showOctaves').checked;
            const colorCoding = document.getElementById('colorCoding').value;
            
            // Zeichne Grundfrequenz-Linie
            const fundamentalX = getXPosition(harmonicAnalyzer.fundamentalFreq, scale, width);
            ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
            ctx.fillRect(fundamentalX - 2, 0, 4, height);
            
            // Zeichne Oktav-Marker
            if (showOctaves) {
                for (let octave = 1; octave <= 8; octave++) {
                    const octaveFreq = harmonicAnalyzer.fundamentalFreq * Math.pow(2, octave);
                    const octaveX = getXPosition(octaveFreq, scale, width);
                    
                    if (octaveX > 0 && octaveX < width) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.fillRect(octaveX - 1, 0, 2, height);
                    }
                }
            }
            
            // Zeichne Harmonische
            harmonics.forEach((harmonic, index) => {
                const x = getXPosition(harmonic.frequency, scale, width);
                const barHeight = (harmonic.magnitude * height * 0.8);
                
                if (x < 0 || x > width) return;
                
                // Bestimme Farbe basierend auf Kodierung
                let color = getHarmonicColor(harmonic, colorCoding);
                
                // Zeichne Harmonik-Balken
                ctx.fillStyle = color;
                ctx.fillRect(x - 3, height - barHeight, 6, barHeight);
                
                // Zeichne Verhältnis-Label
                if (showRatios) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(harmonic.rational.toString(), x, height - barHeight - 5);
                }
                
                // Zeichne Frequenz-Label
                ctx.fillStyle = '#ffd700';
                ctx.font = '8px Arial';
                ctx.fillText(harmonic.frequency.toFixed(1), x, height - 5);
            });
            
            // Zeichne Frequenz-Achse
            drawFrequencyAxis(width, height, scale);
        }

        function getXPosition(frequency, scale, width) {
            const minFreq = 20;
            const maxFreq = 2000;
            
            if (scale === 'log') {
                const logMin = Math.log10(minFreq);
                const logMax = Math.log10(maxFreq);
                const logFreq = Math.log10(frequency);
                return ((logFreq - logMin) / (logMax - logMin)) * width;
            } else if (scale === 'rational') {
                // Rationale Skalierung basierend auf harmonischen Verhältnissen
                const ratio = frequency / harmonicAnalyzer.fundamentalFreq;
                const maxRatio = maxFreq / harmonicAnalyzer.fundamentalFreq;
                return (ratio / maxRatio) * width;
            } else {
                // Linear
                return ((frequency - minFreq) / (maxFreq - minFreq)) * width;
            }
        }

        function getHarmonicColor(harmonic, colorCoding) {
            switch (colorCoding) {
                case 'frequency':
                    const hue = (harmonic.frequency / 2000) * 120 + 240;
                    return `hsl(${hue}, 70%, 60%)`;
                    
                case 'ratio':
                    const ratio = harmonic.rational.toFloat();
                    const ratioHue = (ratio % 1) * 360;
                    return `hsl(${ratioHue}, 80%, 60%)`;
                    
                case 'euler':
                    const eulerHue = (6 - harmonic.eulerGradus) * 60;
                    return `hsl(${eulerHue}, 90%, 60%)`;
                    
                case 'deviation':
                    const deviation = Math.abs(harmonic.harmonic - Math.round(harmonic.harmonic));
                    const devHue = (1 - deviation) * 120;
                    return `hsl(${devHue}, 80%, 60%)`;
                    
                default:
                    return '#4CAF50';
            }
        }

        function drawFrequencyAxis(width, height, scale) {
            const minFreq = 20;
            const maxFreq = 2000;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            
            // Zeichne Frequenz-Markierungen
            const frequencies = [50, 100, 200, 500, 1000, 2000];
            
            frequencies.forEach(freq => {
                const x = getXPosition(freq, scale, width);
                
                if (x > 0 && x < width) {
                    ctx.beginPath();
                    ctx.moveTo(x, height - 20);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(freq + 'Hz', x, height - 25);
                }
            });
        }

        function updateIntervalDisplay() {
            const container = document.getElementById('detectedIntervals');
            const intervals = harmonicAnalyzer.intervals;
            
            if (intervals.length === 0) {
                container.innerHTML = '<div style="text-align: center; opacity: 0.6; grid-column: 1/-1;">Keine Intervalle erkannt</div>';
                return;
            }
            
            container.innerHTML = intervals.map(interval => {
                // Sichere Behandlung der rationalen Zahl
                let rationalStr = 'N/A';
                if (interval.rational) {
                    if (typeof interval.rational.toString === 'function') {
                        rationalStr = interval.rational.toString();
                    } else if (interval.rational.numerator !== undefined && interval.rational.denominator !== undefined) {
                        rationalStr = `${interval.rational.numerator}/${interval.rational.denominator}`;
                    }
                }
                
                return `
                    <div class="interval-card">
                        <div class="interval-ratio">${rationalStr}</div>
                        <div class="interval-name">${interval.name || 'Unbekannt'}</div>
                        <div class="interval-deviation">${interval.cents ? interval.cents.toFixed(1) : 'N/A'}¢</div>
                        <div style="font-size: 10px; opacity: 0.8;">
                            ${interval.freq1 ? interval.freq1.toFixed(1) : 'N/A'}Hz → ${interval.freq2 ? interval.freq2.toFixed(1) : 'N/A'}Hz
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateHarmonicSeriesDisplay() {
            const container = document.getElementById('harmonicSeriesDisplay');
            const harmonics = harmonicAnalyzer.detectedHarmonics;
            
            if (harmonics.length === 0) {
                container.innerHTML = '<div style="text-align: center; opacity: 0.6;">Keine Harmonische erkannt</div>';
                return;
            }
            
            let display = `Fundamental: ${harmonicAnalyzer.fundamentalFreq.toFixed(2)}Hz\n`;
            display += `Erkannte Harmonische: ${harmonics.length}\n\n`;
            
            harmonics.forEach((harmonic, index) => {
                // Sichere Behandlung der rationalen Zahl
                let rationalStr = 'N/A';
                if (harmonic.rational) {
                    if (typeof harmonic.rational.toString === 'function') {
                        rationalStr = harmonic.rational.toString();
                    } else if (harmonic.rational.numerator !== undefined && harmonic.rational.denominator !== undefined) {
                        rationalStr = `${harmonic.rational.numerator}/${harmonic.rational.denominator}`;
                    }
                }
                
                display += `${index + 1}. ${rationalStr} = ${harmonic.frequency.toFixed(2)}Hz `;
                display += `(Mag: ${harmonic.magnitude.toFixed(3)}, Euler: ${harmonic.eulerGradus || 'N/A'})\n`;
            });
            
            container.innerHTML = `<pre>${display}</pre>`;
        }

        function handleCanvasMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Finde nächste Harmonische
            const harmonics = harmonicAnalyzer.detectedHarmonics;
            const scale = document.getElementById('spectrumScale').value;
            
            let closestHarmonic = null;
            let minDistance = Infinity;
            
            harmonics.forEach(harmonic => {
                const harmonicX = getXPosition(harmonic.frequency, scale, canvas.width);
                const distance = Math.abs(x - harmonicX);
                
                if (distance < minDistance && distance < 10) {
                    minDistance = distance;
                    closestHarmonic = harmonic;
                }
            });
            
            if (closestHarmonic) {
                showHarmonicInfo(closestHarmonic, event.clientX, event.clientY);
            } else {
                hideHarmonicInfo();
            }
        }

        function showHarmonicInfo(harmonic, x, y) {
            const info = document.getElementById('harmonicInfo');
            
            info.innerHTML = `
                <strong>Harmonische ${harmonic.rational.toString()}</strong><br>
                Frequenz: ${harmonic.frequency.toFixed(2)} Hz<br>
                Magnitude: ${harmonic.magnitude.toFixed(3)}<br>
                Euler-Gradus: ${harmonic.eulerGradus}<br>
                Verhältnis: ${harmonic.rational.toFloat().toFixed(4)}
            `;
            
            info.style.left = (x + 10) + 'px';
            info.style.top = (y - 10) + 'px';
            info.style.display = 'block';
        }

        function hideHarmonicInfo() {
            document.getElementById('harmonicInfo').style.display = 'none';
        }

        function updateFrequencyInputs() {
            const mode = document.getElementById('generatorMode').value;
            const container = document.getElementById('frequencyInputs');
            
            let frequencies = [];
            
            switch(mode) {
                case 'single':
                    frequencies = [440];
                    break;
                case 'chord':
                    frequencies = [261.63, 329.63, 392.00]; // C-E-G
                    break;
                case 'harmonic':
                    const base = parseFloat(document.getElementById('fundamentalFreq').value);
                    frequencies = [base, base*2, base*3, base*4, base*5];
                    break;
                case 'beating':
                    frequencies = [440, 442];
                    break;
                case 'custom':
                    frequencies = [220, 330, 440, 550, 660, 770];
                    break;
                case 'test_intervals':
                    frequencies = generateJustIntonationTest();
                    break;
                case 'test_scales':
                    frequencies = generateScaleTest();
                    break;
                case 'test_rationals':
                    frequencies = generateRationalTest();
                    break;
            }
            
            currentFrequencies = frequencies;
            renderFrequencyInputs(frequencies);
        }

        function renderFrequencyInputs(frequencies) {
            const container = document.getElementById('frequencyInputs');
            container.innerHTML = '';
            
            frequencies.forEach((freq, index) => {
                const group = document.createElement('div');
                group.className = 'freq-input-group';
                
                const rational = harmonicAnalyzer.approximateRational(freq / frequencies[0], 100);
                const interval = getIntervalInfo(freq, frequencies[0]);
                
                group.innerHTML = `
                    <label for="freq${index}">Frequenz ${index + 1}</label>
                    <input type="number" id="freq${index}" min="20" max="5000" value="${freq.toFixed(2)}" step="0.1">
                    <div class="freq-display">${freq.toFixed(2)} Hz</div>
                    <div class="interval-display">Verhältnis: ${rational.toString()} | ${interval}</div>
                `;
                
                container.appendChild(group);
                
                // Event Listener für Input-Änderungen
                document.getElementById(`freq${index}`).addEventListener('input', function(e) {
                    const newFreq = parseFloat(e.target.value);
                    currentFrequencies[index] = newFreq;
                    updateFrequencyDisplay(index, newFreq);
                });
            });
        }

        function updateFrequencyDisplay(index, frequency) {
            const baseFreq = currentFrequencies[0];
            const rational = harmonicAnalyzer.approximateRational(frequency / baseFreq, 100);
            const interval = getIntervalInfo(frequency, baseFreq);
            
            const group = document.getElementById(`freq${index}`).parentElement;
            const freqDisplay = group.querySelector('.freq-display');
            const intervalDisplay = group.querySelector('.interval-display');
            
            freqDisplay.textContent = `${frequency.toFixed(2)} Hz`;
            intervalDisplay.textContent = `Verhältnis: ${rational.toString()} | ${interval}`;
        }

        function getIntervalInfo(freq1, freq2) {
            const ratio = freq1 / freq2;
            const cents = Math.abs(1200 * Math.log2(ratio));
            
            // Bekannte Intervalle
            const intervals = {
                1: 'Unison',
                2: 'Oktave',
                1.5: 'Quinte',
                1.333: 'Quarte',
                1.25: 'Große Terz',
                1.2: 'Kleine Terz',
                1.125: 'Ganzton'
            };
            
            let bestMatch = 'Unbekannt';
            let minDeviation = Infinity;
            
            for (const [r, name] of Object.entries(intervals)) {
                const deviation = Math.abs(ratio - parseFloat(r));
                if (deviation < minDeviation) {
                    minDeviation = deviation;
                    bestMatch = name;
                }
            }
            
            return `${bestMatch} (${cents.toFixed(1)}¢)`;
        }

        // Test-Frequenz-Generatoren
        function generateJustIntonationTest() {
            const base = parseFloat(document.getElementById('fundamentalFreq').value);
            return [
                base,           // 1/1 Unison
                base * 16/15,   // 16/15 Halbton
                base * 9/8,     // 9/8 Ganzton
                base * 6/5,     // 6/5 Kleine Terz
                base * 5/4,     // 5/4 Große Terz
                base * 4/3,     // 4/3 Quarte
                base * 3/2,     // 3/2 Quinte
                base * 2        // 2/1 Oktave
            ];
        }

        function generateScaleTest() {
            const base = parseFloat(document.getElementById('fundamentalFreq').value);
            // C-Dur in Just Intonation
            return [
                base,           // C
                base * 9/8,     // D
                base * 5/4,     // E
                base * 4/3,     // F
                base * 3/2,     // G
                base * 5/3,     // A
                base * 15/8     // B
            ];
        }

        function generateRationalTest() {
            const base = parseFloat(document.getElementById('fundamentalFreq').value);
            return [
                base,           // 1/1
                base * 3/2,     // 3/2
                base * 4/3,     // 4/3
                base * 5/4,     // 5/4
                base * 6/5,     // 6/5
                base * 7/6,     // 7/6
                base * 8/7,     // 8/7
                base * 9/8      // 9/8
            ];
        }

        // Preset-Loader
        function loadPreset(presetName) {
            const base = parseFloat(document.getElementById('fundamentalFreq').value);
            let frequencies = [];
            
            switch(presetName) {
                case 'unison':
                    frequencies = [base];
                    break;
                case 'octave':
                    frequencies = [base, base * 2];
                    break;
                case 'fifth':
                    frequencies = [base, base * 3/2];
                    break;
                case 'fourth':
                    frequencies = [base, base * 4/3];
                    break;
                case 'major3rd':
                    frequencies = [base, base * 5/4];
                    break;
                case 'minor3rd':
                    frequencies = [base, base * 6/5];
                    break;
                case 'major_chord':
                    frequencies = [base, base * 5/4, base * 3/2];
                    break;
                case 'minor_chord':
                    frequencies = [base, base * 6/5, base * 3/2];
                    break;
                case 'dim_chord':
                    frequencies = [base, base * 6/5, base * 64/45];
                    break;
                case 'aug_chord':
                    frequencies = [base, base * 5/4, base * 25/16];
                    break;
                case 'sus2_chord':
                    frequencies = [base, base * 9/8, base * 3/2];
                    break;
                case 'sus4_chord':
                    frequencies = [base, base * 4/3, base * 3/2];
                    break;
                case 'harmonic_series':
                    frequencies = [base, base*2, base*3, base*4, base*5, base*6];
                    break;
                case 'prime_ratios':
                    frequencies = [base, base*2, base*3, base*5, base*7, base*11];
                    break;
                case 'euler_simple':
                    frequencies = [base, base*2, base*3/2, base*4/3, base*5/4];
                    break;
                case 'xi_test':
                    // Test für verschiedene ξ-Parameter Toleranzen
                    frequencies = [
                        base,
                        base * 1.01,    // 1 Cent Abweichung
                        base * 1.05,    // ~50 Cent
                        base * 1.1      // ~100 Cent
                    ];
                    break;
            }
            
            currentFrequencies = frequencies;
            renderFrequencyInputs(frequencies);
            
            logMessage(`Preset geladen: ${presetName} (${frequencies.length} Frequenzen)`, 'detection');
        }

        // Generator-Funktionen
        function startGenerator() {
            if (!audioContext) {
                initAudioContext();
            }
            
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            stopGenerator(); // Stoppe vorherige Oszillatoren
            
            const waveform = document.getElementById('waveform').value;
            const volume = document.getElementById('masterVolume').value / 100 * 0.3;
            
            currentFrequencies.forEach(freq => {
                const oscillator = audioContext.createOscillator();
                const oscGain = audioContext.createGain();
                
                oscillator.type = waveform;
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                
                oscGain.gain.setValueAtTime(volume / currentFrequencies.length, audioContext.currentTime);
                
                oscillator.connect(oscGain);
                oscGain.connect(gainNode || audioContext.destination);
                
                oscillator.start();
                oscillators.push(oscillator);
            });
            
            generatorActive = true;
            document.getElementById('playButton').textContent = '🔄 Generator läuft';
            document.getElementById('playButton').disabled = true;
            
            logMessage(`Generator gestartet: ${currentFrequencies.length} Frequenzen`, 'analysis');
            
            // Starte automatisch die Analyse für Generator-Signale
            if (!analysisActive) {
                setTimeout(() => {
                    document.getElementById('startAnalysis').click();
                }, 500);
            }
        }

        function stopGenerator() {
            oscillators.forEach(osc => {
                try {
                    osc.stop();
                    osc.disconnect();
                } catch (e) {
                    // Oscillator bereits gestoppt
                }
            });
            oscillators = [];
            
            generatorActive = false;
            document.getElementById('playButton').textContent = '▶️ Generator Starten';
            document.getElementById('playButton').disabled = false;
            
            logMessage('Generator gestoppt', 'analysis');
        }

        function initAudioContext() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                gainNode.gain.value = 0.3;
                gainNode.connect(audioContext.destination);
                
                logMessage('Audio-Context initialisiert', 'analysis');
            } catch (error) {
                logMessage('Fehler beim Audio-Context: ' + error.message, 'error');
            }
        }

        function clearLog() {
            document.getElementById('analysisLog').innerHTML = '';
            logMessage('Log gelöscht', 'analysis');
        }

        function exportLog() {
            const log = document.getElementById('analysisLog');
            const content = Array.from(log.children).map(entry => entry.textContent).join('\n');
            
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `harmonic-analysis-log-${new Date().toISOString().slice(0, 19)}.txt`;
            a.click();
            
            URL.revokeObjectURL(url);
            logMessage('Log exportiert', 'analysis');
        }

        // Audio-Datei Funktionen
        async function loadAudioFile(event) {
            const file = event.target.files[0];
            
            if (!file) {
                logMessage('Keine Datei ausgewählt', 'error');
                return;
            }
            
            try {
                if (!audioContext) {
                    initAudioContext();
                }
                
                logMessage('Lade Audio-Datei: ' + file.name, 'analysis');
                
                const arrayBuffer = await file.arrayBuffer();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // Datei-Info anzeigen
                const duration = audioBuffer.duration.toFixed(2);
                const sampleRate = audioBuffer.sampleRate;
                const channels = audioBuffer.numberOfChannels;
                const fileSize = (file.size / (1024 * 1024)).toFixed(2);
                
                document.getElementById('fileInfo').innerHTML = `
                    <strong>📁 ${file.name}</strong><br>
                    <span style="color: #00ff00;">⏱️ Dauer: ${duration}s</span><br>
                    <span style="color: #ffd700;">🎵 Sample Rate: ${sampleRate}Hz</span><br>
                    <span style="color: #ff8c00;">🔊 Kanäle: ${channels}</span><br>
                    <span style="color: #00ffff;">💾 Größe: ${fileSize}MB</span>
                `;
                
                document.getElementById('playFileButton').disabled = false;
                
                logMessage(`Audio-Datei geladen: ${file.name} (${duration}s, ${channels} Kanäle, ${fileSize}MB)`, 'analysis');
                
            } catch (error) {
                logMessage('Fehler beim Laden der Datei: ' + error.message, 'error');
                document.getElementById('fileInfo').innerHTML = `
                    <span style="color: #ff4444;">❌ Fehler beim Laden der Datei</span><br>
                    ${error.message}
                `;
            }
        }

        function playAudioFile() {
            if (!audioBuffer) {
                logMessage('Keine Audio-Datei geladen', 'error');
                return;
            }
            
            try {
                stopAudioFile(); // Stoppe vorherige Wiedergabe
                
                audioSource = audioContext.createBufferSource();
                audioSource.buffer = audioBuffer;
                
                fileGainNode = audioContext.createGain();
                const volume = document.getElementById('fileVolume').value / 100;
                fileGainNode.gain.value = volume;
                
                // Für Analyse vorbereiten
                if (!micAnalyser) {
                    micAnalyser = audioContext.createAnalyser();
                    micAnalyser.fftSize = 2048;
                    micAnalyser.smoothingTimeConstant = 0.8;
                }
                
                audioSource.connect(fileGainNode);
                fileGainNode.connect(micAnalyser);
                fileGainNode.connect(audioContext.destination);
                
                audioSource.start();
                fileActive = true;
                
                document.getElementById('playFileButton').disabled = true;
                document.getElementById('stopFileButton').disabled = false;
                
                // Automatisch stoppen, wenn Datei zu Ende ist
                audioSource.onended = () => {
                    stopAudioFile();
                };
                
                logMessage('Audio-Datei wird abgespielt', 'analysis');
                
                // Starte automatisch die Analyse
                if (!analysisActive) {
                    setTimeout(() => {
                        document.getElementById('startAnalysis').click();
                    }, 500);
                }
                
            } catch (error) {
                logMessage('Fehler beim Abspielen: ' + error.message, 'error');
            }
        }

        function stopAudioFile() {
            if (audioSource) {
                try {
                    audioSource.stop();
                    audioSource.disconnect();
                } catch (e) {
                    // Source bereits gestoppt
                }
                audioSource = null;
            }
            
            if (fileGainNode) {
                fileGainNode.disconnect();
                fileGainNode = null;
            }
            
            fileActive = false;
            
            document.getElementById('playFileButton').disabled = false;
            document.getElementById('stopFileButton').disabled = true;
            
            logMessage('Audio-Datei gestoppt', 'analysis');
        }

        // Konfiguration-Management
        function getCurrentConfiguration() {
            return {
                audioSource: document.getElementById('audioSource').value,
                generatorMode: document.getElementById('generatorMode').value,
                masterVolume: document.getElementById('masterVolume').value,
                waveform: document.getElementById('waveform').value,
                fundamentalFreq: document.getElementById('fundamentalFreq').value,
                harmonicRange: document.getElementById('harmonicRange').value,
                // Mikrofon-Parameter
                micSensitivity: document.getElementById('micSensitivity').value,
                noiseThreshold: document.getElementById('noiseThreshold').value,
                micGain: document.getElementById('micGain').value,
                // ξ-Parameter
                xiTolerance: document.getElementById('xiTolerance').value,
                xiProfile: document.getElementById('xiProfile').value,
                rationalLimit: document.getElementById('rationalLimit').value,
                eulerLimit: document.getElementById('eulerLimit').value,
                analysisType: document.getElementById('analysisType').value,
                detectionMethod: document.getElementById('detectionMethod').value,
                updateRate: document.getElementById('updateRate').value,
                spectrumScale: document.getElementById('spectrumScale').value,
                showRatios: document.getElementById('showRatios').checked,
                showOctaves: document.getElementById('showOctaves').checked,
                colorCoding: document.getElementById('colorCoding').value,
                intervalSensitivity: document.getElementById('intervalSensitivity').value,
                currentFrequencies: currentFrequencies,
                timestamp: new Date().toISOString()
            };
        }

        function applyConfiguration(config) {
            try {
                // Basis-Einstellungen
                if (config.audioSource) document.getElementById('audioSource').value = config.audioSource;
                if (config.generatorMode) document.getElementById('generatorMode').value = config.generatorMode;
                if (config.masterVolume) {
                    document.getElementById('masterVolume').value = config.masterVolume;
                    document.getElementById('volumeValue').textContent = config.masterVolume + '%';
                }
                if (config.waveform) document.getElementById('waveform').value = config.waveform;
                if (config.fundamentalFreq) document.getElementById('fundamentalFreq').value = config.fundamentalFreq;
                if (config.harmonicRange) {
                    document.getElementById('harmonicRange').value = config.harmonicRange;
                    document.getElementById('harmonicRangeValue').textContent = config.harmonicRange;
                }
                
                // Mikrofon-Parameter
                if (config.micSensitivity) {
                    document.getElementById('micSensitivity').value = config.micSensitivity;
                    document.getElementById('micSensitivityValue').textContent = config.micSensitivity;
                }
                if (config.noiseThreshold) {
                    document.getElementById('noiseThreshold').value = config.noiseThreshold;
                    document.getElementById('noiseThresholdValue').textContent = config.noiseThreshold;
                }
                if (config.micGain) {
                    document.getElementById('micGain').value = config.micGain;
                    document.getElementById('micGainValue').textContent = config.micGain;
                }
                
                // ξ-Parameter
                if (config.xiTolerance) {
                    document.getElementById('xiTolerance').value = config.xiTolerance;
                    document.getElementById('xiToleranceValue').textContent = config.xiTolerance + '¢';
                    harmonicAnalyzer.xiTolerance = parseFloat(config.xiTolerance);
                }
                if (config.xiProfile) document.getElementById('xiProfile').value = config.xiProfile;
                if (config.rationalLimit) {
                    document.getElementById('rationalLimit').value = config.rationalLimit;
                    document.getElementById('rationalLimitValue').textContent = config.rationalLimit;
                    harmonicAnalyzer.rationalLimit = parseInt(config.rationalLimit);
                }
                if (config.eulerLimit) {
                    document.getElementById('eulerLimit').value = config.eulerLimit;
                    document.getElementById('eulerLimitValue').textContent = config.eulerLimit;
                    harmonicAnalyzer.eulerLimit = parseInt(config.eulerLimit);
                }
                
                // Analyse-Einstellungen
                if (config.analysisType) document.getElementById('analysisType').value = config.analysisType;
                if (config.detectionMethod) document.getElementById('detectionMethod').value = config.detectionMethod;
                if (config.updateRate) {
                    document.getElementById('updateRate').value = config.updateRate;
                    document.getElementById('updateRateValue').textContent = config.updateRate + 'ms';
                }
                
                // Spektrum-Einstellungen
                if (config.spectrumScale) document.getElementById('spectrumScale').value = config.spectrumScale;
                if (config.showRatios !== undefined) document.getElementById('showRatios').checked = config.showRatios;
                if (config.showOctaves !== undefined) document.getElementById('showOctaves').checked = config.showOctaves;
                if (config.colorCoding) document.getElementById('colorCoding').value = config.colorCoding;
                if (config.intervalSensitivity) {
                    document.getElementById('intervalSensitivity').value = config.intervalSensitivity;
                    document.getElementById('intervalSensitivityValue').textContent = config.intervalSensitivity;
                }
                
                // Frequenzen
                if (config.currentFrequencies && config.currentFrequencies.length > 0) {
                    currentFrequencies = config.currentFrequencies;
                    renderFrequencyInputs(currentFrequencies);
                }
                
                // UI aktualisieren
                handleAudioSourceChange();
                updateFrequencyInputs();
                
                logMessage('Konfiguration erfolgreich geladen', 'analysis');
                
            } catch (error) {
                logMessage('Fehler beim Anwenden der Konfiguration: ' + error.message, 'error');
            }
        }

        function saveConfiguration() {
            try {
                const config = getCurrentConfiguration();
                const configJson = JSON.stringify(config, null, 2);
                
                const blob = new Blob([configJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `harmonic-analyzer-config-${new Date().toISOString().slice(0, 19)}.json`;
                a.click();
                
                URL.revokeObjectURL(url);
                logMessage('Konfiguration gespeichert', 'analysis');
                
            } catch (error) {
                logMessage('Fehler beim Speichern der Konfiguration: ' + error.message, 'error');
            }
        }

        function loadConfiguration(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const config = JSON.parse(e.target.result);
                    applyConfiguration(config);
                } catch (error) {
                    logMessage('Fehler beim Laden der Konfiguration: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        function saveAnalysisData() {
            try {
                // Sichere Serialisierung der RationalNumber-Objekte
                const detectedHarmonicsSerializable = harmonicAnalyzer.detectedHarmonics.map(harmonic => ({
                    ...harmonic,
                    rational: harmonic.rational ? {
                        numerator: harmonic.rational.numerator,
                        denominator: harmonic.rational.denominator,
                        _type: 'RationalNumber'
                    } : null
                }));
                
                const intervalsSerializable = harmonicAnalyzer.intervals.map(interval => ({
                    ...interval,
                    rational: interval.rational ? {
                        numerator: interval.rational.numerator,
                        denominator: interval.rational.denominator,
                        _type: 'RationalNumber'
                    } : null
                }));
                
                const analysisData = {
                    timestamp: new Date().toISOString(),
                    version: '1.0',
                    configuration: getCurrentConfiguration(),
                    detectedHarmonics: detectedHarmonicsSerializable,
                    intervals: intervalsSerializable,
                    logEntries: Array.from(document.getElementById('analysisLog').children).map(entry => entry.textContent),
                    metadata: {
                        harmonicsCount: harmonicAnalyzer.detectedHarmonics.length,
                        intervalsCount: harmonicAnalyzer.intervals.length,
                        fundamentalFreq: harmonicAnalyzer.fundamentalFreq
                    }
                };
                
                const dataJson = JSON.stringify(analysisData, null, 2);
                
                const blob = new Blob([dataJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `harmonic-analysis-data-${new Date().toISOString().slice(0, 19)}.json`;
                a.click();
                
                URL.revokeObjectURL(url);
                logMessage(`Analyse-Daten gespeichert: ${analysisData.metadata.harmonicsCount} Harmonische, ${analysisData.metadata.intervalsCount} Intervalle`, 'analysis');
                
            } catch (error) {
                logMessage('Fehler beim Speichern der Analyse-Daten: ' + error.message, 'error');
                console.error('Save error details:', error);
            }
        }

        function loadAnalysisData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const analysisData = JSON.parse(e.target.result);
                    
                    // Konfiguration anwenden
                    if (analysisData.configuration) {
                        applyConfiguration(analysisData.configuration);
                    }
                    
                    // Analyse-Daten wiederherstellen mit korrekter Objektrekonstruktion
                    if (analysisData.detectedHarmonics) {
                        harmonicAnalyzer.detectedHarmonics = analysisData.detectedHarmonics.map(harmonic => {
                            // RationalNumber-Objekt rekonstruieren
                            if (harmonic.rational && typeof harmonic.rational === 'object') {
                                harmonic.rational = new RationalNumber(
                                    harmonic.rational.numerator, 
                                    harmonic.rational.denominator
                                );
                            }
                            return harmonic;
                        });
                    }
                    
                    if (analysisData.intervals) {
                        harmonicAnalyzer.intervals = analysisData.intervals.map(interval => {
                            // RationalNumber-Objekt rekonstruieren
                            if (interval.rational && typeof interval.rational === 'object') {
                                interval.rational = new RationalNumber(
                                    interval.rational.numerator,
                                    interval.rational.denominator
                                );
                            }
                            return interval;
                        });
                    }
                    
                    // Log-Einträge wiederherstellen (optional)
                    if (analysisData.logEntries && analysisData.logEntries.length > 0) {
                        const logContainer = document.getElementById('analysisLog');
                        logContainer.innerHTML = ''; // Vorherige Logs löschen
                        
                        analysisData.logEntries.forEach(logEntry => {
                            const entry = document.createElement('div');
                            entry.className = 'log-entry log-analysis';
                            entry.textContent = logEntry;
                            logContainer.appendChild(entry);
                        });
                        
                        logContainer.scrollTop = logContainer.scrollHeight;
                    }
                    
                    // UI aktualisieren
                    updateSpectrum();
                    updateIntervalDisplay();
                    updateHarmonicSeriesDisplay();
                    
                    logMessage('Analyse-Daten erfolgreich geladen: ' + file.name, 'analysis');
                    logMessage(`Wiederhergestellt: ${harmonicAnalyzer.detectedHarmonics.length} Harmonische, ${harmonicAnalyzer.intervals.length} Intervalle`, 'analysis');
                    
                } catch (error) {
                    logMessage('Fehler beim Laden der Analyse-Daten: ' + error.message, 'error');
                    console.error('Detailed error:', error);
                }
            };
            reader.readAsText(file);
        }

        function updateConfigPreview() {
            try {
                const config = getCurrentConfiguration();
                const preview = document.getElementById('configPreview');
                
                const previewText = `Audio-Quelle: ${config.audioSource}
Generator-Modus: ${config.generatorMode}
Grundfrequenz: ${config.fundamentalFreq} Hz
ξ-Toleranz: ${config.xiTolerance}¢
Rationale Grenze: ${config.rationalLimit}
Euler-Limit: ${config.eulerLimit}
Analyse-Typ: ${config.analysisType}
Erkennungsmethode: ${config.detectionMethod}
Aktive Frequenzen: ${config.currentFrequencies.length}`;
                
                preview.textContent = previewText;
                
            } catch (error) {
                // Fehler beim Update der Vorschau ignorieren
            }
        }

        function logMessage(message, type = 'analysis') {
            const log = document.getElementById('analysisLog');
            const timestamp = new Date().toLocaleTimeString();
            
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            
            // Begrenze Log-Einträge
            while (log.children.length > 100) {
                log.removeChild(log.firstChild);
            }
        }
    </script>
</body>
</html>