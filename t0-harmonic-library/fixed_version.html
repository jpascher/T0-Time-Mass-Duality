<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎵 Modular Audio Analyzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1em;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .test-badge {
            display: inline-block;
            background: linear-gradient(145deg, #27ae60, #229954);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(39, 174, 96, 0.3);
        }

        /* Compact Controls Above Spectrum */
        .top-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            justify-content: center;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .chord-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .chord-buttons label {
            font-size: 0.9em;
            font-weight: bold;
            color: #f1c40f;
            margin-right: 10px;
        }

        .spectrum-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            border-left: 2px solid rgba(255,255,255,0.2);
            padding-left: 15px;
            margin-left: 10px;
        }

        .spectrum-controls label {
            font-size: 0.9em;
            font-weight: bold;
            color: #3498db;
            margin-right: 10px;
        }

        button {
            background: linear-gradient(145deg, #3498db, #2980b9);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 0.85em;
            white-space: nowrap;
            min-width: 120px;
            text-align: center;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        button.active {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .chord-btn {
            min-width: 50px;
            background: linear-gradient(145deg, #f39c12, #e67e22);
        }

        .chord-btn.active {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
        }

        /* Compact Sliders */
        .bottom-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 15px;
            align-items: center;
            justify-content: center;
            padding: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 200px;
        }

        .slider-group label {
            font-size: 0.85em;
            font-weight: 600;
            white-space: nowrap;
            min-width: 60px;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.3);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #f1c40f;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            border: 2px solid #fff;
        }

        .slider-value {
            font-family: monospace;
            font-size: 0.8em;
            color: #f1c40f;
            min-width: 80px;
            text-align: right;
        }

        /* Canvas Container */
        .canvas-container {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
        }

        #spectrum-canvas {
            width: 100%;
            height: 400px;
            border-radius: 8px;
            background: #000;
            border: 2px solid rgba(255,255,255,0.1);
            cursor: crosshair;
        }

        /* Tooltip for frequency detection */
        .frequency-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8em;
            font-family: monospace;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid #f1c40f;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: none;
            max-width: 200px;
        }

        /* Compact Info Panel */
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-card {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .info-card h4 {
            color: #f1c40f;
            margin-bottom: 12px;
            font-size: 1em;
            text-align: center;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85em;
        }

        .metric:last-child {
            border-bottom: none;
        }

        .metric-value {
            font-family: monospace;
            color: #f1c40f;
        }

        .snapshot-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            padding: 8px;
        }

        .snapshot-item {
            background: rgba(255,255,255,0.1);
            margin-bottom: 6px;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 3px solid #3498db;
            font-size: 0.8em;
        }

        .snapshot-item:hover {
            background: rgba(255,255,255,0.2);
        }

        .snapshot-item.selected {
            border-left-color: #f1c40f;
            background: rgba(241, 196, 15, 0.1);
        }

        .log-panel {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            max-height: 120px;
            overflow-y: auto;
        }

        .log-entry {
            margin-bottom: 3px;
            padding: 1px 0;
        }

        .log-success { color: #2ecc71; }
        .log-warning { color: #f39c12; }
        .log-error { color: #e74c3c; }
        .log-info { color: #3498db; }

        /* Grade styling */
        .grade-a { color: #2ecc71 !important; }
        .grade-b { color: #f39c12 !important; }
        .grade-c { color: #e74c3c !important; }

        /* Responsive */
        @media (max-width: 768px) {
            .top-controls, .bottom-controls {
                flex-direction: column;
                gap: 15px;
            }
            
            .spectrum-controls {
                border-left: none;
                padding-left: 0;
                margin-left: 0;
                border-top: 2px solid rgba(255,255,255,0.2);
                padding-top: 15px;
            }
            
            .chord-buttons, .spectrum-controls {
                justify-content: center;
            }
            
            .slider-group {
                min-width: 100%;
            }
            
            .info-panel {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎵 Modular Audio Analyzer</h1>
            <div class="subtitle">Saubere Architektur - T0-Akkord-Erkennung mit Schwebungs-Analyse</div>
            <div class="test-badge">🎼 T0-HARMONIC-THEORIE + SCHWEBUNGS-ERKENNUNG</div>
        </div>

        <!-- Compact Controls Above Spectrum -->
        <div class="top-controls">
            <div class="chord-buttons">
                <label>🎼 Akkorde:</label>
                <button class="chord-btn" data-chord="single_tone" title="Einzelton mit aktueller Grundfrequenz">🎯 Einzelton</button>
                <button class="chord-btn" data-chord="major" title="C-Dur Dreiklang">Dur</button>
                <button class="chord-btn" data-chord="minor" title="C-Moll Dreiklang">Moll</button>
                <button class="chord-btn" data-chord="dom7" title="C7 Dominantseptakkord">C7</button>
                <button class="chord-btn" data-chord="maj7" title="Cmaj7 Major-Septakkord">Maj7</button>
                <button class="chord-btn" data-chord="min7" title="Cm7 Minor-Septakkord">m7</button>
                <button class="chord-btn" data-chord="sus2" title="Csus2 Suspended 2nd">Sus2</button>
                <button class="chord-btn" data-chord="sus4" title="Csus4 Suspended 4th">Sus4</button>
                <button class="chord-btn" data-chord="aug" title="C+ Übermäßiger Dreiklang">Aug</button>
                <button class="chord-btn" data-chord="dim" title="C° Verminderter Dreiklang">Dim</button>
            </div>
            
            <div class="spectrum-controls">
                <label>📊 Anzeige:</label>
                <button id="scaleBtn" title="Frequenz-Skalierung umschalten">📏 Log</button>
                <button id="zoomBtn" title="Frequenz-Bereich ändern">🔍 Full</button>
                <button id="freezeBtn" title="Spektrum einfrieren">❄️ Freeze</button>
                <button id="captureBtn" title="Raw-Buffer manuell erfassen">📊 Buffer</button>
                <button id="methodBtn" title="Analysemethode umschalten">🎼 T0-Akkord-Analyse</button>
                <button id="octaveBtn" title="Oktavreduktion umschalten">🎵 Vollspektrum</button>
                <button id="resetBtn" title="Live-Anzeige wiederherstellen">🔄 Reset</button>
                <button id="saveBtn" disabled title="Raw-Buffer als Datei speichern">💾 Save</button>
                <button id="loadBtn" title="Raw-Buffer aus Datei laden">📁 Load</button>
            </div>
        </div>

        <!-- Spectrum Canvas with Tooltip -->
        <div class="canvas-container">
            <canvas id="spectrum-canvas" width="1000" height="400"></canvas>
            <div id="frequency-tooltip" class="frequency-tooltip"></div>
        </div>

        <!-- Compact Controls Below Spectrum -->
        <div class="bottom-controls">
            <div class="slider-group">
                <label for="rootFreqSlider">🎵 Grundton:</label>
                <input type="range" id="rootFreqSlider" min="100" max="800" value="442" step="0.1">
                <div class="slider-value" id="rootFreqDisplay">442.0 Hz</div>
            </div>
            
            <div class="slider-group">
                <label for="volumeSlider">🔊 Lautstärke:</label>
                <input type="range" id="volumeSlider" min="0" max="100" value="50">
                <div class="slider-value" id="volumeDisplay">50%</div>
            </div>
            
            <div class="slider-group">
                <label for="thresholdSlider">🎯 Analyse-Schwelle:</label>
                <input type="range" id="thresholdSlider" min="0.05" max="0.5" step="0.01" value="0.15">
                <div class="slider-value" id="thresholdDisplay">15%</div>
            </div>
            
            <div class="slider-group">
                <label for="spectrumGainSlider">📈 Verstärkung:</label>
                <input type="range" id="spectrumGainSlider" min="0.1" max="5" step="0.1" value="1.0">
                <div class="slider-value" id="spectrumGainDisplay">1.0x</div>
            </div>
            
            <div class="slider-group">
                <label for="micGainSlider">🎤 Mic-Verstärkung:</label>
                <input type="range" id="micGainSlider" min="1" max="100" step="1" value="10">
                <div class="slider-value" id="micGainDisplay">10x</div>
            </div>
            
            <div class="slider-group">
                <label for="beatFreqSlider">🎵 Schwebung:</label>
                <input type="range" id="beatFreqSlider" min="0" max="10" step="0.1" value="0">
                <div class="slider-value" id="beatFreqDisplay">0.0 Hz</div>
            </div>
            
            <button id="tuningBtn" title="Stimmung umschalten zwischen Temperiert und Rein">🎼 Temperiert</button>
            <button id="waveformBtn" title="Wellenform ändern">🌊 Sinus</button>
            <button id="micBtn" title="Mikrofon ein/aus">🎤 Mikrofon</button>
            <button id="autoCaptureBtn" title="Auto-Capture bei 50% Level ein/aus">🎯 Auto-Capture</button>
        </div>

        <!-- Compact Info Panels -->
        <div class="info-panel">
            <!-- Analysis Results -->
            <div class="info-card">
                <h4>🔍 Snapshot-Analyse</h4>
                
                <div style="text-align: center; margin-bottom: 12px;">
                    <div id="analysisGrade" style="font-size: 1.8em; font-weight: bold; color: #f1c40f;">-</div>
                    <div id="analysisScore" style="font-size: 0.8em; color: rgba(255,255,255,0.8);">Wähle Snapshot für Analyse</div>
                </div>
                
                <div class="metric">
                    <span>Analysemethode:</span>
                    <span class="metric-value" id="currentMethod">Standard FFT</span>
                </div>
                <div class="metric">
                    <span>Erkannte Peaks:</span>
                    <span class="metric-value" id="peakCount">0</span>
                </div>
                <div class="metric">
                    <span>Grundfrequenz:</span>
                    <span class="metric-value" id="fundamentalFreq">-</span>
                </div>
                <div class="metric">
                    <span>Spektral-Zentroid:</span>
                    <span class="metric-value" id="spectralCentroid">-</span>
                </div>
                <div class="metric">
                    <span>Energie-Level:</span>
                    <span class="metric-value" id="energyLevel">-</span>
                </div>
                <div class="metric">
                    <span>Buffer-Größe:</span>
                    <span class="metric-value" id="bufferSize">-</span>
                </div>
                
                <div id="analysisRecommendation" style="margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 0.8em; text-align: center; color: #f39c12;">
                    Erstelle Snapshot und starte Analyse
                </div>
            </div>

            <!-- T0-Chord-Info Panel -->
            <div class="info-card">
                <h4>🎼 T0-Akkord-Erkennung</h4>
                <div class="metric">
                    <span>Erkannter Akkord:</span>
                    <span class="metric-value" id="t0DetectedChord">-</span>
                </div>
                <div class="metric">
                    <span>T0-Qualität:</span>
                    <span class="metric-value" id="t0Quality">-</span>
                </div>
                <div class="metric">
                    <span>Grundton (T0):</span>
                    <span class="metric-value" id="t0Fundamental">-</span>
                </div>
                <div class="metric">
                    <span>T0-konforme Intervalle:</span>
                    <span class="metric-value" id="t0CompliantIntervals">-</span>
                </div>
                <div class="metric">
                    <span>Durchschnitt Euler°:</span>
                    <span class="metric-value" id="avgEulerGradus">-</span>
                </div>
                <div class="metric">
                    <span>Durchschnitt ξ-Abw.:</span>
                    <span class="metric-value" id="avgXiDeviation">-</span>
                </div>
            </div>

            <!-- Detected Frequencies -->
            <div class="info-card">
                <h4 id="peaksTitle">🎯 Erkannte Peaks</h4>
                <div id="detectedPeaks" style="font-family: monospace; font-size: 0.75em; background: rgba(0,0,0,0.2); border-radius: 4px; padding: 8px; min-height: 100px;">
                    <div style="color: rgba(255,255,255,0.6); text-align: center; padding: 20px;">
                        Keine Peaks erkannt<br>
                        <small>Starte Snapshot-Analyse</small>
                    </div>
                </div>
            </div>

            <!-- Microphone Status -->
            <div class="info-card">
                <h4>🎤 Mikrofon Status</h4>
                <div class="metric">
                    <span>Status:</span>
                    <span class="metric-value" id="micStatus">Inaktiv</span>
                </div>
                <div class="metric">
                    <span>Verstärkung:</span>
                    <span class="metric-value" id="micGainStatus">1.0x</span>
                </div>
                <div class="metric">
                    <span>Audio-Quelle:</span>
                    <span class="metric-value" id="audioSource">Generator</span>
                </div>
                <div class="metric">
                    <span>Schwebung:</span>
                    <span class="metric-value" id="beatStatus">Aus</span>
                </div>
                <div class="metric">
                    <span>Auto-Capture:</span>
                    <span class="metric-value" id="autoCaptureStatus">Ein (50%)</span>
                </div>
                
                <!-- Level-Anzeige -->
                <div style="margin-top: 10px;">
                    <div style="font-size: 0.8em; margin-bottom: 5px; color: #f1c40f;">🔊 Audio-Level:</div>
                    <div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 3px; height: 20px; position: relative;">
                        <div id="micLevelBar" style="
                            width: 0%; 
                            height: 100%; 
                            background: linear-gradient(90deg, #2ecc71, #f39c12, #e74c3c); 
                            border-radius: 7px; 
                            transition: width 0.1s ease;
                        "></div>
                        <div id="micLevelText" style="
                            position: absolute; 
                            top: 50%; 
                            left: 50%; 
                            transform: translate(-50%, -50%); 
                            font-size: 0.7em; 
                            font-weight: bold; 
                            color: white; 
                            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
                        ">0%</div>
                    </div>
                </div>
            </div>

            <!-- Generator Status -->
            <div class="info-card">
                <h4>🎵 Generator Status</h4>
                <div class="metric">
                    <span>Aktuell gespielt:</span>
                    <span class="metric-value" id="generatorChord">-</span>
                </div>
                <div class="metric">
                    <span>Generator Grundton:</span>
                    <span class="metric-value" id="generatorRoot">442.0 Hz</span>
                </div>
                <div class="metric">
                    <span>Stimmungssystem:</span>
                    <span class="metric-value" id="generatorTuning">Temperiert</span>
                </div>
                <div class="metric">
                    <span>Wellenform:</span>
                    <span class="metric-value" id="generatorWave">Sinus</span>
                </div>
                <div class="metric">
                    <span>Status:</span>
                    <span class="metric-value" id="generatorStatus">Bereit</span>
                </div>
            </div>

            <!-- Snapshot List -->
            <div class="info-card">
                <h4>📊 Raw-Buffer (<span id="snapshotCount">0</span>)</h4>
                <div id="snapshotList" class="snapshot-list">
                    <div style="text-align: center; color: rgba(255,255,255,0.6); padding: 15px;">
                        Keine Raw-Buffer<br>
                        <small>Werden automatisch bei Generator-Aktivierung erstellt</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- Compact Log Panel -->
        <div class="log-panel" id="logPanel">
            <div class="log-entry log-info">🎵 Modular Audio Analyzer mit T0-Theorie und Schwebungs-Erkennung bereit</div>
        </div>
        
        <input type="file" id="fileInput" accept=".json" style="display: none;">
    </div>

    <script>
        // ============================================
        // MODULAR AUDIO ANALYZER WITH T0 CHORD RECOGNITION
        // Reparierte Version: Funktionierendes Mikrofon + Schwebungs-Erkennung
        // ============================================
        
        /**
         * T0 CHORD RECOGNITION ENGINE - Mit Schwebungs-Analyse
         */

        class T0ChordRecognitionEngine {
            constructor() {
                // T0-THEORIE AKKORD-DEFINITIONEN
                this.t0ChordDatabase = {
                    // BASIC TRIADS
                    major: {
                        intervals: [[1,1], [5,4], [3,2]], // 1:1, 5:4, 3:2
                        name: "Dur-Dreiklang",
                        quality: "consonant",
                        eulerSum: 11,
                        t0Priority: 1,
                        musicalFunction: "tonic"
                    },
                    minor: {
                        intervals: [[1,1], [6,5], [3,2]], // 1:1, 6:5, 3:2
                        name: "Moll-Dreiklang", 
                        quality: "consonant",
                        eulerSum: 12,
                        t0Priority: 2,
                        musicalFunction: "tonic"
                    },
                    diminished: {
                        intervals: [[1,1], [6,5], [7,5]], // 1:1, 6:5, 7:5
                        name: "Verminderter Dreiklang",
                        quality: "dissonant",
                        eulerSum: 17,
                        t0Priority: 8,
                        musicalFunction: "subdominant"
                    },
                    augmented: {
                        intervals: [[1,1], [5,4], [8,5]], // 1:1, 5:4, 8:5
                        name: "Übermäßiger Dreiklang",
                        quality: "dissonant", 
                        eulerSum: 17,
                        t0Priority: 9,
                        musicalFunction: "dominant"
                    },
                    // SEVENTH CHORDS
                    dominant7: {
                        intervals: [[1,1], [5,4], [3,2], [9,5]], // C7: C-E-G-Bb
                        name: "Dominantseptakkord",
                        quality: "mixed",
                        eulerSum: 20,
                        t0Priority: 3,
                        musicalFunction: "dominant"
                    },
                    major7: {
                        intervals: [[1,1], [5,4], [3,2], [15,8]], // Cmaj7: C-E-G-B
                        name: "Major-Septakkord",
                        quality: "consonant",
                        eulerSum: 28,
                        t0Priority: 4,
                        musicalFunction: "tonic"
                    },
                    minor7: {
                        intervals: [[1,1], [6,5], [3,2], [9,5]], // Cm7: C-Eb-G-Bb
                        name: "Minor-Septakkord",
                        quality: "mixed",
                        eulerSum: 21,
                        t0Priority: 5,
                        musicalFunction: "subdominant"
                    },
                    // SUSPENDED CHORDS
                    sus2: {
                        intervals: [[1,1], [9,8], [3,2]], // Csus2: C-D-G
                        name: "Sus2-Akkord",
                        quality: "open",
                        eulerSum: 17,
                        t0Priority: 6,
                        musicalFunction: "neutral"
                    },
                    sus4: {
                        intervals: [[1,1], [4,3], [3,2]], // Csus4: C-F-G
                        name: "Sus4-Akkord", 
                        quality: "open",
                        eulerSum: 11,
                        t0Priority: 7,
                        musicalFunction: "neutral"
                    }
                };

                // T0-GRUNDTON-DETECTION-STRATEGIEN
                this.fundamentalStrategies = {
                    lowestStrong: { name: "Niedrigste starke Frequenz", weight: 0.3, minAmplitude: 0.25 },
                    harmonicSeries: { name: "Harmonische Serie", weight: 0.4, maxHarmonics: 8 },
                    rationalGCD: { name: "T0-Rationaler GCD", weight: 0.3, tolerance: 0.02 }
                };

                // T0-QUALITY-ASSESSMENT-KRITERIEN
                this.qualityThresholds = {
                    excellent: { eulerGradusMax: 6, xiDeviationMax: 10, t0ComplianceMin: 0.8, harmonicClarityMin: 0.9 },
                    good: { eulerGradusMax: 8, xiDeviationMax: 25, t0ComplianceMin: 0.6, harmonicClarityMin: 0.7 },
                    acceptable: { eulerGradusMax: 12, xiDeviationMax: 50, t0ComplianceMin: 0.4, harmonicClarityMin: 0.5 }
                };
            }

            analyzeChordFromSnapshot(snapshot, options = {}) {
                const config = {
                    xiTolerance: options.xiTolerance || 50,
                    minFrequencies: options.minFrequencies || 2,
                    maxFrequencies: options.maxFrequencies || 10,
                    amplitudeThreshold: options.amplitudeThreshold || 0.1,
                    octaveReduction: options.octaveReduction || false,
                    reducedPeaks: options.reducedPeaks || null,
                    ...options
                };

                try {
                    const analysisMode = config.octaveReduction ? '[OKTAVREDUZIERT]' : '[VOLLSPEKTRUM]';
                    logMessage(`🎼 T0-Akkord-Analyse gestartet ${analysisMode}`, 'info');
                    
                    // KRITISCH: Verwende reduzierte Peaks falls Oktavreduktion aktiv
                    let frequencies;
                    if (config.octaveReduction && config.reducedPeaks) {
                        // Verwende die bereits reduzierten Peaks DIREKT
                        frequencies = config.reducedPeaks.map(peak => ({
                            frequency: peak.frequency,
                            amplitude: peak.amplitude,
                            bin: peak.bin,
                            isOctaveReduced: true,
                            originalFrequencies: peak.originalFrequencies || [peak.frequency]
                        }));
                        logMessage(`📊 OKTAVREDUZIERTE PEAKS VERWENDET: ${frequencies.length} Peaks (keine FFT-Extraktion)`, 'warning');
                        frequencies.forEach((f, i) => {
                            const originals = f.originalFrequencies ? f.originalFrequencies.map(freq => freq.toFixed(1)).join(', ') : f.frequency.toFixed(1);
                            logMessage(`   T0-Peak #${i+1}: ${f.frequency.toFixed(1)}Hz (${(f.amplitude*100).toFixed(1)}%) ← [${originals}]Hz`, 'info');
                        });
                    } else {
                        // Normale FFT-Extraktion für Vollspektrum
                        frequencies = this.extractFrequenciesFromSnapshot(snapshot, config);
                        logMessage(`📊 VOLLSPEKTRUM FFT-Extraktion: ${frequencies.length} Peaks`, 'info');
                    }
                    
                    logMessage(`📊 Finale T0-Frequenz-Liste: ${frequencies.map(f => f.frequency.toFixed(1) + 'Hz').join(', ')}`, 'info');
                    
                    if (frequencies.length < config.minFrequencies) {
                        return this.createErrorResult(`Zu wenige Frequenzen erkannt: ${frequencies.length}/${config.minFrequencies}`, frequencies.length);
                    }

                    const fundamentalResult = this.detectT0Fundamental(frequencies, config);
                    logMessage('🎵 Grundton-Detection:', fundamentalResult.success ? fundamentalResult.fundamental.toFixed(1) + 'Hz (' + fundamentalResult.method + ')' : fundamentalResult.reason, 'info');
                    
                    if (!fundamentalResult.success) {
                        // Fallback: Verwende niedrigste Frequenz als Grundton
                        const lowestFreq = frequencies.sort((a, b) => a.frequency - b.frequency)[0];
                        if (lowestFreq) {
                            logMessage('🔄 Fallback: Verwende niedrigste Frequenz als Grundton', 'info');
                            fundamentalResult.success = true;
                            fundamentalResult.fundamental = lowestFreq.frequency;
                            fundamentalResult.confidence = 0.5;
                            fundamentalResult.method = 'fallback_lowest';
                        } else {
                            return this.createErrorResult('Grundton nicht erkennbar', frequencies.length);
                        }
                    }

                    const intervalAnalysis = this.analyzeT0Intervals(frequencies, fundamentalResult.fundamental, config);
                    logMessage(`🎼 Intervall-Analyse: ${intervalAnalysis.length} Intervalle gefunden`, 'info');
                    
                    const chordMatches = this.matchT0ChordPatterns(intervalAnalysis, config);
                    logMessage(`🎯 Akkord-Matching: ${chordMatches.length} Kandidaten gefunden`, 'info');
                    
                    // Debug: Zeige Top-3 Matches
                    chordMatches.slice(0, 3).forEach((match, i) => {
                        logMessage(`   #${i+1}: ${match.chordData.name} (${(match.confidence*100).toFixed(1)}% Konfidenz, ${(match.completeness*100).toFixed(0)}% vollständig)`, 'info');
                    });
                    
                    const qualityAssessment = this.assessT0Quality(intervalAnalysis, chordMatches, config);

                    // SCHWEBUNGS-ANALYSE: Erweiterte Analyse der Frequenz-Struktur
                    const beatAnalysis = this.analyzeBeatingPattern(frequencies, fundamentalResult.fundamental);

                    const result = this.compileT0Result(
                        fundamentalResult, intervalAnalysis, chordMatches, qualityAssessment, frequencies, config, beatAnalysis
                    );

                    const chordName = result.recognizedChord?.name || 'Unbekannt';
                    const confidence = result.recognizedChord?.confidence || 0;
                    logMessage(`✅ T0-Akkord-Ergebnis: ${chordName} (${(confidence*100).toFixed(1)}% Konfidenz)`, 'success');
                    return result;

                } catch (error) {
                    console.error('❌ T0-Akkord-Analyse Fehler:', error);
                    return this.createErrorResult(`Analyse-Fehler: ${error.message}`, 0);
                }
            }

            extractFrequenciesFromSnapshot(snapshot, config) {
                if (!snapshot.freqData || !snapshot.sampleRate) {
                    throw new Error('Ungültige Snapshot-Daten');
                }

                const frequencies = [];
                const fftData = snapshot.freqData;
                const sampleRate = snapshot.sampleRate;
                const binSize = sampleRate / (2 * fftData.length);

                // AGGRESSIVE Threshold für Schwebungs-Erkennung
                const maxAmplitude = Math.max(...fftData) / 255;
                const adaptiveThreshold = Math.max(0.02, maxAmplitude * 0.05); // Reduziert für bessere Schwebungs-Erkennung
                
                console.log(`📊 FFT-Analyse: Max=${maxAmplitude.toFixed(3)}, Threshold=${adaptiveThreshold.toFixed(3)}`);

                for (let i = 1; i < fftData.length - 1; i++) { // Reduziert Window
                    const amplitude = fftData[i] / 255;
                    
                    if (amplitude > adaptiveThreshold && this.isSignificantPeak(fftData, i, 1)) { // Window=1 für Schwebung
                        const preciseFreq = this.calculatePreciseFrequency(fftData, i, binSize);
                        
                        if (preciseFreq >= 50 && preciseFreq <= 4000) { // Erweitert für alle Schwebungs-Töne
                            frequencies.push({
                                frequency: preciseFreq,
                                amplitude: amplitude,
                                bin: i
                            });
                        }
                    }
                }

                frequencies.sort((a, b) => b.amplitude - a.amplitude);
                const filtered = this.removeTooCloseFrequencies(frequencies, 5); // Reduziert auf 5Hz für Schwebung
                const result = filtered.slice(0, config.maxFrequencies);
                
                console.log(`🎯 Gefilterte Frequenzen:`, result.map(f => `${f.frequency.toFixed(1)}Hz (${(f.amplitude*100).toFixed(1)}%)`));
                return result;
            }

            detectT0Fundamental(frequencies, config) {
                const strategies = [];
                
                const lowestStrong = this.findLowestStrongFrequency(frequencies);
                if (lowestStrong) {
                    strategies.push({
                        fundamental: lowestStrong.frequency,
                        confidence: lowestStrong.amplitude * 0.3,
                        method: 'lowest_strong'
                    });
                }

                const harmonicSeries = this.findFundamentalByHarmonicSeries(frequencies);
                if (harmonicSeries) {
                    strategies.push({
                        fundamental: harmonicSeries.fundamental,
                        confidence: harmonicSeries.confidence * 0.4,
                        method: 'harmonic_series'
                    });
                }

                if (strategies.length === 0) {
                    return { success: false, reason: 'Keine Strategien erfolgreich' };
                }

                strategies.sort((a, b) => b.confidence - a.confidence);
                const bestStrategy = strategies[0];

                return {
                    success: true,
                    fundamental: bestStrategy.fundamental,
                    confidence: bestStrategy.confidence,
                    method: bestStrategy.method,
                    strategies: strategies
                };
            }

            analyzeT0Intervals(frequencies, fundamental, config) {
                const intervals = [];

                for (const freq of frequencies) {
                    const ratio = freq.frequency / fundamental;
                    const rationalApprox = this.approximateRational(ratio, 1000);
                    const reducedRational = this.reduceToOctave(rationalApprox);
                    
                    const eulerGradus = this.calculateEulerGradus(reducedRational);
                    const xiDeviation = this.calculateXiDeviation(reducedRational);
                    
                    intervals.push({
                        frequency: freq.frequency,
                        amplitude: freq.amplitude,
                        ratio: ratio,
                        rational: rationalApprox,
                        reducedRational: reducedRational,
                        eulerGradus: eulerGradus,
                        xiDeviation: xiDeviation,
                        isT0Compliant: xiDeviation <= config.xiTolerance,
                        cents: 1200 * Math.log2(ratio)
                    });
                }

                return intervals.sort((a, b) => a.eulerGradus - b.eulerGradus);
            }

            matchT0ChordPatterns(intervals, config) {
                const matches = [];
                
                console.log(`🎼 Chord-Pattern-Matching mit ${intervals.length} Intervallen...`);
                
                // Debugging: Zeige alle erkannten Intervalle mit Ratios
                intervals.forEach((interval, i) => {
                    const ratio = interval.reducedRational.numerator / interval.reducedRational.denominator;
                    console.log(`  Intervall #${i+1}: ${interval.frequency.toFixed(1)}Hz, Ratio: ${ratio.toFixed(3)} (${interval.reducedRational.numerator}/${interval.reducedRational.denominator})`);
                });
                
                for (const [chordType, chordData] of Object.entries(this.t0ChordDatabase)) {
                    const match = this.matchSingleChordPattern(intervals, chordData, config);
                    
                    console.log(`  ${chordType}: ${(match.confidence * 100).toFixed(1)}% (${(match.completeness * 100).toFixed(0)}% vollständig)`);
                    
                    if (match.confidence > 0.15) { // Reduziert von 0.2 auf 0.15 für bessere Sensitivität
                        matches.push({
                            chordType: chordType,
                            chordData: chordData,
                            confidence: match.confidence,
                            completeness: match.completeness,
                            t0Compliance: match.t0Compliance,
                            matchDetails: match.matchDetails // Debugging info
                        });
                    }
                }

                const sortedMatches = matches.sort((a, b) => b.confidence - a.confidence);
                console.log(`🎯 ${sortedMatches.length} Akkord-Kandidaten gefunden`);
                
                return sortedMatches;
            }

            matchSingleChordPattern(intervals, chordData, config) {
                const requiredIntervals = chordData.intervals;
                let matchedCount = 0;
                const matchDetails = [];
                let totalDeviation = 0;

                for (const requiredInterval of requiredIntervals) {
                    const targetRatio = requiredInterval[0] / requiredInterval[1];
                    let bestMatch = null;
                    let bestDeviation = Infinity;
                    
                    for (const interval of intervals) {
                        const intervalRatio = interval.reducedRational.numerator / interval.reducedRational.denominator;
                        const deviation = Math.abs(1200 * Math.log2(intervalRatio / targetRatio));
                        
                        if (deviation <= config.xiTolerance && deviation < bestDeviation) {
                            bestMatch = interval;
                            bestDeviation = deviation;
                        }
                    }

                    if (bestMatch) {
                        matchedCount++;
                        totalDeviation += bestDeviation;
                        matchDetails.push({
                            required: `${requiredInterval[0]}/${requiredInterval[1]}`,
                            matched: `${bestMatch.reducedRational.numerator}/${bestMatch.reducedRational.denominator}`,
                            deviation: bestDeviation.toFixed(1) + '¢',
                            frequency: bestMatch.frequency.toFixed(1) + 'Hz'
                        });
                    }
                }

                const completeness = matchedCount / requiredIntervals.length;
                const t0Compliance = intervals.filter(i => i.isT0Compliant).length / Math.max(intervals.length, 1);
                const avgDeviation = matchedCount > 0 ? totalDeviation / matchedCount : 100;

                // VERBESSERTE Konfidenz-Berechnung mit Deviations-Penalty
                let confidence = completeness * 0.5; // Basis für Vollständigkeit
                confidence += t0Compliance * 0.2; // T0-Konformität Bonus
                confidence += (matchedCount >= 2 ? 0.2 : 0); // Match-Anzahl Bonus
                
                // Deviations-Penalty: Je präziser, desto besser
                const deviationPenalty = Math.min(avgDeviation / 50, 0.3); // Max 30% Penalty
                confidence -= deviationPenalty;
                
                // Spezial-Boost für perfekte Matches
                if (completeness === 1.0 && avgDeviation < 10) {
                    confidence += 0.1; // Perfect match bonus
                }

                return {
                    confidence: Math.max(0, Math.min(confidence, 1.0)),
                    completeness: completeness,
                    t0Compliance: t0Compliance || 0,
                    matchDetails: matchDetails,
                    averageDeviation: avgDeviation
                };
            }

            assessT0Quality(intervals, chordMatches, config) {
                const stats = {
                    totalIntervals: intervals.length,
                    t0CompliantCount: intervals.filter(i => i.isT0Compliant).length,
                    averageEulerGradus: intervals.reduce((sum, i) => sum + i.eulerGradus, 0) / intervals.length,
                    averageXiDeviation: intervals.reduce((sum, i) => sum + i.xiDeviation, 0) / intervals.length,
                    bestChordConfidence: chordMatches.length > 0 ? chordMatches[0].confidence : 0
                };

                let qualityLevel = 'poor';
                let qualityScore = 0;

                for (const [level, thresholds] of Object.entries(this.qualityThresholds)) {
                    if (stats.averageEulerGradus <= thresholds.eulerGradusMax &&
                        stats.averageXiDeviation <= thresholds.xiDeviationMax &&
                        (stats.t0CompliantCount / stats.totalIntervals) >= thresholds.t0ComplianceMin) {
                        
                        qualityLevel = level;
                        qualityScore = this.calculateQualityScore(stats);
                        break;
                    }
                }

                return {
                    level: qualityLevel,
                    score: qualityScore,
                    statistics: stats,
                    grade: this.calculateGrade(qualityScore)
                };
            }

            // VERBESSERTE SCHWEBUNGS-ANALYSE (Funktioniert mit funktionierendem Mikrofon)
            analyzeBeatingPattern(frequencies, fundamental) {
                if (frequencies.length < 2) {
                    return { detected: false, reason: 'Zu wenige Frequenzen für Schwebungs-Analyse' };
                }

                logMessage(`🔍 SCHWEBUNGS-ANALYSE gestartet: ${frequencies.length} Frequenzen`, 'info');

                // Sortiere Frequenzen nach Wert
                const sortedFreqs = frequencies.slice().sort((a, b) => a.frequency - b.frequency);
                
                // 1. SUCHE NACH SYMMETRISCHEN SCHWEBUNGS-PAAREN um Fundamental
                const beatPairs = [];
                const tolerance = 1.5; // Hz Toleranz für Schwebungs-Erkennung
                const maxBeatFreq = 20; // Maximum 20Hz Schwebung
                const minBeatFreq = 0.1; // Minimum 0.1Hz Schwebung
                
                logMessage(`🎵 Suche Schwebungs-Paare um ${fundamental.toFixed(1)}Hz (±${tolerance}Hz Toleranz)`, 'info');
                
                // Finde Grundfrequenz im Spektrum
                const fundamentalFreq = sortedFreqs.find(f => Math.abs(f.frequency - fundamental) < tolerance * 2);
                
                if (fundamentalFreq) {
                    logMessage(`🎯 Grundfrequenz gefunden: ${fundamentalFreq.frequency.toFixed(1)}Hz`, 'info');
                    
                    // Suche nach symmetrischen Paaren: fu < f0 < fo
                    for (const lowerFreq of sortedFreqs) {
                        if (lowerFreq.frequency >= fundamentalFreq.frequency) continue;
                        
                        const beatFreqLower = fundamentalFreq.frequency - lowerFreq.frequency;
                        if (beatFreqLower < minBeatFreq || beatFreqLower > maxBeatFreq) continue;
                        
                        // Suche entsprechendes oberes Paar
                        const expectedUpperFreq = fundamentalFreq.frequency + beatFreqLower;
                        const upperFreq = sortedFreqs.find(f => 
                            Math.abs(f.frequency - expectedUpperFreq) < tolerance
                        );
                        
                        if (upperFreq) {
                            const beatFreqUpper = upperFreq.frequency - fundamentalFreq.frequency;
                            const avgBeatFreq = (beatFreqLower + beatFreqUpper) / 2;
                            const symmetryError = Math.abs(beatFreqLower - beatFreqUpper);
                            
                            // Klassifiziere Schwebungs-Typ
                            let beatType = this.classifyBeatType(avgBeatFreq);
                            
                            beatPairs.push({
                                lower: lowerFreq.frequency,
                                center: fundamentalFreq.frequency,
                                upper: upperFreq.frequency,
                                beatFrequency: avgBeatFreq,
                                lowerAmplitude: lowerFreq.amplitude,
                                centerAmplitude: fundamentalFreq.amplitude,
                                upperAmplitude: upperFreq.amplitude,
                                symmetryError: symmetryError,
                                quality: symmetryError < 0.5 ? 'excellent' : symmetryError < 1.0 ? 'good' : 'moderate',
                                beatType: beatType.type,
                                musicalEffect: beatType.effect,
                                color: beatType.color
                            });
                            
                            logMessage(`✅ Schwebungs-Paar gefunden: ${lowerFreq.frequency.toFixed(1)} - ${fundamentalFreq.frequency.toFixed(1)} - ${upperFreq.frequency.toFixed(1)}Hz`, 'success');
                            logMessage(`   Schwebung: ${avgBeatFreq.toFixed(2)}Hz (${beatType.type} - ${beatType.effect})`, 'info');
                        }
                    }
                }
                
                // 2. ERGEBNIS-BEWERTUNG
                if (beatPairs.length > 0) {
                    // Sortiere nach Qualität
                    beatPairs.sort((a, b) => a.symmetryError - b.symmetryError);
                    
                    const bestPair = beatPairs[0];
                    const avgConfidence = Math.max(0.3, 1.0 - (bestPair.symmetryError / 3.0));
                    
                    logMessage(`🏆 BESTE SCHWEBUNG: ${bestPair.beatFrequency.toFixed(2)}Hz (${bestPair.quality}) - ${bestPair.beatType}`, 'success');
                    
                    return {
                        detected: true,
                        type: 'symmetric_beating_pairs',
                        beatPairs: beatPairs,
                        totalPairs: beatPairs.length,
                        bestPair: bestPair,
                        confidence: avgConfidence,
                        analysis: `${beatPairs.length} symmetrische Schwebungs-Paare erkannt`
                    };
                } else if (frequencies.length === 1) {
                    // Einzelton
                    return {
                        detected: true,
                        type: 'single_tone',
                        frequency: frequencies[0].frequency,
                        analysis: 'Einzelton ohne Schwebung'
                    };
                } else {
                    logMessage(`❌ Keine Schwebungs-Paare gefunden`, 'warning');
                    return {
                        detected: false,
                        type: 'no_beating_pattern',
                        confidence: 0,
                        analysis: 'Keine erkennbare Schwebungsstruktur'
                    };
                }
            }

            // HILFSFUNKTION: Klassifiziere Schwebungs-Typ nach Frequenz
            classifyBeatType(beatFreq) {
                if (beatFreq <= 0.1) return { type: "Perfekte Stimmung", effect: "stabil", color: "#2ecc71" };
                else if (beatFreq <= 1) return { type: "Sehr langsame Schwebung", effect: "kaum hörbar", color: "#3498db" };
                else if (beatFreq <= 5) return { type: "Langsame Schwebung", effect: "angenehm, expressiv", color: "#f39c12" };
                else if (beatFreq <= 15) return { type: "Mittlere Schwebung", effect: "unruhig, merklich", color: "#e67e22" };
                else if (beatFreq <= 20) return { type: "Schnelle Schwebung", effect: "sehr unruhig", color: "#e74c3c" };
                else return { type: "Rauheit", effect: "dissonant, unangenehm", color: "#8e44ad" };
            }

            compileT0Result(fundamentalResult, intervals, chordMatches, quality, frequencies, config, beatAnalysis) {
                const bestChord = chordMatches.length > 0 ? chordMatches[0] : null;
                
                return {
                    success: true,
                    timestamp: Date.now(),
                    
                    fundamental: {
                        frequency: fundamentalResult.fundamental,
                        confidence: fundamentalResult.confidence,
                        method: fundamentalResult.method
                    },
                    
                    intervals: intervals,
                    intervalStatistics: {
                        total: intervals.length,
                        t0Compliant: intervals.filter(i => i.isT0Compliant).length
                    },
                    
                    recognizedChord: bestChord ? {
                        name: bestChord.chordData.name,
                        type: bestChord.chordType,
                        confidence: bestChord.confidence,
                        completeness: bestChord.completeness,
                        t0Compliance: bestChord.t0Compliance,
                        musicalFunction: bestChord.chordData.musicalFunction,
                        quality: bestChord.chordData.quality
                    } : null,
                    
                    // SCHWEBUNGS-INFO
                    beatPattern: beatAnalysis,
                    
                    quality: quality,
                    rawFrequencies: frequencies,
                    config: config
                };
            }

            // === UTILITY FUNCTIONS ===
            isSignificantPeak(fftData, index, windowSize = 2) {
                const current = fftData[index];
                for (let i = 1; i <= windowSize; i++) {
                    if (index - i >= 0 && current <= fftData[index - i]) return false;
                    if (index + i < fftData.length && current <= fftData[index + i]) return false;
                }
                return true;
            }

            calculatePreciseFrequency(fftData, index, binSize) {
                if (index <= 0 || index >= fftData.length - 1) return index * binSize;
                
                const y1 = fftData[index - 1] || 0;
                const y2 = fftData[index];
                const y3 = fftData[index + 1] || 0;
                
                const a = (y1 - 2*y2 + y3) / 2;
                const b = (y3 - y1) / 2;
                
                let offset = 0;
                if (Math.abs(a) > 1e-10) {
                    offset = -b / (2 * a);
                    offset = Math.max(-0.5, Math.min(0.5, offset));
                }
                
                return (index + offset) * binSize;
            }

            removeTooCloseFrequencies(frequencies, minSeparation) {
                const filtered = [];
                
                for (const freq of frequencies) {
                    const tooClose = filtered.some(existing => 
                        Math.abs(existing.frequency - freq.frequency) < minSeparation
                    );
                    
                    if (!tooClose) {
                        filtered.push(freq);
                    }
                }
                
                return filtered;
            }

            findLowestStrongFrequency(frequencies) {
                const minAmplitude = 0.15; // Reduziert von 0.25 auf 0.15
                const strongFreqs = frequencies.filter(f => f.amplitude >= minAmplitude);
                
                console.log(`🔍 Starke Frequenzen (>=${(minAmplitude*100).toFixed(0)}%):`, strongFreqs.length);
                
                if (strongFreqs.length === 0) return null;
                
                strongFreqs.sort((a, b) => a.frequency - b.frequency);
                return strongFreqs[0];
            }

            findFundamentalByHarmonicSeries(frequencies) {
                const candidates = [];
                
                for (const candidate of frequencies) {
                    let harmonicCount = 0;
                    const harmonics = [];
                    
                    for (let harmonic = 1; harmonic <= 6; harmonic++) { // Reduziert von 8 auf 6
                        const expectedFreq = candidate.frequency * harmonic;
                        const tolerance = expectedFreq * 0.05; // Erhöht von 0.02 auf 0.05 (5% Toleranz)
                        
                        const match = frequencies.find(f => 
                            Math.abs(f.frequency - expectedFreq) <= tolerance
                        );
                        
                        if (match) {
                            harmonicCount++;
                            harmonics.push({ harmonic, frequency: match.frequency, amplitude: match.amplitude });
                        }
                    }
                    
                    if (harmonicCount >= 2) { // Reduziert von 3 auf 2
                        const confidence = harmonicCount / 6;
                        candidates.push({
                            fundamental: candidate.frequency,
                            confidence: confidence,
                            harmonicCount: harmonicCount,
                            harmonics: harmonics
                        });
                        
                        console.log(`🎵 Grundton-Kandidat: ${candidate.frequency.toFixed(1)}Hz mit ${harmonicCount} Harmonischen`);
                    }
                }
                
                if (candidates.length === 0) {
                    console.log('⚠️ Keine harmonischen Serien gefunden');
                    return null;
                }
                
                candidates.sort((a, b) => b.confidence - a.confidence);
                return candidates[0];
            }

            approximateRational(decimal, maxDenominator = 1000) {
                if (decimal === 0) return { numerator: 0, denominator: 1 };
                
                let sign = decimal < 0 ? -1 : 1;
                decimal = Math.abs(decimal);
                let wholePart = Math.floor(decimal);
                let fractionalPart = decimal - wholePart;
                
                if (fractionalPart < 1e-10) {
                    return { numerator: sign * wholePart, denominator: 1 };
                }
                
                let h1 = 1, k1 = 0, h0 = wholePart, k0 = 1, x = fractionalPart;
                let iterations = 0;
                
                while (k0 <= maxDenominator && x !== 0 && iterations < 50) {
                    let a = Math.floor(1 / x);
                    let h2 = a * h0 + h1, k2 = a * k0 + k1;
                    if (k2 > maxDenominator) break;
                    h1 = h0; k1 = k0; h0 = h2; k0 = k2;
                    x = 1 / x - a;
                    if (Math.abs(x) < 1e-10) break;
                    iterations++;
                }
                
                return { numerator: sign * h0, denominator: k0 };
            }

            reduceToOctave(rational) {
                let ratio = rational.numerator / rational.denominator;
                while (ratio >= 2.0) ratio = ratio / 2.0;
                while (ratio < 1.0) ratio = ratio * 2.0;
                return this.approximateRational(ratio, 1000);
            }

            calculateEulerGradus(rational) {
                const primeFactorCount = (n) => {
                    let count = 0, factor = 2, temp = Math.abs(n);
                    while (factor * factor <= temp) {
                        while (temp % factor === 0) { count++; temp = temp / factor; }
                        factor++;
                    }
                    if (temp > 1) count++;
                    return count;
                };
                
                return primeFactorCount(rational.numerator) + primeFactorCount(rational.denominator) + 1;
            }

            calculateXiDeviation(rational) {
                const perfectRatios = [
                    {ratio: 1.0, cents: 0}, {ratio: 16/15, cents: 112}, {ratio: 9/8, cents: 204},
                    {ratio: 6/5, cents: 316}, {ratio: 5/4, cents: 386}, {ratio: 4/3, cents: 498},
                    {ratio: 3/2, cents: 702}, {ratio: 8/5, cents: 814}, {ratio: 5/3, cents: 884},
                    {ratio: 15/8, cents: 1088}
                ];
                
                const actualRatio = rational.numerator / rational.denominator;
                const actualCents = 1200 * Math.log2(actualRatio);
                
                let minDeviation = Infinity;
                for (const perfect of perfectRatios) {
                    const deviation = Math.abs(actualCents - perfect.cents);
                    minDeviation = Math.min(minDeviation, deviation);
                }
                
                return minDeviation;
            }

            calculateQualityScore(stats) {
                let score = 100;
                score -= (stats.averageEulerGradus - 4) * 5;
                score -= stats.averageXiDeviation * 0.5;
                score += (stats.t0CompliantCount / stats.totalIntervals) * 20;
                return Math.max(0, Math.min(100, score));
            }

            calculateGrade(score) {
                if (score >= 95) return 'A+';
                if (score >= 90) return 'A';
                if (score >= 85) return 'B+';
                if (score >= 80) return 'B';
                if (score >= 75) return 'C+';
                if (score >= 70) return 'C';
                if (score >= 60) return 'D';
                return 'F';
            }

            createErrorResult(reason, frequencyCount) {
                return {
                    success: false,
                    error: reason,
                    frequencyCount: frequencyCount,
                    timestamp: Date.now()
                };
            }
        }
        
        class ModularAudioEngine {
            constructor() {
                this.audioContext = null;
                this.oscillators = [];
                this.gainNode = null;
                this.analyser = null;
                this.isActive = false;
                this.bufferSize = 32768;
                this.sampleRate = 44100;
                this.currentChord = null;
                this.rootFrequency = 442; // GEÄNDERT AUF 442Hz
                this.volume = 0.5;
                this.tuningSystem = 'tempered';
                this.waveform = 'sine';
                this.playDuration = 2000;
                this.playTimeout = null;
                
                // Schwebungs-Eigenschaften
                this.beatFrequency = 0;
                
                // Mikrofon-Eigenschaften
                this.micStream = null;
                this.micGainNode = null;
                this.micAnalyser = null;
                this.micActive = false;
                this.micGain = 10;
                this.micLevelInterval = null;
                this.micAutoCapture = true;
                this.micCaptureThreshold = 0.5;
                
                // Chord definitions (inkl. Einzelton)
                this.chordRatios = {
                    major: { 
                        tempered: [1.0, 1.2599, 1.4983],
                        just: [1.0, 1.25, 1.5],
                        name: 'Dur'
                    },
                    minor: {
                        tempered: [1.0, 1.1892, 1.4983],
                        just: [1.0, 1.2, 1.5],
                        name: 'Moll'
                    },
                    dom7: {
                        tempered: [1.0, 1.2599, 1.4983, 1.7818],
                        just: [1.0, 1.25, 1.5, 1.7778],
                        name: 'Dominant 7'
                    },
                    maj7: {
                        tempered: [1.0, 1.2599, 1.4983, 1.8877],
                        just: [1.0, 1.25, 1.5, 1.875],
                        name: 'Major 7'
                    },
                    min7: {
                        tempered: [1.0, 1.1892, 1.4983, 1.7818],
                        just: [1.0, 1.2, 1.5, 1.7778],
                        name: 'Minor 7'
                    },
                    sus2: {
                        tempered: [1.0, 1.1225, 1.4983],
                        just: [1.0, 1.125, 1.5],
                        name: 'Sus2'
                    },
                    sus4: {
                        tempered: [1.0, 1.3348, 1.4983],
                        just: [1.0, 1.3333, 1.5],
                        name: 'Sus4'
                    },
                    aug: {
                        tempered: [1.0, 1.2599, 1.5874],
                        just: [1.0, 1.25, 1.6],
                        name: 'Übermäßig'
                    },
                    dim: {
                        tempered: [1.0, 1.1892, 1.4142],
                        just: [1.0, 1.2, 1.44],
                        name: 'Vermindert'
                    },
                    single_tone: {
                        tempered: [1.0],
                        just: [1.0],
                        name: 'Einzelton'
                    }
                };
            }
            
            async initialize() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.sampleRate = this.audioContext.sampleRate;
                    
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = this.volume;
                    
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = this.bufferSize;
                    this.analyser.smoothingTimeConstant = 0.8;
                    
                    this.gainNode.connect(this.analyser);
                    this.gainNode.connect(this.audioContext.destination);
                    
                    logMessage('🎵 Audio Engine bereit: ' + this.sampleRate + 'Hz', 'success');
                    return true;
                } catch (error) {
                    logMessage('❌ Audio Engine Fehler: ' + error.message, 'error');
                    return false;
                }
            }
            
            // REPARIERTE MIKROFON-FUNKTIONEN (aus funktionierender Version)
            async startMicrophone() {
                try {
                    if (this.micActive) {
                        this.stopMicrophone();
                    }
                    
                    if (!this.audioContext) {
                        await this.initialize();
                    }
                    
                    const constraints = {
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: this.sampleRate,
                            channelCount: 1
                        }
                    };
                    
                    this.micStream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    const micSource = this.audioContext.createMediaStreamSource(this.micStream);
                    this.micGainNode = this.audioContext.createGain();
                    this.micGainNode.gain.value = this.micGain;
                    
                    this.micAnalyser = this.audioContext.createAnalyser();
                    this.micAnalyser.fftSize = this.bufferSize;
                    this.micAnalyser.smoothingTimeConstant = 0.1;
                    this.micAnalyser.minDecibels = -90;
                    this.micAnalyser.maxDecibels = -10;
                    
                    micSource.connect(this.micGainNode);
                    this.micGainNode.connect(this.micAnalyser);
                    
                    this.micActive = true;
                    // KRITISCH: Starte Level-Monitoring HIER
                    this.startLevelMonitoring();
                    
                    logMessage('🎤 Mikrofon aktiviert mit optimierten Einstellungen', 'success');
                    updateMicrophoneStatus();
                    return true;
                    
                } catch (error) {
                    logMessage('❌ Mikrofon Fehler: ' + error.message, 'error');
                    logMessage('💡 Tipp: Erlauben Sie Mikrofon-Zugriff im Browser', 'info');
                    return false;
                }
            }
            
            stopMicrophone() {
                if (this.micStream) {
                    this.micStream.getTracks().forEach(track => track.stop());
                    this.micStream = null;
                }
                
                // KRITISCH: Stoppe Level-Monitoring
                if (this.micLevelInterval) {
                    clearInterval(this.micLevelInterval);
                    this.micLevelInterval = null;
                }
                
                this.micActive = false;
                logMessage('🎤 Mikrofon deaktiviert', 'info');
                updateMicrophoneStatus();
                updateMicLevel(0);
            }
            
            setMicGain(gain) {
                this.micGain = gain;
                if (this.micGainNode) {
                    this.micGainNode.gain.value = gain;
                }
            }
            
            // REPARIERTE startLevelMonitoring Funktion
            startLevelMonitoring() {
                if (this.micLevelInterval) return; // Verhindere doppelte Intervals
                
                let lastCaptureTime = 0;
                const captureDelay = 2000;
                
                this.micLevelInterval = setInterval(() => {
                    if (this.micAnalyser && this.micActive) {
                        const freqArray = new Uint8Array(this.micAnalyser.frequencyBinCount);
                        const timeArray = new Uint8Array(this.micAnalyser.frequencyBinCount);
                        
                        this.micAnalyser.getByteFrequencyData(freqArray);
                        this.micAnalyser.getByteTimeDomainData(timeArray);
                        
                        // RMS von Frequenz-Daten
                        let freqSum = 0;
                        for (let i = 0; i < freqArray.length; i++) {
                            freqSum += freqArray[i] * freqArray[i];
                        }
                        const freqRms = Math.sqrt(freqSum / freqArray.length);
                        
                        // RMS von Zeit-Daten
                        let timeSum = 0;
                        for (let i = 0; i < timeArray.length; i++) {
                            const normalized = (timeArray[i] - 128) / 128;
                            timeSum += normalized * normalized;
                        }
                        const timeRms = Math.sqrt(timeSum / timeArray.length);
                        
                        // Kombiniere beide für bessere Responsivität
                        const freqLevel = freqRms / 255;
                        const timeLevel = timeRms;
                        const combinedLevel = Math.max(freqLevel, timeLevel * 2);
                        
                        // KRITISCH: Rufe updateMicLevel auf
                        updateMicLevel(combinedLevel);
                        
                        // AUTO-CAPTURE bei 50% Schwelle
                        const currentTime = Date.now();
                        if (this.micAutoCapture && 
                            combinedLevel >= this.micCaptureThreshold && 
                            currentTime - lastCaptureTime > captureDelay) {
                            
                            lastCaptureTime = currentTime;
                            logMessage(`🎤 Auto-Capture ausgelöst bei ${(combinedLevel * 100).toFixed(0)}% Level`, 'success');
                            
                            setTimeout(() => {
                                if (bufferManager) {
                                    const buffer = bufferManager.captureRawBuffer();
                                    if (buffer) {
                                        setTimeout(() => {
                                            bufferManager.selectBuffer(buffer);
                                        }, 100);
                                    }
                                }
                            }, 200);
                        }
                    }
                }, 50); // 20fps Update
            }
            
            getMicrophoneData() {
                if (!this.micAnalyser || !this.micActive) return null;
                
                const timeData = new Float32Array(this.bufferSize);
                const freqData = new Uint8Array(this.micAnalyser.frequencyBinCount);
                
                this.micAnalyser.getFloatTimeDomainData(timeData);
                this.micAnalyser.getByteFrequencyData(freqData);
                
                return {
                    timeData: timeData,
                    freqData: freqData,
                    sampleRate: this.sampleRate,
                    bufferSize: this.bufferSize,
                    timestamp: Date.now(),
                    source: 'microphone'
                };
            }
            
            playChordTimed(chordType) {
                this.stopChord();
                
                if (!this.chordRatios[chordType]) return;
                
                const chord = this.chordRatios[chordType];
                const ratios = chord[this.tuningSystem];
                this.currentChord = chordType;
                
                // Unfreeze Spektrum für Live-Anzeige
                if (visualizer && visualizer.frozen) {
                    visualizer.frozen = false;
                    visualizer.analysisResults = null;
                    document.getElementById('freezeBtn').textContent = '❄️ Freeze';
                    document.getElementById('freezeBtn').classList.remove('active');
                    logMessage('🔄 Spektrum ungefroren für Live-Anzeige', 'info');
                }
                
                ratios.forEach((ratio, index) => {
                    const baseFrequency = this.rootFrequency * ratio;
                    
                    // Schwebungs-Dreiklang: f0-beat, f0, f0+beat
                    let frequencies = [baseFrequency];
                    
                    if (this.beatFrequency > 0) {
                        frequencies = [
                            baseFrequency - this.beatFrequency,
                            baseFrequency,
                            baseFrequency + this.beatFrequency
                        ];
                    }
                    
                    frequencies.forEach((frequency, beatIndex) => {
                        const osc = this.audioContext.createOscillator();
                        const oscGain = this.audioContext.createGain();
                        
                        osc.frequency.value = frequency;
                        osc.type = this.waveform;
                        
                        const amplitude = this.volume / (ratios.length * frequencies.length);
                        oscGain.gain.value = amplitude;
                        
                        osc.connect(oscGain);
                        oscGain.connect(this.gainNode);
                        
                        osc.start();
                        this.oscillators.push(osc);
                        
                        if (this.beatFrequency > 0 && frequencies.length > 1) {
                            const freqList = frequencies.map(f => f.toFixed(1)).join(', ');
                            logMessage(`🎵 Schwebungs-Dreiklang: [${freqList}] Hz`, 'info');
                        }
                    });
                });
                
                this.isActive = true;
                
                // Auto-stop after duration
                this.playTimeout = setTimeout(() => {
                    this.stopChord();
                }, this.playDuration);
                
                const beatInfo = this.beatFrequency > 0 ? ` (±${this.beatFrequency}Hz Schwebung)` : '';
                logMessage(`🎼 Generator: ${chord.name} @ ${this.rootFrequency.toFixed(1)}Hz${beatInfo}`, 'success');
                
                updateGeneratorStatus();
                
                // Automatische Raw-Buffer Erfassung
                setTimeout(() => {
                    if (this.isActive) {
                        const buffer = bufferManager.captureRawBuffer();
                        
                        if (buffer) {
                            setTimeout(() => {
                                bufferManager.selectBuffer(buffer);
                            }, 200);
                        }
                    }
                }, 800);
            }
            
            stopChord() {
                if (this.playTimeout) {
                    clearTimeout(this.playTimeout);
                    this.playTimeout = null;
                }
                
                this.oscillators.forEach(osc => {
                    try {
                        osc.stop();
                        osc.disconnect();
                    } catch (e) {}
                });
                this.oscillators = [];
                this.isActive = false;
                this.currentChord = null;
                
                updateGeneratorStatus();
                
                // Auto-select last snapshot nach Chord-Ende
                setTimeout(() => {
                    if (bufferManager.buffers.length > 0 && visualizer && !visualizer.frozen) {
                        const lastBuffer = bufferManager.buffers[bufferManager.buffers.length - 1];
                        const bufferTime = new Date(lastBuffer.timestamp).toLocaleTimeString();
                        const currentTime = new Date().toLocaleTimeString();
                        
                        const bufferAge = Date.now() - lastBuffer.timestamp;
                        if (bufferAge < 5000) {
                            logMessage(`🎯 AUTO-AUSWAHL: Buffer ${bufferTime} wird analysiert (Auswahl: ${currentTime})`, 'info');
                            bufferManager.selectBuffer(lastBuffer);
                            
                            document.getElementById('freezeBtn').textContent = '🔥 Unfreeze';
                            document.getElementById('freezeBtn').classList.add('active');
                        } else {
                            logMessage(`⏰ AUTO-AUSWAHL ÜBERSPRUNGEN: Buffer ${bufferTime} zu alt (${Math.round(bufferAge/1000)}s)`, 'warning');
                        }
                    }
                }, 1200);
            }
            
            setRootFrequency(frequency) {
                this.rootFrequency = frequency;
                updateGeneratorStatus();
            }
            
            setVolume(volume) {
                this.volume = volume / 100;
                if (this.gainNode) {
                    this.gainNode.gain.value = this.volume;
                }
            }
            
            setTuningSystem(system) {
                this.tuningSystem = system;
                updateGeneratorStatus();
                logMessage(`🎼 Generator Stimmung: ${system}`, 'info');
            }
            
            setWaveform(waveform) {
                this.waveform = waveform;
                updateGeneratorStatus();
                logMessage(`🌊 Generator Wellenform: ${waveform}`, 'info');
            }
            
            setBeatFrequency(frequency) {
                this.beatFrequency = frequency;
                updateGeneratorStatus();
                const modeText = frequency > 0 ? `±${frequency}Hz Dreiklang` : 'Aus';
                logMessage(`🎵 Schwebungs-Frequenz: ${frequency}Hz (${modeText})`, 'info');
            }
            
            setMicAutoCapture(enabled) {
                this.micAutoCapture = enabled;
                logMessage(`🎤 Auto-Capture: ${enabled ? 'Ein' : 'Aus'}`, 'info');
            }
            
            getAudioData() {
                // Priorisiere Mikrofon-Daten wenn aktiv
                if (this.micActive && this.micAnalyser) {
                    return this.getMicrophoneData();
                }
                
                // Fallback auf Generator-Daten
                if (!this.analyser) return null;
                
                const timeData = new Float32Array(this.bufferSize);
                const freqData = new Uint8Array(this.analyser.frequencyBinCount);
                
                this.analyser.getFloatTimeDomainData(timeData);
                this.analyser.getByteFrequencyData(freqData);
                
                return {
                    timeData: timeData,
                    freqData: freqData,
                    sampleRate: this.sampleRate,
                    bufferSize: this.bufferSize,
                    timestamp: Date.now(),
                    source: this.isActive ? 'generator' : 'silence',
                    beatFrequency: this.beatFrequency
                };
            }
        }
        
        class ModularSpectrumVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.scale = 'log';
                this.zoomMode = 'full';
                this.spectrumGain = 1.0;
                this.frozen = false;
                this.frozenData = null;
                this.mousePos = { x: 0, y: 0 };
                this.detectedFrequencies = [];
                this.analysisResults = null;
                
                this.zoomPresets = {
                    full: { min: 20, max: 20000, name: 'Full' },
                    bass: { min: 20, max: 500, name: 'Bass' },
                    mid: { min: 200, max: 2000, name: 'Mid' },
                    high: { min: 1000, max: 8000, name: 'High' }
                };
                
                this.setupCanvas();
                this.setupMouseHandling();
            }
            
            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            setupMouseHandling() {
                const tooltip = document.getElementById('frequency-tooltip');
                
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mousePos.x = e.clientX - rect.left;
                    this.mousePos.y = e.clientY - rect.top;
                    
                    this.showFrequencyTooltip(e.clientX, e.clientY);
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    tooltip.style.display = 'none';
                });
            }
            
            showFrequencyTooltip(clientX, clientY) {
                const tooltip = document.getElementById('frequency-tooltip');
                const preset = this.zoomPresets[this.zoomMode];
                
                const frequency = this.getFrequencyFromX(this.mousePos.x, preset);
                
                if (frequency >= preset.min && frequency <= preset.max) {
                    let tooltipText = `${frequency.toFixed(1)} Hz`;
                    
                    // Erweiterte Tooltip-Info bei T0-Analyse mit Schwebungs-Info
                    if (this.frozen && this.analysisResults && this.analysisResults.t0Analysis) {
                        const t0 = this.analysisResults.t0Analysis;
                        
                        const nearInterval = t0.intervals.find(interval => 
                            Math.abs(interval.frequency - frequency) < 20
                        );
                        
                        if (nearInterval) {
                            const noteName = getNoteName(nearInterval.frequency, t0.fundamental.frequency);
                            const rational = `${nearInterval.reducedRational.numerator}/${nearInterval.reducedRational.denominator}`;
                            const compliance = nearInterval.isT0Compliant ? '✅' : '❌';
                            
                            tooltipText += `<br><strong>${nearInterval.frequency.toFixed(1)} Hz</strong>`;
                            tooltipText += `<br>Note: <span style="color: #f1c40f">${noteName}</span>`;
                            tooltipText += `<br>Rational: ${rational} ${compliance}`;
                            tooltipText += `<br>Euler°: ${nearInterval.eulerGradus}`;
                            tooltipText += `<br>ξ: ${nearInterval.xiDeviation.toFixed(1)}¢`;
                        }
                        
                        // SCHWEBUNGS-INFO in Tooltip
                        if (t0.beatPattern && t0.beatPattern.detected && t0.beatPattern.beatPairs) {
                            for (const pair of t0.beatPattern.beatPairs) {
                                const tolerance = 2.0; // Hz
                                
                                if (Math.abs(frequency - pair.lower) < tolerance) {
                                    tooltipText += `<br><span style="color: #e74c3c"><strong>🎵 Untere Schwebung</strong></span>`;
                                    tooltipText += `<br>Schwebung: ${pair.beatFrequency.toFixed(2)}Hz`;
                                    tooltipText += `<br>Zentrum: ${pair.center.toFixed(1)}Hz | Obere: ${pair.upper.toFixed(1)}Hz`;
                                    tooltipText += `<br>Typ: ${pair.beatType}`;
                                    break;
                                } else if (Math.abs(frequency - pair.center) < tolerance) {
                                    tooltipText += `<br><span style="color: #f1c40f"><strong>🎯 Schwebungs-Zentrum</strong></span>`;
                                    tooltipText += `<br>Schwebung: ±${pair.beatFrequency.toFixed(2)}Hz`;
                                    tooltipText += `<br>Untere: ${pair.lower.toFixed(1)}Hz | Obere: ${pair.upper.toFixed(1)}Hz`;
                                    tooltipText += `<br>Typ: ${pair.beatType}`;
                                    break;
                                } else if (Math.abs(frequency - pair.upper) < tolerance) {
                                    tooltipText += `<br><span style="color: #27ae60"><strong>🎵 Obere Schwebung</strong></span>`;
                                    tooltipText += `<br>Schwebung: ${pair.beatFrequency.toFixed(2)}Hz`;
                                    tooltipText += `<br>Zentrum: ${pair.center.toFixed(1)}Hz | Untere: ${pair.lower.toFixed(1)}Hz`;
                                    tooltipText += `<br>Typ: ${pair.beatType}`;
                                    break;
                                }
                            }
                        }
                    }
                    
                    tooltip.innerHTML = tooltipText;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (clientX + 10) + 'px';
                    tooltip.style.top = (clientY - 10) + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            }
            
            drawSpectrum(audioData) {
                if (this.frozen && this.frozenData) {
                    audioData = this.frozenData;
                }
                
                this.clear();
                
                if (!audioData || !audioData.freqData) return;
                
                this.drawFrequencySpectrum(audioData.freqData, audioData.sampleRate);
                this.drawGrid();
                this.drawLabels();
                
                if (this.frozen) {
                    this.drawDetectedFrequencies();
                }
                
                if (!this.frozen) {
                    this.frozenData = audioData;
                }
            }
            
            drawFrequencySpectrum(freqData, sampleRate) {
                const binCount = freqData.length;
                const binWidth = sampleRate / (2 * binCount);
                const preset = this.zoomPresets[this.zoomMode];
                
                for (let i = 1; i < binCount; i++) {
                    const frequency = i * binWidth;
                    let amplitude = (freqData[i] / 255) * this.spectrumGain;
                    
                    if (amplitude > 0.01 && frequency >= preset.min && frequency <= preset.max) {
                        const x = this.getFrequencyX(frequency, preset);
                        const barHeight = amplitude * this.canvas.height * 0.85;
                        
                        if (x >= 0 && x < this.canvas.width && barHeight > 1) {
                            const color = this.getSpectrumColor(frequency, amplitude);
                            
                            this.ctx.fillStyle = color;
                            this.ctx.fillRect(x, this.canvas.height - barHeight, 2, barHeight);
                        }
                    }
                }
            }
            
            getFrequencyFromX(x, preset) {
                if (this.scale === 'log') {
                    const logMin = Math.log10(preset.min);
                    const logMax = Math.log10(preset.max);
                    const logFreq = logMin + (x / this.canvas.width) * (logMax - logMin);
                    return Math.pow(10, logFreq);
                } else {
                    return preset.min + (x / this.canvas.width) * (preset.max - preset.min);
                }
            }
            
            getFrequencyX(frequency, preset) {
                if (this.scale === 'log') {
                    const logMin = Math.log10(preset.min);
                    const logMax = Math.log10(preset.max);
                    const logFreq = Math.log10(frequency);
                    return ((logFreq - logMin) / (logMax - logMin)) * this.canvas.width;
                } else {
                    return ((frequency - preset.min) / (preset.max - preset.min)) * this.canvas.width;
                }
            }
            
            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                
                for (let i = 1; i < 4; i++) {
                    const y = (this.canvas.height * i) / 4;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            drawLabels() {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                this.ctx.font = '10px Arial';
                this.ctx.textAlign = 'center';
                
                const preset = this.zoomPresets[this.zoomMode];
                const frequencies = this.getFrequencyMarkers(preset);
                
                frequencies.forEach(freq => {
                    const x = this.getFrequencyX(freq, preset);
                    if (x > 20 && x < this.canvas.width - 20) {
                        const label = freq >= 1000 ? (freq/1000) + 'k' : freq.toString();
                        this.ctx.fillText(label, x, this.canvas.height - 5);
                    }
                });
            }
            
            drawDetectedFrequencies() {
                if (!this.analysisResults) return;
                
                const preset = this.zoomPresets[this.zoomMode];
                
                // Standard FFT Peaks
                if (this.analysisResults.peaks) {
                    this.analysisResults.peaks.forEach((peak, index) => {
                        if (peak.frequency >= preset.min && peak.frequency <= preset.max) {
                            const x = this.getFrequencyX(peak.frequency, preset);
                            this.drawFrequencyLine(x, peak.frequency, '#3498db', peak.amplitude);
                        }
                    });
                }
                
                // T0-Analyse Intervalle mit Schwebungs-Markierungen
                if (this.analysisResults.t0Analysis && this.analysisResults.t0Analysis.success) {
                    const t0 = this.analysisResults.t0Analysis;
                    
                    t0.intervals.forEach((interval) => {
                        if (interval.frequency >= preset.min && interval.frequency <= preset.max) {
                            const x = this.getFrequencyX(interval.frequency, preset);
                            let color = interval.isT0Compliant ? '#2ecc71' : '#e74c3c';
                            
                            // Spezielle Farben für Schwebungs-Frequenzen
                            if (t0.beatPattern && t0.beatPattern.beatPairs) {
                                for (const pair of t0.beatPattern.beatPairs) {
                                    if (Math.abs(interval.frequency - pair.lower) < 2) {
                                        color = '#e74c3c'; // Rot für untere Schwebung
                                        break;
                                    } else if (Math.abs(interval.frequency - pair.center) < 2) {
                                        color = '#f1c40f'; // Gelb für Zentrum
                                        break;
                                    } else if (Math.abs(interval.frequency - pair.upper) < 2) {
                                        color = '#27ae60'; // Grün für obere Schwebung
                                        break;
                                    }
                                }
                            }
                            
                            const noteName = getNoteName(interval.frequency, t0.fundamental.frequency);
                            this.drawFrequencyLine(x, interval.frequency, color, interval.amplitude, noteName);
                        }
                    });
                    
                    // Grundton-Linie
                    if (t0.fundamental.frequency >= preset.min && t0.fundamental.frequency <= preset.max) {
                        const x = this.getFrequencyX(t0.fundamental.frequency, preset);
                        this.drawFundamentalLine(x, t0.fundamental.frequency);
                    }
                }
            }
            
            drawFrequencyLine(x, frequency, color, amplitude, noteLabel = null) {
                // Vertikale Linie
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.globalAlpha = 0.8;
                
                this.ctx.beginPath();
                this.ctx.moveTo(x, 0);
                this.ctx.lineTo(x, this.canvas.height - 20);
                this.ctx.stroke();
                
                // Frequenz-Label
                this.ctx.setLineDash([]);
                this.ctx.globalAlpha = 1.0;
                this.ctx.fillStyle = color;
                this.ctx.font = 'bold 10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(frequency.toFixed(0) + 'Hz', x, 15);
                
                // Noten-Label
                if (noteLabel) {
                    this.ctx.fillStyle = '#f1c40f';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.fillText(noteLabel, x, 30);
                }
                
                // Amplituden-Indikator
                if (amplitude) {
                    const barHeight = amplitude * 20;
                    this.ctx.fillStyle = color;
                    this.ctx.globalAlpha = 0.6;
                    this.ctx.fillRect(x - 2, this.canvas.height - 20, 4, -barHeight);
                    this.ctx.globalAlpha = 1.0;
                }
            }
            
            drawFundamentalLine(x, frequency) {
                // Grundton-Linie
                this.ctx.strokeStyle = '#f1c40f';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([10, 5]);
                this.ctx.globalAlpha = 0.9;
                
                this.ctx.beginPath();
                this.ctx.moveTo(x, 0);
                this.ctx.lineTo(x, this.canvas.height - 20);
                this.ctx.stroke();
                
                // Grundton-Label
                this.ctx.setLineDash([]);
                this.ctx.fillStyle = '#f1c40f';
                this.ctx.font = 'bold 12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('♪ ' + frequency.toFixed(1) + 'Hz', x, 50);
                this.ctx.fillText('GRUNDTON', x, 65);
                
                this.ctx.globalAlpha = 1.0;
            }
            
            updateAnalysisResults(results) {
                this.analysisResults = results;
                this.detectedFrequencies = [];
                
                if (results.peaks) {
                    this.detectedFrequencies = results.peaks.map(peak => ({
                        frequency: peak.frequency,
                        amplitude: peak.amplitude,
                        type: 'fft'
                    }));
                }
                
                if (results.t0Analysis && results.t0Analysis.success) {
                    results.t0Analysis.intervals.forEach(interval => {
                        this.detectedFrequencies.push({
                            frequency: interval.frequency,
                            amplitude: interval.amplitude,
                            type: 't0',
                            t0Compliant: interval.isT0Compliant,
                            noteName: getNoteName(interval.frequency, results.t0Analysis.fundamental.frequency)
                        });
                    });
                }
            }
            
            getFrequencyMarkers(preset) {
                const range = preset.max - preset.min;
                if (range <= 1000) {
                    return [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000].filter(f => f >= preset.min && f <= preset.max);
                } else if (range <= 5000) {
                    return [100, 500, 1000, 2000, 3000, 4000, 5000].filter(f => f >= preset.min && f <= preset.max);
                } else {
                    return [100, 500, 1000, 2000, 5000, 10000, 15000, 20000].filter(f => f >= preset.min && f <= preset.max);
                }
            }
            
            getSpectrumColor(frequency, amplitude) {
                const hue = (Math.log2(frequency / 440) % 1 + 1) % 1 * 360;
                const saturation = 70;
                const lightness = 40 + amplitude * 40;
                return `hsla(${hue}, ${saturation}%, ${lightness}%, ${Math.min(1, amplitude * 1.5)})`;
            }
            
            clear() {
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            setScale(scale) {
                this.scale = scale;
            }
            
            setZoom(mode) {
                this.zoomMode = mode;
                
                // Spektrum sofort neu zeichnen für gespeicherte Buffer
                if (this.frozen && this.frozenData) {
                    this.drawSpectrum(this.frozenData);
                    logMessage(`🔍 Zoom geändert: ${this.zoomPresets[mode].name} (${this.zoomPresets[mode].min}-${this.zoomPresets[mode].max}Hz)`, 'info');
                } else {
                    logMessage(`🔍 Zoom geändert: ${this.zoomPresets[mode].name} - wirkt auf Live-Spektrum`, 'info');
                }
            }
            
            setSpectrumGain(gain) {
                this.spectrumGain = gain;
            }
            
            freeze() {
                this.frozen = !this.frozen;
            }
        }
        
        class ModularSnapshotManager {
            constructor() {
                this.buffers = [];
                this.selectedBuffer = null;
                this.autoCapture = true;
            }
            
            captureRawBuffer() {
                const audioData = audioEngine.getAudioData();
                if (!audioData) {
                    logMessage('❌ Keine Audio-Daten für Buffer-Capture', 'error');
                    return;
                }
                
                const rawBuffer = {
                    id: `buffer_${Date.now()}`,
                    timestamp: Date.now(),
                    timeData: Array.from(audioData.timeData),
                    freqData: Array.from(audioData.freqData),
                    sampleRate: audioData.sampleRate,
                    bufferSize: audioData.bufferSize
                };
                
                this.buffers.push(rawBuffer);
                this.updateBufferList();
                
                logMessage(`📊 Raw-Buffer erfasst: ${rawBuffer.bufferSize} Samples`, 'success');
                return rawBuffer;
            }
            
            selectBuffer(buffer) {
                this.selectedBuffer = buffer;
                this.updateBufferList();
                logMessage(`📋 Raw-Buffer ausgewählt: ${buffer.bufferSize} Samples`, 'info');
                
                // Freeze spectrum and show buffer
                if (visualizer) {
                    visualizer.frozen = true;
                    const bufferAudioData = {
                        timeData: new Float32Array(buffer.timeData),
                        freqData: new Uint8Array(buffer.freqData),
                        sampleRate: buffer.sampleRate,
                        bufferSize: buffer.bufferSize,
                        timestamp: buffer.timestamp
                    };
                    visualizer.frozenData = bufferAudioData;
                    visualizer.drawSpectrum(bufferAudioData);
                    
                    if (!audioEngine.isActive) {
                        document.getElementById('freezeBtn').textContent = '🔥 Unfreeze';
                        document.getElementById('freezeBtn').classList.add('active');
                    }
                }
                
                // Auto-analyze selected buffer
                setTimeout(() => {
                    analysisEngine.analyzeBuffer(buffer);
                }, 100);
            }
            
            saveRawBuffers() {
                if (this.buffers.length === 0) {
                    logMessage('❌ Keine Raw-Buffer zum Speichern', 'warning');
                    return;
                }
                
                const data = {
                    version: '1.0',
                    type: 'raw_audio_buffers',
                    created: new Date().toISOString(),
                    count: this.buffers.length,
                    buffers: this.buffers.map(buffer => ({
                        id: buffer.id,
                        timestamp: buffer.timestamp,
                        timeData: buffer.timeData,
                        freqData: buffer.freqData,
                        sampleRate: buffer.sampleRate,
                        bufferSize: buffer.bufferSize
                    }))
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `raw_buffers_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                logMessage(`💾 ${this.buffers.length} Raw-Buffer (32768 Samples) gespeichert`, 'success');
            }
            
            loadRawBuffers(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        if (data.buffers && Array.isArray(data.buffers)) {
                            this.buffers = data.buffers.map(buffer => ({
                                id: buffer.id || `buffer_${Date.now()}_${Math.random()}`,
                                timestamp: buffer.timestamp || Date.now(),
                                timeData: buffer.timeData || [],
                                freqData: buffer.freqData || [],
                                sampleRate: buffer.sampleRate || 44100,
                                bufferSize: buffer.bufferSize || 32768
                            }));
                            
                            this.selectedBuffer = null;
                            this.updateBufferList();
                            logMessage(`📁 ${this.buffers.length} Raw-Buffer geladen (${this.buffers[0]?.bufferSize || '?'} Samples)`, 'success');
                        } else {
                            throw new Error('Ungültiges Raw-Buffer-Format');
                        }
                    } catch (error) {
                        logMessage(`❌ Ladefehler: ${error.message}`, 'error');
                    }
                };
                
                reader.readAsText(file);
            }
            
            updateBufferList() {
                const list = document.getElementById('snapshotList');
                const count = this.buffers.length;
                
                document.getElementById('snapshotCount').textContent = count.toString();
                document.getElementById('saveBtn').disabled = count === 0;
                
                if (count === 0) {
                    list.innerHTML = `
                        <div style="text-align: center; color: rgba(255,255,255,0.6); padding: 15px;">
                            Keine Raw-Buffer<br>
                            <small>Werden automatisch bei Generator-Aktivierung erstellt</small>
                        </div>
                    `;
                    return;
                }
                
                list.innerHTML = '';
                
                this.buffers.slice(-10).reverse().forEach((buffer, index) => {
                    const item = document.createElement('div');
                    item.className = 'snapshot-item';
                    
                    if (this.selectedBuffer === buffer) {
                        item.classList.add('selected');
                    }
                    
                    const time = new Date(buffer.timestamp).toLocaleTimeString();
                    const sampleCount = buffer.timeData.length;
                    const durationMs = (sampleCount / buffer.sampleRate * 1000).toFixed(0);
                    
                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>📊 Raw-Buffer #${count - index}</strong><br>
                                <small style="color: rgba(255,255,255,0.7);">${time} | ${sampleCount} Samples | ${durationMs}ms</small>
                            </div>
                        </div>
                    `;
                    
                    item.addEventListener('click', () => {
                        this.selectBuffer(buffer);
                    });
                    
                    list.appendChild(item);
                });
            }
        }
        
        class ModularAnalysisEngine {
            constructor() {
                this.currentMethod = 'standard';
                this.threshold = 0.15;
                this.lastResults = null;
                this.t0ChordEngine = new T0ChordRecognitionEngine();
                this.octaveReduction = false;
            }
            
            analyzeBuffer(buffer) {
                if (!buffer) {
                    logMessage('❌ Kein Raw-Buffer für Analyse', 'error');
                    return;
                }

                const modeText = this.octaveReduction ? '[OKTAVREDUZIERT]' : '[VOLLSPEKTRUM]';
                logMessage(`🔍 Analysiere Raw-Buffer ${modeText}: ${buffer.bufferSize} Samples...`, 'info');

                try {
                    let results = this.performFFTAnalysis(buffer);
                    let t0Buffer = buffer;
                    let reducedPeaks = null;

                    // OKTAVREDUKTION falls aktiviert
                    if (this.octaveReduction) {
                        logMessage('🎵 OKTAVREDUKTION AKTIV: Reduziere alle Peaks auf Grundoktave', 'info');

                        const originalPeaks = [...results.peaks];
                        reducedPeaks = this.reduceToBaseOctave(originalPeaks);
                        t0Buffer = this.createReducedBufferForT0(buffer, reducedPeaks);

                        results.peaks = reducedPeaks;
                        results.originalPeaks = originalPeaks;
                        results.octaveReduced = true;
                        results.method += ' (Oktavreduziert)';

                        logMessage(`🎵 Oktavreduktion: ${originalPeaks.length} → ${reducedPeaks.length} Grundfrequenzen`, 'success');
                    }

                    // T0-AKKORD-ANALYSE mit korrektem Buffer
                    if (this.currentMethod === 't0' || this.currentMethod === 'standard') {
                        const t0Config = {
                            xiTolerance: 50,
                            minFrequencies: 1,
                            maxFrequencies: 15,
                            amplitudeThreshold: 0.05,
                            octaveReduction: this.octaveReduction,
                            reducedPeaks: reducedPeaks
                        };

                        const t0Result = this.t0ChordEngine.analyzeChordFromSnapshot(t0Buffer, t0Config);

                        if (t0Result.success) {
                            results.t0Analysis = t0Result;
                            const chordName = t0Result.recognizedChord?.name || 'Unbekannt';
                            const confidence = t0Result.recognizedChord?.confidence || 0;
                            logMessage(`🎼 T0-Akkord erkannt: ${chordName} (${(confidence*100).toFixed(1)}% Konfidenz)`, 'success');
                            
                            // SCHWEBUNGS-INFO ins Log
                            if (t0Result.beatPattern && t0Result.beatPattern.detected) {
                                logMessage(`🌊 Schwebungs-Analyse: ${t0Result.beatPattern.analysis}`, 'info');
                            }
                        } else {
                            logMessage(`⚠️ T0-Analyse: ${t0Result.error}`, 'warning');
                        }
                    }

                    this.lastResults = results;
                    updateAnalysisDisplay(results);

                    const peakCount = this.octaveReduction ? `${results.originalPeaks?.length || 0}→${results.peaks.length}` : results.peaks.length;
                    logMessage(`✅ Raw-Buffer Analyse ${modeText}: ${peakCount} Peaks erkannt`, 'success');

                } catch (error) {
                    logMessage(`❌ Buffer-Analyse Fehler: ${error.message}`, 'error');
                }
            }
            
            performFFTAnalysis(buffer) {
                const freqData = buffer.freqData;
                const sampleRate = buffer.sampleRate;
                const binSize = sampleRate / (2 * freqData.length);
                
                // Find peaks in raw FFT data
                const peaks = [];
                for (let i = 2; i < freqData.length - 2; i++) {
                    const amplitude = freqData[i] / 255;
                    
                    if (amplitude > this.threshold && 
                        amplitude > freqData[i-1]/255 && 
                        amplitude > freqData[i+1]/255 &&
                        amplitude > freqData[i-2]/255 && 
                        amplitude > freqData[i+2]/255) {
                        
                        const frequency = i * binSize;
                        
                        if (frequency >= 80 && frequency <= 2000) {
                            peaks.push({
                                frequency: frequency,
                                amplitude: amplitude,
                                bin: i
                            });
                        }
                    }
                }
                
                peaks.sort((a, b) => b.amplitude - a.amplitude);
                
                // Calculate statistics from raw buffer
                const totalEnergy = freqData.reduce((sum, val) => sum + (val/255) * (val/255), 0);
                const peakFrequency = peaks.length > 0 ? peaks[0].frequency : 0;
                const spectralCentroid = this.calculateSpectralCentroid(freqData, sampleRate);
                const fundamental = this.findFundamental(peaks);
                
                return {
                    method: 'Raw Buffer T0 Method',
                    timestamp: Date.now(),
                    bufferTimestamp: buffer.timestamp,
                    bufferSize: buffer.bufferSize,
                    sampleRate: buffer.sampleRate,
                    peaks: peaks.slice(0, 10),
                    totalEnergy: totalEnergy,
                    peakFrequency: peakFrequency,
                    spectralCentroid: spectralCentroid,
                    fundamental: fundamental,
                    peakCount: peaks.length
                };
            }
            
            calculateSpectralCentroid(freqData, sampleRate) {
                const binSize = sampleRate / (2 * freqData.length);
                let weightedSum = 0;
                let magnitudeSum = 0;
                
                for (let i = 1; i < freqData.length; i++) {
                    const magnitude = freqData[i] / 255;
                    const frequency = i * binSize;
                    
                    weightedSum += frequency * magnitude;
                    magnitudeSum += magnitude;
                }
                
                return magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
            }
            
            findFundamental(peaks) {
                if (peaks.length === 0) return null;
                
                const sortedByFreq = [...peaks].sort((a, b) => a.frequency - b.frequency);
                
                for (const peak of sortedByFreq) {
                    if (peak.amplitude > 0.25) {
                        return peak;
                    }
                }
                
                return sortedByFreq[0];
            }

            // OKTAVREDUKTION (funktionsfähige Version aus bb1.html)
            reduceToBaseOctave(peaks) {
                const baseOctaveMin = 221; // C4
                const baseOctaveMax = 886; // C5
                const frequencyGroups = new Map();

                logMessage(`🔧 Oktavreduktion Input: ${peaks.length} Peaks werden verarbeitet`, 'info');

                peaks.forEach((peak, index) => {
                    let reducedFreq = peak.frequency;
                    let octaveShifts = 0;
                    const originalFreq = peak.frequency;

                    // Reduziere auf Grundoktave durch Halbierung
                    while (reducedFreq > baseOctaveMax) {
                        reducedFreq = reducedFreq / 2;
                        octaveShifts--;
                    }

                    // Erhöhe auf Grundoktave durch Verdopplung
                    while (reducedFreq < baseOctaveMin) {
                        reducedFreq = reducedFreq * 2;
                        octaveShifts++;
                    }

                    // Gruppiere ähnliche Frequenzen (Toleranz: 5 Hz)
                    const groupKey = Math.round(reducedFreq / 5) * 5;

                    if (frequencyGroups.has(groupKey)) {
                        const existing = frequencyGroups.get(groupKey);
                        existing.amplitude += peak.amplitude;
                        existing.originalFrequencies.push(peak.frequency);
                    } else {
                        frequencyGroups.set(groupKey, {
                            frequency: reducedFreq,
                            amplitude: peak.amplitude,
                            bin: peak.bin,
                            originalFrequencies: [peak.frequency],
                            isOctaveReduced: true
                        });
                    }
                });

                const result = Array.from(frequencyGroups.values()).sort((a, b) => a.frequency - b.frequency);
                logMessage(`🎵 Oktavreduktion OUTPUT: ${result.length} Grundfrequenzen erstellt`, 'success');
                return result;
            }

            createReducedBufferForT0(originalBuffer, reducedPeaks) {
                const newFreqData = new Array(originalBuffer.freqData.length).fill(0);
                const binSize = originalBuffer.sampleRate / (2 * originalBuffer.freqData.length);

                reducedPeaks.forEach((peak, index) => {
                    const binIndex = Math.round(peak.frequency / binSize);
                    if (binIndex > 0 && binIndex < newFreqData.length) {
                        const amplitudeValue = Math.round(peak.amplitude * 255);
                        newFreqData[binIndex] = amplitudeValue;

                        if (binIndex > 1) newFreqData[binIndex-1] = Math.round(amplitudeValue * 0.5);
                        if (binIndex < newFreqData.length-1) newFreqData[binIndex+1] = Math.round(amplitudeValue * 0.5);
                    }
                });

                return {
                    ...originalBuffer,
                    freqData: newFreqData,
                    isOctaveReduced: true,
                    reducedPeakCount: reducedPeaks.length
                };
            }
        }
        
        // Global instances
        let audioEngine = new ModularAudioEngine();
        let visualizer = null;
        let bufferManager = new ModularSnapshotManager();
        let analysisEngine = new ModularAnalysisEngine();
        let isRunning = false;
        let animationId = null;
        let analysisMethod = 't0';
        
        // Update functions
        function updateAnalysisDisplay(results) {
            const displayTime = new Date().toLocaleTimeString();
            const bufferTime = results.bufferTimestamp ? new Date(results.bufferTimestamp).toLocaleTimeString() : 'UNKNOWN';
            
            logMessage(`🖥️ DISPLAY UPDATE: Buffer ${bufferTime} → Display ${displayTime}`, 'info');
            
            // Update visualizer with analysis results
            if (visualizer) {
                visualizer.analysisResults = null;
                visualizer.updateAnalysisResults(results);
                
                if (visualizer.frozen && visualizer.frozenData && results.bufferTimestamp) {
                    const frozenTime = visualizer.frozenData.timestamp;
                    const resultsTime = results.bufferTimestamp;
                    
                    if (frozenTime === resultsTime) {
                        visualizer.drawSpectrum(visualizer.frozenData);
                        logMessage(`✅ SPEKTRUM UPDATED: Timestamps stimmen überein (${new Date(frozenTime).toLocaleTimeString()})`, 'success');
                    } else {
                        const frozenTimeStr = frozenTime ? new Date(frozenTime).toLocaleTimeString() : 'UNKNOWN';
                        const resultsTimeStr = resultsTime ? new Date(resultsTime).toLocaleTimeString() : 'UNKNOWN';
                        logMessage(`⚠️ TIMING MISMATCH: Frozen=${frozenTimeStr}, Results=${resultsTimeStr}`, 'warning');
                        visualizer.drawSpectrum(visualizer.frozenData);
                    }
                } else if (visualizer.frozen && visualizer.frozenData) {
                    visualizer.drawSpectrum(visualizer.frozenData);
                    logMessage(`🔄 SPEKTRUM UPDATED (ohne Timestamp-Check)`, 'info');
                }
            }
            
            // T0-Analysis Display Update MIT SCHWEBUNGS-PRIORITÄT
            if (results.t0Analysis && results.t0Analysis.success) {
                const t0 = results.t0Analysis;
                
                // SCHWEBUNGS-PRIORITÄT: Zeige Schwebung als Hauptergebnis wenn erkannt
                if (t0.beatPattern && t0.beatPattern.detected) {
                    if (t0.beatPattern.type === 'symmetric_beating_pairs' && t0.beatPattern.beatPairs && t0.beatPattern.beatPairs.length > 0) {
                        const bestPair = t0.beatPattern.bestPair || t0.beatPattern.beatPairs[0];
                        document.getElementById('t0DetectedChord').textContent = 
                            `SCHWEBUNGS-PAAR (${bestPair.beatFrequency.toFixed(2)}Hz)`;
                        document.getElementById('t0Quality').textContent = 
                            `${bestPair.quality.toUpperCase()} (${bestPair.beatType})`;
                        document.getElementById('t0Fundamental').textContent = 
                            `${bestPair.lower.toFixed(1)} - ${bestPair.center.toFixed(1)} - ${bestPair.upper.toFixed(1)}Hz`;
                        document.getElementById('t0CompliantIntervals').textContent = 
                            `${t0.beatPattern.totalPairs} Schwebungs-Paare`;
                    } else if (t0.beatPattern.type === 'single_tone') {
                        document.getElementById('t0DetectedChord').textContent = 
                            `EINZELTON (${t0.beatPattern.frequency.toFixed(1)}Hz)`;
                        document.getElementById('t0Quality').textContent = 
                            `Keine Schwebung`;
                        document.getElementById('t0Fundamental').textContent = 
                            `${t0.fundamental.frequency.toFixed(1)}Hz (${t0.fundamental.method})`;
                        document.getElementById('t0CompliantIntervals').textContent = 
                            `${t0.intervalStatistics.t0Compliant}/${t0.intervalStatistics.total}`;
                    } else {
                        document.getElementById('t0DetectedChord').textContent = 
                            `SCHWEBUNG ERKANNT`;
                        document.getElementById('t0Quality').textContent = 
                            `${t0.beatPattern.analysis}`;
                        document.getElementById('t0Fundamental').textContent = 
                            `${t0.fundamental.frequency.toFixed(1)}Hz (${t0.fundamental.method})`;
                        document.getElementById('t0CompliantIntervals').textContent = 
                            `${t0.intervalStatistics.t0Compliant}/${t0.intervalStatistics.total}`;
                    }
                } else {
                    // Standard T0-Akkord-Erkennung (keine Schwebung)
                    document.getElementById('t0DetectedChord').textContent = 
                        t0.recognizedChord?.name || 'Unbekannt';
                    document.getElementById('t0Quality').textContent = 
                        `${t0.quality.grade} (${t0.quality.score.toFixed(1)}%)`;
                    document.getElementById('t0Fundamental').textContent = 
                        `${t0.fundamental.frequency.toFixed(1)}Hz (${t0.fundamental.method})`;
                    document.getElementById('t0CompliantIntervals').textContent = 
                        `${t0.intervalStatistics.t0Compliant}/${t0.intervalStatistics.total}`;
                }
                
                // Diese Werte sind immer gleich
                document.getElementById('avgEulerGradus').textContent = 
                    t0.quality.statistics.averageEulerGradus.toFixed(1) + '°';
                document.getElementById('avgXiDeviation').textContent = 
                    t0.quality.statistics.averageXiDeviation.toFixed(1) + '¢';
                
                // Update T0 chord confidence in main grade if available
                if (t0.recognizedChord) {
                    const t0Confidence = t0.recognizedChord.confidence;
                    const combinedScore = (results.totalEnergy * 0.3 + t0Confidence * 0.7) * 100;
                    document.getElementById('analysisScore').textContent = 
                        `${combinedScore.toFixed(1)}% (mit T0-Akkord)`;
                }
                
                // Enhanced peak display with T0 intervals UND SCHWEBUNGS-INFO
                updateT0PeakDisplay(t0);
                
            } else {
                // Reset T0 fields if no T0 analysis
                document.getElementById('t0DetectedChord').textContent = '-';
                document.getElementById('t0Quality').textContent = '-';
                document.getElementById('t0Fundamental').textContent = '-';
                document.getElementById('t0CompliantIntervals').textContent = '-';
                document.getElementById('avgEulerGradus').textContent = '-';
                document.getElementById('avgXiDeviation').textContent = '-';
            }
            
            // Calculate grade
            const score = Math.min(1, results.peakCount / 10) * 0.5 + 
                         Math.min(1, results.totalEnergy / 100) * 0.5;
            const grade = score > 0.8 ? 'A' : score > 0.6 ? 'B' : score > 0.4 ? 'C' : 'D';
            
            document.getElementById('analysisGrade').textContent = grade;
            if (!results.t0Analysis) {
                document.getElementById('analysisScore').textContent = `${(score * 100).toFixed(1)}% (${results.method})`;
            }
            
            // Color coding
            const gradeElement = document.getElementById('analysisGrade');
            gradeElement.className = '';
            if (score > 0.7) {
                gradeElement.classList.add('grade-a');
            } else if (score > 0.5) {
                gradeElement.classList.add('grade-b');
            } else {
                gradeElement.classList.add('grade-c');
            }
            
            document.getElementById('analysisRecommendation').textContent = 
                score > 0.8 ? '🎯 Exzellente Analyse!' :
                score > 0.6 ? '✅ Gute Ergebnisse' :
                score > 0.4 ? '⚠️ Mittelgradige Qualität' : '❌ Niedrige Qualität';
            
            // Update detected peaks display (standard if no T0)
            if (!results.t0Analysis || !results.t0Analysis.success) {
                updateStandardPeakDisplay(results);
            }
            
            // OKTAVREDUKTION Info anzeigen
            if (results.octaveReduced && results.originalPeaks) {
                document.getElementById('analysisRecommendation').innerHTML = 
                    `🎵 Oktavreduktion aktiv: ${results.originalPeaks.length} → ${results.peaks.length} Grundfrequenzen<br>
                    <small>Alle Frequenzen auf C4-C5 Oktave reduziert</small>`;
            }
        }
        
        function updateT0PeakDisplay(t0Analysis) {
            const peakDisplay = document.getElementById('detectedPeaks');
            
            if (t0Analysis.intervals.length > 0) {
                let peakText = '';
                
                // SCHWEBUNGS-ANALYSE ZUERST ANZEIGEN
                if (t0Analysis.beatPattern && t0Analysis.beatPattern.detected) {
                    if (t0Analysis.beatPattern.type === 'symmetric_beating_pairs' && t0Analysis.beatPattern.beatPairs && t0Analysis.beatPattern.beatPairs.length > 0) {
                        peakText += `<div style="margin-bottom: 12px; padding: 8px; background: rgba(241, 196, 15, 0.25); border-radius: 6px; border-left: 4px solid #f1c40f;">
                            <strong>🎵 SCHWEBUNGS-ANALYSE</strong><br>
                            <div style="font-size: 0.9em; margin-top: 4px;">
                                <strong>Erkannte Paare:</strong> ${t0Analysis.beatPattern.beatPairs.length}<br>
                                <strong>Beste Schwebung:</strong> ${t0Analysis.beatPattern.bestPair ? t0Analysis.beatPattern.bestPair.beatFrequency.toFixed(2) + 'Hz (' + t0Analysis.beatPattern.bestPair.quality + ')' : 'N/A'}
                            </div>
                        </div>`;
                        
                        // Zeige alle Schwebungs-Paare
                        t0Analysis.beatPattern.beatPairs.forEach((pair, i) => {
                            peakText += `<div style="margin-bottom: 6px; padding: 4px; background: rgba(52, 152, 219, 0.1); border-radius: 3px; border-left: 2px solid ${pair.color || '#3498db'};">
                                <div style="font-weight: bold; color: #3498db;">Schwebung #${i+1}: ±${pair.beatFrequency.toFixed(1)}Hz</div>
                                <div style="font-size: 0.7em; color: rgba(255,255,255,0.9);">
                                    📉 ${pair.lower.toFixed(1)}Hz (${(pair.lowerAmplitude*100).toFixed(1)}%)<br>
                                    🎯 ${pair.center.toFixed(1)}Hz (Zentrum)<br>
                                    📈 ${pair.upper.toFixed(1)}Hz (${(pair.upperAmplitude*100).toFixed(1)}%)<br>
                                    <span style="color: ${pair.color || '#3498db'};">${pair.beatType}: ${pair.musicalEffect}</span>
                                </div>
                            </div>`;
                        });
                    } else if (t0Analysis.beatPattern.type === 'single_tone') {
                        peakText += `<div style="margin-bottom: 8px; padding: 6px; background: rgba(46, 204, 113, 0.2); border-radius: 4px; border-left: 3px solid #2ecc71;">
                            <strong>🎯 EINZELTON-ANALYSE</strong><br>
                            <small>Frequenz: ${t0Analysis.beatPattern.frequency.toFixed(1)}Hz (keine Schwebung)</small>
                        </div>`;
                    }
                }
                
                // T0-INTERVALLE anzeigen
                peakText += `<div style="margin-top: 12px; margin-bottom: 6px; font-weight: bold; color: #f1c40f; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">🎼 T0-INTERVALLE</div>`;
                
                t0Analysis.intervals.forEach((interval, index) => {
                    const noteName = getNoteName(interval.frequency, t0Analysis.fundamental.frequency);
                    const rationalStr = `${interval.reducedRational.numerator}/${interval.reducedRational.denominator}`;
                    const t0Status = interval.isT0Compliant ? '✅' : '❌';
                    
                    peakText += `<div style="margin-bottom: 6px; padding: 4px; background: rgba(0,0,0,0.3); border-radius: 3px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong>${interval.frequency.toFixed(1)} Hz</strong>
                            <span style="color: #f1c40f;">${noteName}</span>
                        </div>
                        <div style="font-size: 0.7em; color: rgba(255,255,255,0.8);">
                            Rational: ${rationalStr} | Euler°: ${interval.eulerGradus} | ξ: ${interval.xiDeviation.toFixed(1)}¢ ${t0Status}
                        </div>
                        <div style="font-size: 0.7em; color: rgba(255,255,255,0.6);">
                            Amplitude: ${(interval.amplitude * 100).toFixed(1)}% | Cents: ${interval.cents.toFixed(0)}¢
                        </div>
                    </div>`;
                });
                
                peakDisplay.innerHTML = peakText;
            } else {
                peakDisplay.innerHTML = `
                    <div style="color: rgba(255,255,255,0.6); text-align: center; padding: 20px;">
                        Keine T0-Intervalle erkannt<br>
                        <small>Erhöhe Lautstärke oder reduziere Schwelle</small>
                    </div>
                `;
            }
        }
        
        function updateStandardPeakDisplay(results) {
            const peakDisplay = document.getElementById('detectedPeaks');
            if (results.peaks.length > 0) {
                let peakText = '';

                // OKTAVREDUKTIONS-HEADER falls aktiv
                if (results.octaveReduced && results.originalPeaks) {
                    peakText += `<div style="margin-bottom: 8px; padding: 6px; background: rgba(155, 89, 182, 0.2); border-radius: 4px; border-left: 3px solid #9b59b6;">
                        <strong>🎵 OKTAVREDUKTION AKTIV</strong><br>
                        <small>${results.originalPeaks.length} Originale → ${results.peaks.length} Grundfrequenzen</small>
                    </div>`;
                }

                results.peaks.forEach((peak, index) => {
                    let peakInfo = `<div style="margin-bottom: 4px;">
                        <strong>${peak.frequency.toFixed(1)} Hz</strong><br>
                        <small>Amplitude: ${(peak.amplitude * 100).toFixed(1)}% | Bin: ${peak.bin}</small>`;

                    // OKTAVREDUKTIONS-INFO falls verfügbar
                    if (peak.isOctaveReduced && peak.originalFrequencies) {
                        const originals = peak.originalFrequencies.map(f => f.toFixed(1)).join(', ');
                        peakInfo += `<br><small style="color: #9b59b6;">Ursprünglich: [${originals}] Hz</small>`;
                    }

                    peakInfo += `</div>`;
                    peakText += peakInfo;
                });
                peakDisplay.innerHTML = peakText;
            } else {
                peakDisplay.innerHTML = `
                    <div style="color: rgba(255,255,255,0.6); text-align: center; padding: 20px;">
                        Keine Peaks erkannt<br>
                        <small>Erhöhe Lautstärke oder reduziere Schwelle</small>
                    </div>
                `;
            }
        }
        
        function getNoteName(frequency, fundamental) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const ratio = frequency / fundamental;
            const cents = 1200 * Math.log2(ratio);
            const semitones = Math.round(cents / 100);
            const octave = Math.floor(semitones / 12);
            const noteIndex = ((semitones % 12) + 12) % 12;
            return noteNames[noteIndex] + (octave > 0 ? `+${octave}` : octave < 0 ? octave : '');
        }
        
        function updateGeneratorStatus() {
            document.getElementById('generatorChord').textContent = 
                audioEngine.currentChord ? audioEngine.chordRatios[audioEngine.currentChord].name : 'Keiner';
            
            document.getElementById('generatorRoot').textContent = audioEngine.rootFrequency.toFixed(1) + ' Hz';
            document.getElementById('generatorTuning').textContent = 
                audioEngine.tuningSystem === 'tempered' ? 'Temperiert' : 'Rein';
            document.getElementById('generatorWave').textContent = 
                audioEngine.waveform.charAt(0).toUpperCase() + audioEngine.waveform.slice(1);
            document.getElementById('generatorStatus').textContent = 
                audioEngine.isActive ? 'Aktiv' : 'Bereit';
        }
        
        function updateMicrophoneStatus() {
            document.getElementById('micStatus').textContent = 
                audioEngine.micActive ? 'Aktiv' : 'Inaktiv';
            document.getElementById('micGainStatus').textContent = 
                audioEngine.micGain.toFixed(0) + 'x';
            
            // Update beat status
            document.getElementById('beatStatus').textContent = 
                audioEngine.beatFrequency > 0 ? `±${audioEngine.beatFrequency.toFixed(1)}Hz Dreiklang` : 'Aus';
            
            // Update auto-capture status
            document.getElementById('autoCaptureStatus').textContent = 
                audioEngine.micAutoCapture ? 'Ein (50%)' : 'Aus';
            
            // Update audio source indicator
            const audioData = audioEngine.getAudioData();
            if (audioData) {
                document.getElementById('audioSource').textContent = 
                    audioData.source === 'microphone' ? '🎤 Mikrofon' :
                    audioData.source === 'generator' ? '🎵 Generator' : '🔇 Stille';
            }
            
            // Update mic button styling
            const micBtn = document.getElementById('micBtn');
            if (audioEngine.micActive) {
                micBtn.style.background = 'linear-gradient(145deg, #e74c3c, #c0392b)';
                micBtn.textContent = '🎤 Stop';
            } else {
                micBtn.style.background = 'linear-gradient(145deg, #2ecc71, #27ae60)';
                micBtn.textContent = '🎤 Mikrofon';
            }
            
            // Update auto-capture button styling
            const autoCaptureBtn = document.getElementById('autoCaptureBtn');
            if (audioEngine.micAutoCapture) {
                autoCaptureBtn.style.background = 'linear-gradient(145deg, #f39c12, #e67e22)';
                autoCaptureBtn.textContent = '🎯 Auto-Capture';
            } else {
                autoCaptureBtn.style.background = 'linear-gradient(145deg, #95a5a6, #7f8c8d)';
                autoCaptureBtn.textContent = '🎯 Manuell';
            }
        }
        
        // REPARIERTE updateMicLevel Funktion
        function updateMicLevel(level) {
            const levelPercent = Math.min(100, level * 100);
            const levelBar = document.getElementById('micLevelBar');
            const levelText = document.getElementById('micLevelText');
            
            if (levelBar && levelText) {
                levelBar.style.width = levelPercent + '%';
                levelText.textContent = levelPercent.toFixed(0) + '%';
                
                // Color coding based on level mit 50% Schwellen-Markierung
                if (levelPercent >= 50) {
                    levelBar.style.background = '#f39c12'; // Orange - über Schwelle
                    if (levelPercent > 80) {
                        levelBar.style.background = '#e74c3c'; // Red - zu laut
                    }
                } else if (levelPercent > 20) {
                    levelBar.style.background = '#2ecc71'; // Green - unter Schwelle aber hörbar
                } else {
                    levelBar.style.background = '#3498db'; // Blue - sehr leise
                }
                
                // Schwellen-Markierung bei 50%
                const threshold = document.getElementById('micThresholdLine');
                if (!threshold) {
                    const container = levelBar.parentElement;
                    const line = document.createElement('div');
                    line.id = 'micThresholdLine';
                    line.style.cssText = `
                        position: absolute;
                        left: 50%;
                        top: 0;
                        width: 2px;
                        height: 100%;
                        background: #f1c40f;
                        opacity: 0.8;
                        z-index: 10;
                    `;
                    container.appendChild(line);
                }
            }
        }
        
        function analysisLoop() {
            if (!isRunning) return;
            
            const audioData = audioEngine.getAudioData();
            if (audioData) {
                visualizer.drawSpectrum(audioData);
            }
            
            animationId = requestAnimationFrame(analysisLoop);
        }
        
        function startAnalysis() {
            if (isRunning) return;
            isRunning = true;
            analysisLoop();
        }
        
        function stopAnalysis() {
            if (!isRunning) return;
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        function logMessage(message, type = 'info') {
            const log = document.getElementById('logPanel');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            
            while (log.children.length > 20) {
                log.removeChild(log.firstChild);
            }
        }
        
        // Event Handlers
        function setupEventHandlers() {
            // Chord buttons
            document.querySelectorAll('.chord-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    if (!audioEngine.audioContext) {
                        const success = await audioEngine.initialize();
                        if (!success) return;
                    }
                    
                    if (!isRunning) {
                        startAnalysis();
                    }
                    
                    document.querySelectorAll('.chord-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    audioEngine.playChordTimed(btn.dataset.chord);
                    
                    setTimeout(() => {
                        btn.classList.remove('active');
                    }, audioEngine.playDuration + 100);
                });
            });
            
            // Sliders
            document.getElementById('rootFreqSlider').addEventListener('input', (e) => {
                const freq = parseFloat(e.target.value);
                audioEngine.setRootFrequency(freq);
                document.getElementById('rootFreqDisplay').textContent = freq.toFixed(1) + ' Hz';
            });
            
            document.getElementById('volumeSlider').addEventListener('input', (e) => {
                const volume = parseInt(e.target.value);
                audioEngine.setVolume(volume);
                document.getElementById('volumeDisplay').textContent = volume + '%';
            });
            
            document.getElementById('thresholdSlider').addEventListener('input', (e) => {
                const threshold = parseFloat(e.target.value);
                analysisEngine.threshold = threshold;
                document.getElementById('thresholdDisplay').textContent = (threshold * 100).toFixed(0) + '%';
            });
            
            document.getElementById('spectrumGainSlider').addEventListener('input', (e) => {
                const gain = parseFloat(e.target.value);
                visualizer.setSpectrumGain(gain);
                document.getElementById('spectrumGainDisplay').textContent = gain.toFixed(1) + 'x';
            });
            
            document.getElementById('micGainSlider').addEventListener('input', (e) => {
                const gain = parseInt(e.target.value);
                audioEngine.setMicGain(gain);
                document.getElementById('micGainDisplay').textContent = gain + 'x';
                updateMicrophoneStatus();
            });
            
            document.getElementById('beatFreqSlider').addEventListener('input', (e) => {
                const freq = parseFloat(e.target.value);
                audioEngine.setBeatFrequency(freq);
                document.getElementById('beatFreqDisplay').textContent = freq.toFixed(1) + ' Hz';
                updateMicrophoneStatus();
            });
            
            // Mode buttons
            document.getElementById('tuningBtn').addEventListener('click', () => {
                const newTuning = audioEngine.tuningSystem === 'tempered' ? 'just' : 'tempered';
                audioEngine.setTuningSystem(newTuning);
                document.getElementById('tuningBtn').textContent = 
                    newTuning === 'tempered' ? '🎼 Temperiert' : '🎼 Rein';
            });
            
            document.getElementById('waveformBtn').addEventListener('click', () => {
                const waveforms = ['sine', 'sawtooth', 'square', 'triangle'];
                const currentIndex = waveforms.indexOf(audioEngine.waveform);
                const nextWaveform = waveforms[(currentIndex + 1) % waveforms.length];
                
                audioEngine.setWaveform(nextWaveform);
                
                const icons = { sine: '🌊', sawtooth: '🔺', square: '⬜', triangle: '🔻' };
                const names = { sine: 'Sinus', sawtooth: 'Sägezahn', square: 'Rechteck', triangle: 'Dreieck' };
                document.getElementById('waveformBtn').textContent = 
                    `${icons[nextWaveform]} ${names[nextWaveform]}`;
            });
            
            // Mikrofon Button
            document.getElementById('micBtn').addEventListener('click', async () => {
                if (audioEngine.micActive) {
                    audioEngine.stopMicrophone();
                } else {
                    await audioEngine.startMicrophone();
                }
                updateMicrophoneStatus();
            });
            
            // Auto-Capture Button
            document.getElementById('autoCaptureBtn').addEventListener('click', () => {
                audioEngine.setMicAutoCapture(!audioEngine.micAutoCapture);
                updateMicrophoneStatus();
            });
            
            // Spectrum controls
            document.getElementById('scaleBtn').addEventListener('click', () => {
                const scales = ['log', 'linear'];
                const currentIndex = scales.indexOf(visualizer.scale);
                const nextScale = scales[(currentIndex + 1) % scales.length];
                
                visualizer.setScale(nextScale);
                
                const icons = { log: '📏', linear: '📐' };
                const names = { log: 'Log', linear: 'Linear' };
                document.getElementById('scaleBtn').textContent = `${icons[nextScale]} ${names[nextScale]}`;
            });
            
            document.getElementById('zoomBtn').addEventListener('click', () => {
                const modes = ['full', 'bass', 'mid', 'high'];
                const currentIndex = modes.indexOf(visualizer.zoomMode);
                const nextMode = modes[(currentIndex + 1) % modes.length];
                
                visualizer.setZoom(nextMode);
                document.getElementById('zoomBtn').textContent = `🔍 ${visualizer.zoomPresets[nextMode].name}`;
            });
            
            document.getElementById('freezeBtn').addEventListener('click', () => {
                visualizer.freeze();
                const btn = document.getElementById('freezeBtn');
                btn.textContent = visualizer.frozen ? '🔥 Unfreeze' : '❄️ Freeze';
                btn.classList.toggle('active', visualizer.frozen);
            });
            
            document.getElementById('captureBtn').addEventListener('click', () => {
                bufferManager.captureRawBuffer();
            });
            
            document.getElementById('methodBtn').addEventListener('click', () => {
                if (analysisMethod === 't0') {
                    analysisMethod = 'standard';
                    document.getElementById('methodBtn').textContent = '🔬 Standard FFT';
                    document.getElementById('methodBtn').style.background = 'linear-gradient(145deg, #3498db, #2980b9)';
                    document.getElementById('peaksTitle').textContent = '🎯 Erkannte Peaks';
                    logMessage('📊 Standard FFT Methode aktiviert', 'info');
                } else {
                    analysisMethod = 't0';
                    document.getElementById('methodBtn').textContent = '🎼 T0-Akkord-Analyse';
                    document.getElementById('methodBtn').style.background = 'linear-gradient(145deg, #9b59b6, #8e44ad)';
                    document.getElementById('peaksTitle').textContent = '🎼 T0-Intervalle';
                    logMessage('🎼 T0-Akkord-Analyse aktiviert', 'info');
                }
                analysisEngine.currentMethod = analysisMethod;
            });

            // Oktavreduktions-Button
            document.getElementById('octaveBtn').addEventListener('click', () => {
                analysisEngine.octaveReduction = !analysisEngine.octaveReduction;

                const btn = document.getElementById('octaveBtn');
                if (analysisEngine.octaveReduction) {
                    btn.textContent = '🎵 Oktavreduziert';
                    btn.style.background = 'linear-gradient(145deg, #9b59b6, #8e44ad)';
                    btn.classList.add('active');
                    logMessage('🎵 Oktavreduktion AKTIVIERT: Alle Frequenzen → C4-C5 Grundoktave', 'info');
                } else {
                    btn.textContent = '🎵 Vollspektrum';
                    btn.style.background = 'linear-gradient(145deg, #3498db, #2980b9)';
                    btn.classList.remove('active');
                    logMessage('🎵 Vollspektrum AKTIVIERT: Originale Frequenzen', 'info');
                }

                // Re-analysiere aktuellen Buffer falls vorhanden
                if (bufferManager.selectedBuffer) {
                    logMessage(`🔄 Re-Analyse mit ${analysisEngine.octaveReduction ? 'OKTAVREDUKTION' : 'VOLLSPEKTRUM'}`, 'warning');

                    // Clear alte Results SOFORT
                    analysisEngine.lastResults = null;
                    if (visualizer) {
                        visualizer.analysisResults = null;
                    }

                    setTimeout(() => {
                        analysisEngine.analyzeBuffer(bufferManager.selectedBuffer);
                    }, 50);
                }
            });
            
            document.getElementById('resetBtn').addEventListener('click', () => {
                visualizer.setupCanvas();
                visualizer.frozen = false;
                visualizer.frozenData = null;
                visualizer.analysisResults = null;
                
                document.getElementById('freezeBtn').textContent = '❄️ Freeze';
                document.getElementById('freezeBtn').classList.remove('active');
                
                // Reset selected buffer to prevent auto-selection
                bufferManager.selectedBuffer = null;
                
                // Reset T0 analysis display
                document.getElementById('t0DetectedChord').textContent = '-';
                document.getElementById('t0Quality').textContent = '-';
                document.getElementById('t0Fundamental').textContent = '-';
                document.getElementById('t0CompliantIntervals').textContent = '-';
                document.getElementById('avgEulerGradus').textContent = '-';
                document.getElementById('avgXiDeviation').textContent = '-';
                document.getElementById('peaksTitle').textContent = '🎯 Erkannte Peaks';
                document.getElementById('analysisGrade').textContent = '-';
                document.getElementById('analysisScore').textContent = 'Wähle Raw-Buffer für Analyse';
                document.getElementById('peakCount').textContent = '0';
                document.getElementById('fundamentalFreq').textContent = '-';
                document.getElementById('spectralCentroid').textContent = '-';
                document.getElementById('energyLevel').textContent = '-';
                document.getElementById('bufferSize').textContent = '-';
                document.getElementById('analysisRecommendation').textContent = 'Erstelle Raw-Buffer und starte Analyse';
                document.getElementById('detectedPeaks').innerHTML = `
                    <div style="color: rgba(255,255,255,0.6); text-align: center; padding: 20px;">
                        Keine Peaks erkannt<br>
                        <small>Starte Raw-Buffer-Analyse</small>
                    </div>
                `;
                
                // Update buffer list to remove selection highlighting
                bufferManager.updateBufferList();
                
                logMessage('🔄 Reset - Live-Modus', 'info');
            });
            
            // File operations
            document.getElementById('saveBtn').addEventListener('click', () => {
                bufferManager.saveRawBuffers();
            });
            
            document.getElementById('loadBtn').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            
            document.getElementById('fileInput').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    bufferManager.loadRawBuffers(file);
                }
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                if (visualizer) {
                    visualizer.setupCanvas();
                }
            });
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            logMessage('🎵 Modular Audio Analyzer mit T0-Theorie und Schwebungs-Erkennung gestartet', 'info');
            
            // Initialize canvas
            const canvas = document.getElementById('spectrum-canvas');
            visualizer = new ModularSpectrumVisualizer(canvas);
            
            // Setup event handlers
            setupEventHandlers();
            
            // Initialize audio engine
            await audioEngine.initialize();
            
            // Start analysis immediately for live spectrum display
            startAnalysis();
            
            // Update displays
            updateGeneratorStatus();
            updateMicrophoneStatus();
            
            // Set initial T0 mode styling
            document.getElementById('methodBtn').style.background = 'linear-gradient(145deg, #9b59b6, #8e44ad)';
            document.getElementById('peaksTitle').textContent = '🎼 T0-Intervalle';
            analysisEngine.currentMethod = 't0';
            
            logMessage('✅ System bereit! T0-Akkord-Erkennung mit Schwebungs-Analyse vorausgewählt', 'success');
            logMessage('🎼 T0-Modus aktiv - spiele Akkorde für automatische Analyse', 'info');
            logMessage('🎤 Mikrofon verfügbar - Auto-Capture bei 50% Level aktiviert', 'info');
            logMessage('📊 Live-Spektrum läuft - spiele Akkorde für automatische Buffer-Erfassung', 'info');
            logMessage('🎵 Oktavreduktion verfügbar - Button umschalten zwischen Vollspektrum ⟷ Oktavreduziert', 'success');
            logMessage('🌊 Schwebungs-Analyse integriert - erkannt und im T0-Panel angezeigt', 'success');
            logMessage('🔧 Mikrofon-Problem repariert - Level-Monitoring funktioniert wieder', 'success');
            logMessage('🎯 442Hz Grundton voreingestellt - perfekt für Barock-Stimmung', 'info');
        });
    </script>
</body>
</html>
            