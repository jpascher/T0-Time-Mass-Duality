<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harmonische Faktorisierung</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            backdrop-filter: blur(10px);
        }
        
        .input-section h2 {
            color: #4A5568;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2D3748;
        }
        
        input[type="number"], input[type="range"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #E2E8F0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .tolerance-display {
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
            color: #667eea;
        }
        
        button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .test-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }
        
        .test-btn {
            background: linear-gradient(135deg, #48BB78, #38A169);
            font-size: 14px;
            padding: 12px;
        }
        
        .test-btn:hover {
            background: linear-gradient(135deg, #38A169, #2F855A);
        }
        
        .result-section {
            min-height: 400px;
        }
        
        .result-content {
            display: none;
        }
        
        .result-content.active {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .success {
            background: linear-gradient(135deg, #48BB78, #38A169);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .failure {
            background: linear-gradient(135deg, #F56565, #E53E3E);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .harmonic-info {
            background: #F7FAFC;
            border: 2px solid #E2E8F0;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .factors {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
        }
        
        .ratio-comparison {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 15px;
            align-items: center;
            margin: 15px 0;
        }
        
        .ratio-box {
            background: white;
            border: 2px solid #E2E8F0;
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }
        
        .ratio-box.actual {
            border-color: #667eea;
        }
        
        .ratio-box.target {
            border-color: #48BB78;
        }
        
        .example-numbers {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .example-number {
            background: #EDF2F7;
            border: 1px solid #CBD5E0;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .example-number:hover {
            background: #667eea;
            color: white;
        }
        
        .test-results {
            max-height: 400px;
            overflow-y: auto;
            background: #F7FAFC;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .test-result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #E2E8F0;
        }
        
        .test-result-item:last-child {
            border-bottom: none;
        }
        
        .success-icon {
            color: #48BB78;
            font-weight: bold;
        }
        
        .failure-icon {
            color: #F56565;
            font-weight: bold;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-item {
            background: #F7FAFC;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #718096;
            margin-top: 5px;
        }
        
        .harmonics-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .harmonics-table th,
        .harmonics-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #E2E8F0;
        }
        
        .harmonics-table th {
            background: #F7FAFC;
            font-weight: 600;
            color: #4A5568;
        }
        
        .harmonics-table tr:hover {
            background: #F7FAFC;
        }
        
        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎵 Harmonische Faktorisierung</h1>
            <p>Die Musik der Mathematik - Faktorisierung durch musikalische Verhältnisse</p>
        </div>
        
        <div class="main-grid">
            <div class="card input-section">
                <h2>🔢 Einzeltest</h2>
                
                <div class="input-group">
                    <label for="numberInput">Zu faktorisierende Zahl:</label>
                    <input type="number" id="numberInput" value="221" min="4" max="1000000">
                </div>
                
                <div class="input-group">
                    <label for="toleranceInput">Toleranz: <span id="toleranceValue">5.0%</span></label>
                    <input type="range" id="toleranceInput" min="0.1" max="10" step="0.1" value="5.0">
                </div>
                
                <button onclick="factorizeNumber()">🎼 Harmonisch Faktorisieren</button>
                
                <div class="example-numbers">
                    <div class="example-number" onclick="useExample(77)">77</div>
                    <div class="example-number" onclick="useExample(143)">143</div>
                    <div class="example-number" onclick="useExample(221)">221</div>
                    <div class="example-number" onclick="useExample(323)">323</div>
                    <div class="example-number" onclick="useExample(391)">391</div>
                    <div class="example-number" onclick="useExample(1247)">1247</div>
                </div>
            </div>
            
            <div class="card">
                <h2>🧪 Serientests</h2>
                
                <div class="test-buttons">
                    <button class="test-btn" onclick="runPrimeProductTest()">🔢 Primzahl-Produkte</button>
                    <button class="test-btn" onclick="runHarmonicConstructionTest()">🎼 Harmonische Zahlen</button>
                    <button class="test-btn" onclick="runRangeTest()">📊 Bereichstest</button>
                    <button class="test-btn" onclick="runPerformanceTest()">⚡ Performance Test</button>
                </div>
                
                <div class="input-group">
                    <label for="testCount">Anzahl Tests:</label>
                    <input type="number" id="testCount" value="20" min="5" max="100">
                </div>
                
                <div class="input-group">
                    <label for="maxNumber">Max. Zahl:</label>
                    <input type="number" id="maxNumber" value="10000" min="100" max="1000000">
                </div>
                
                <div id="testProgress" style="display: none;">
                    <div style="background: #E2E8F0; border-radius: 4px; height: 8px; margin: 10px 0;">
                        <div id="progressBar" style="background: #667eea; height: 100%; border-radius: 4px; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <p id="progressText" style="text-align: center; font-size: 14px; color: #718096;"></p>
                </div>
            </div>
            
            <div class="card result-section">
                <h2>📊 Ergebnisse</h2>
                <div id="resultContent">
                    <p style="text-align: center; color: #718096; margin-top: 50px;">
                        Führen Sie einen Test durch, um Ergebnisse zu sehen
                    </p>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>🎼 Harmonische Intervalle</h2>
            <p>Die fundamentalen musikalischen Verhältnisse, die zur Faktorisierung verwendet werden:</p>
            
            <table class="harmonics-table">
                <thead>
                    <tr>
                        <th>Intervall</th>
                        <th>Verhältnis</th>
                        <th>Dezimalwert</th>
                        <th>Kategorie</th>
                    </tr>
                </thead>
                <tbody id="harmonicsTable">
                </tbody>
            </table>
        </div>
        
        <div id="statistics" class="card" style="display: none;">
            <h2>📈 Session Statistiken</h2>
            <div class="stats" id="statsContent"></div>
        </div>
    </div>

    <script>
        // Harmonische Intervalle basierend auf der Library
        const harmonicIntervals = [
            { name: "Große Sekunde", ratio: [9, 8], category: "Sekunde" },
            { name: "Kleine Terz", ratio: [6, 5], category: "Terz" },
            { name: "Große Terz", ratio: [5, 4], category: "Terz" },
            { name: "Quarte", ratio: [4, 3], category: "Quarte" },
            { name: "Quinte", ratio: [3, 2], category: "Quinte" },
            { name: "Kleine Sexte", ratio: [8, 5], category: "Sexte" },
            { name: "Große Sexte", ratio: [5, 3], category: "Sexte" },
            { name: "Kleine Septime", ratio: [16, 9], category: "Septime" },
            { name: "Große Septime", ratio: [15, 8], category: "Septime" }
        ];
        
        // Statistiken
        let statistics = {
            totalFactorizations: 0,
            successfulFactorizations: 0,
            exactMatches: 0,
            totalTime: 0,
            testResults: []
        };
        
        // Initialisierung
        document.addEventListener('DOMContentLoaded', function() {
            updateToleranceDisplay();
            populateHarmonicsTable();
            
            // Event Listeners
            document.getElementById('toleranceInput').addEventListener('input', updateToleranceDisplay);
            document.getElementById('numberInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') factorizeNumber();
            });
        });
        
        function updateToleranceDisplay() {
            const tolerance = document.getElementById('toleranceInput').value;
            document.getElementById('toleranceValue').textContent = tolerance + '%';
        }
        
        function populateHarmonicsTable() {
            const tbody = document.getElementById('harmonicsTable');
            tbody.innerHTML = '';
            
            harmonicIntervals.forEach(interval => {
                const row = document.createElement('tr');
                const decimalValue = (interval.ratio[0] / interval.ratio[1]).toFixed(4);
                
                row.innerHTML = `
                    <td><strong>${interval.name}</strong></td>
                    <td>${interval.ratio[0]}:${interval.ratio[1]}</td>
                    <td>${decimalValue}</td>
                    <td>${interval.category}</td>
                `;
                
                tbody.appendChild(row);
            });
        }
        
        function useExample(number) {
            document.getElementById('numberInput').value = number;
            factorizeNumber();
        }
        
        // Harmonische Faktorisierung mit MathJS für exakte Berechnungen
        function factorizeNumber() {
            const number = parseInt(document.getElementById('numberInput').value);
            const tolerance = parseFloat(document.getElementById('toleranceInput').value) / 100;
            
            if (!number || number < 4) {
                showError("Bitte geben Sie eine Zahl ≥ 4 ein.");
                return;
            }
            
            const startTime = performance.now();
            statistics.totalFactorizations++;
            
            // Verwende MathJS für exakte Berechnungen
            const numberFraction = math.fraction(number);
            
            // Teste zuerst exakte harmonische Verhältnisse
            const exactResult = testExactHarmonics(numberFraction);
            if (exactResult) {
                const endTime = performance.now();
                exactResult.time = endTime - startTime;
                statistics.successfulFactorizations++;
                statistics.exactMatches++;
                statistics.totalTime += exactResult.time;
                showSuccess(number, exactResult.factors, exactResult.ratio, exactResult.harmonic, true, 0, exactResult.time);
                updateStatistics();
                return;
            }
            
            // Fallback: klassische Faktorisierung mit Harmonieprüfung
            const factors = findFactors(number);
            if (!factors) {
                const endTime = performance.now();
                showError(`${number} ist eine Primzahl und kann nicht faktorisiert werden.`);
                return;
            }
            
            // Berechne Verhältnis mit MathJS
            const ratio = math.divide(math.max(factors[0], factors[1]), math.min(factors[0], factors[1]));
            const ratioDecimal = math.number(ratio);
            
            // Finde nächstes harmonisches Intervall
            const harmonicMatch = findClosestHarmonic(ratioDecimal, tolerance);
            
            const endTime = performance.now();
            const testTime = endTime - startTime;
            statistics.totalTime += testTime;
            
            if (harmonicMatch) {
                statistics.successfulFactorizations++;
                showSuccess(number, factors, ratioDecimal, harmonicMatch, false, harmonicMatch.deviation * 100, testTime);
            } else {
                showFailure(number, factors, ratioDecimal, testTime);
            }
            
            updateStatistics();
        }
        
        function testExactHarmonics(numberFraction) {
            for (const interval of harmonicIntervals) {
                const ratioFraction = math.fraction(interval.ratio[0], interval.ratio[1]);
                
                // Teste: n = a × b, wobei a:b = ratio
                // Also: a = ratio × b und n = ratio × b²
                // Daher: b = sqrt(n / ratio) und a = ratio × b
                
                const onePlusRatio = math.add(ratioFraction, math.fraction(1));
                
                // Berechne potenzielle Faktoren
                try {
                    const bNumerator = math.multiply(numberFraction, onePlusRatio.d);
                    const bDenominator = onePlusRatio.n;
                    
                    if (math.mod(bNumerator, bDenominator).equals(0)) {
                        const b = math.divide(bNumerator, bDenominator);
                        const a = math.multiply(numberFraction, ratioFraction.d, onePlusRatio.d);
                        const aDenom = math.multiply(ratioFraction.n, onePlusRatio.n);
                        
                        if (math.mod(a, aDenom).equals(0)) {
                            const aFinal = math.divide(a, aDenom);
                            
                            // Prüfe ob beide Faktoren ganzzahlig und > 1 sind
                            if (math.isInteger(aFinal) && math.isInteger(b) && 
                                math.larger(aFinal, 1) && math.larger(b, 1) &&
                                math.equal(math.multiply(aFinal, b), numberFraction)) {
                                
                                return {
                                    factors: [math.number(aFinal), math.number(b)],
                                    ratio: math.number(ratioFraction),
                                    harmonic: interval
                                };
                            }
                        }
                    }
                } catch (e) {
                    // Ignoriere Fehler und teste nächstes Intervall
                    continue;
                }
            }
            return null;
        }
        
        function findFactors(n) {
            for (let i = 2; i <= Math.sqrt(n); i++) {
                if (n % i === 0) {
                    return [i, n / i];
                }
            }
            return null; // Primzahl
        }
        
        function findClosestHarmonic(ratio, tolerance) {
            let bestMatch = null;
            let minDeviation = Infinity;
            
            for (const interval of harmonicIntervals) {
                const harmonicRatio = interval.ratio[0] / interval.ratio[1];
                const deviation = Math.abs(ratio - harmonicRatio) / harmonicRatio;
                
                if (deviation <= tolerance && deviation < minDeviation) {
                    minDeviation = deviation;
                    bestMatch = {
                        interval: interval,
                        deviation: deviation,
                        harmonicRatio: harmonicRatio
                    };
                }
            }
            
            return bestMatch;
        }
        
        // Serientests
        async function runPrimeProductTest() {
            const count = parseInt(document.getElementById('testCount').value);
            const maxNumber = parseInt(document.getElementById('maxNumber').value);
            
            showProgress(true, "Generiere Primzahlen...");
            
            // Generiere Primzahlen
            const primes = generatePrimes(Math.min(maxNumber, 1000));
            
            const testResults = [];
            const tolerance = parseFloat(document.getElementById('toleranceInput').value) / 100;
            
            for (let i = 0; i < count; i++) {
                updateProgress((i / count) * 100, `Teste Primzahl-Produkt ${i + 1}/${count}`);
                
                // Wähle zwei zufällige Primzahlen
                const p1 = primes[Math.floor(Math.random() * primes.length)];
                const p2 = primes[Math.floor(Math.random() * primes.length)];
                const number = p1 * p2;
                
                if (number <= maxNumber) {
                    const result = testSingleNumber(number, tolerance);
                    testResults.push({
                        number: number,
                        factors: [p1, p2],
                        result: result
                    });
                }
                
                // Kleine Pause für UI Update
                await new Promise(resolve => setTimeout(resolve, 1));
            }
            
            showProgress(false);
            showTestResults("Primzahl-Produkte Test", testResults);
        }
        
        async function runHarmonicConstructionTest() {
            showProgress(true, "Konstruiere harmonische Zahlen...");
            
            const testResults = [];
            const tolerance = parseFloat(document.getElementById('toleranceInput').value) / 100;
            const maxK = 10;
            
            let totalTests = harmonicIntervals.length * maxK;
            let currentTest = 0;
            
            for (const interval of harmonicIntervals) {
                for (let k = 1; k <= maxK; k++) {
                    currentTest++;
                    updateProgress((currentTest / totalTests) * 100, 
                                 `Teste ${interval.name}, k=${k}`);
                    
                    const a = k * interval.ratio[0];
                    const b = k * interval.ratio[1];
                    const number = a * b;
                    
                    const result = testSingleNumber(number, tolerance);
                    testResults.push({
                        number: number,
                        factors: [a, b],
                        result: result,
                        harmonic: interval.name,
                        k: k
                    });
                    
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            showProgress(false);
            showTestResults("Harmonische Konstruktion Test", testResults);
        }
        
        async function runRangeTest() {
            const maxNumber = parseInt(document.getElementById('maxNumber').value);
            const start = Math.max(100, maxNumber - 500);
            const end = maxNumber;
            
            showProgress(true, "Teste Zahlenbereich...");
            
            const testResults = [];
            const tolerance = parseFloat(document.getElementById('toleranceInput').value) / 100;
            
            let compositeCount = 0;
            const step = Math.max(1, Math.floor((end - start) / 100)); // Max 100 Tests
            
            for (let n = start; n <= end; n += step) {
                if (isComposite(n)) {
                    compositeCount++;
                    updateProgress(((n - start) / (end - start)) * 100, 
                                 `Teste Zahl ${n} (${compositeCount} zusammengesetzte)`);
                    
                    const result = testSingleNumber(n, tolerance);
                    testResults.push({
                        number: n,
                        factors: findFactors(n),
                        result: result
                    });
                    
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            showProgress(false);
            showTestResults(`Bereichstest ${start}-${end}`, testResults);
        }
        
        async function runPerformanceTest() {
            const count = Math.min(parseInt(document.getElementById('testCount').value), 50);
            
            showProgress(true, "Performance Test läuft...");
            
            const testNumbers = [];
            const maxNumber = parseInt(document.getElementById('maxNumber').value);
            
            // Generiere Testzahlen
            for (let i = 0; i < count; i++) {
                let number;
                do {
                    number = Math.floor(Math.random() * (maxNumber - 100)) + 100;
                } while (!isComposite(number));
                testNumbers.push(number);
            }
            
            const tolerance = parseFloat(document.getElementById('toleranceInput').value) / 100;
            const results = [];
            
            for (let i = 0; i < testNumbers.length; i++) {
                updateProgress((i / testNumbers.length) * 100, 
                             `Performance Test ${i + 1}/${testNumbers.length}`);
                
                const number = testNumbers[i];
                const startTime = performance.now();
                
                // Harmonischer Test
                const harmonicResult = testSingleNumber(number, tolerance);
                const harmonicTime = performance.now() - startTime;
                
                // Klassischer Test (nur Zeitmessung)
                const classicStartTime = performance.now();
                findFactors(number); // Klassische Faktorisierung
                const classicTime = performance.now() - classicStartTime;
                
                results.push({
                    number: number,
                    harmonicTime: harmonicTime,
                    classicTime: classicTime,
                    speedup: classicTime / harmonicTime,
                    success: harmonicResult.success
                });
                
                await new Promise(resolve => setTimeout(resolve, 1));
            }
            
            showProgress(false);
            showPerformanceResults(results);
        }
        
        function testSingleNumber(number, tolerance) {
            const startTime = performance.now();
            
            // Teste exakte harmonische Verhältnisse mit MathJS
            const numberFraction = math.fraction(number);
            const exactResult = testExactHarmonics(numberFraction);
            
            if (exactResult) {
                return {
                    success: true,
                    exact: true,
                    factors: exactResult.factors,
                    harmonic: exactResult.harmonic,
                    ratio: exactResult.ratio,
                    deviation: 0,
                    time: performance.now() - startTime
                };
            }
            
            // Fallback: klassische Faktorisierung
            const factors = findFactors(number);
            if (!factors) return { success: false, time: performance.now() - startTime };
            
            const ratio = Math.max(factors[0], factors[1]) / Math.min(factors[0], factors[1]);
            const harmonicMatch = findClosestHarmonic(ratio, tolerance);
            
            return {
                success: !!harmonicMatch,
                exact: false,
                factors: factors,
                harmonic: harmonicMatch ? harmonicMatch.interval : null,
                ratio: ratio,
                deviation: harmonicMatch ? harmonicMatch.deviation * 100 : null,
                time: performance.now() - startTime
            };
        }
        
        function generatePrimes(max) {
            const sieve = new Array(max + 1).fill(true);
            sieve[0] = sieve[1] = false;
            
            for (let i = 2; i <= Math.sqrt(max); i++) {
                if (sieve[i]) {
                    for (let j = i * i; j <= max; j += i) {
                        sieve[j] = false;
                    }
                }
            }
            
            return sieve.map((isPrime, num) => isPrime ? num : null).filter(num => num !== null);
        }
        
        function isComposite(n) {
            if (n < 4) return false;
            for (let i = 2; i <= Math.sqrt(n); i++) {
                if (n % i === 0) return true;
            }
            return false;
        }
        
        function showProgress(show, text = '') {
            const progressDiv = document.getElementById('testProgress');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            
            if (show) {
                progressDiv.style.display = 'block';
                progressText.textContent = text;
                progressBar.style.width = '0%';
            } else {
                progressDiv.style.display = 'none';
            }
        }
        
        function updateProgress(percent, text) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            
            progressBar.style.width = percent + '%';
            progressText.textContent = text;
        }
        
        function showTestResults(testName, results) {
            const successCount = results.filter(r => r.result.success).length;
            const exactCount = results.filter(r => r.result.exact).length;
            const successRate = (successCount / results.length * 100).toFixed(1);
            const exactRate = (exactCount / results.length * 100).toFixed(1);
            
            // Aktualisiere globale Statistiken
            statistics.totalFactorizations += results.length;
            statistics.successfulFactorizations += successCount;
            statistics.exactMatches += exactCount;
            statistics.testResults = results;
            
            const content = `
                <div class="success">
                    <h3>✅ ${testName} Abgeschlossen</h3>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-top: 15px;">
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold;">${results.length}</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">Tests</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold;">${successRate}%</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">Erfolgsquote</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold;">${exactRate}%</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">Exakt</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold;">${successCount}</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">Harmonisch</div>
                        </div>
                    </div>
                </div>
                
                <div class="test-results">
                    ${results.slice(0, 20).map(r => `
                        <div class="test-result-item">
                            <span>${r.number}: ${r.factors[0]} × ${r.factors[1]}</span>
                            <span>
                                ${r.result.success ? 
                                    `<span class="success-icon">✅ ${r.result.harmonic.name} ${r.result.exact ? '(exakt)' : `(${r.result.deviation.toFixed(2)}%)`}</span>` :
                                    '<span class="failure-icon">❌ Nicht harmonisch</span>'
                                }
                            </span>
                        </div>
                    `).join('')}
                    ${results.length > 20 ? `<div style="text-align: center; margin-top: 10px; color: #718096;">... und ${results.length - 20} weitere Ergebnisse</div>` : ''}
                </div>
            `;
            
            showResult(content);
            updateStatistics();
        }
        
        function showPerformanceResults(results) {
            const avgHarmonicTime = results.reduce((sum, r) => sum + r.harmonicTime, 0) / results.length;
            const avgClassicTime = results.reduce((sum, r) => sum + r.classicTime, 0) / results.length;
            const avgSpeedup = results.reduce((sum, r) => sum + r.speedup, 0) / results.length;
            const successCount = results.filter(r => r.success).length;
            
            const content = `
                <div class="success">
                    <h3>⚡ Performance Test Ergebnisse</h3>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-top: 15px;">
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold;">${avgHarmonicTime.toFixed(2)}ms</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">⌀ Harmonisch</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold;">${avgClassicTime.toFixed(2)}ms</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">⌀ Klassisch</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold;">${avgSpeedup.toFixed(1)}x</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">Speedup</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold;">${(successCount/results.length*100).toFixed(1)}%</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">Erfolgsquote</div>
                        </div>
                    </div>
                </div>
                
                <div class="test-results">
                    ${results.slice(0, 15).map(r => `
                        <div class="test-result-item">
                            <span>${r.number}</span>
                            <span style="font-size: 0.9rem;">
                                H: ${r.harmonicTime.toFixed(2)}ms | 
                                K: ${r.classicTime.toFixed(2)}ms | 
                                ${r.speedup.toFixed(1)}x ${r.success ? '✅' : '❌'}
                            </span>
                        </div>
                    `).join('')}
                </div>
            `;
            
            showResult(content);
        }
        
        function showSuccess(number, factors, ratio, harmonicMatch, isExact, deviation, time) {
            const content = `
                <div class="success">
                    <h3>✅ Harmonische Faktoren gefunden!</h3>
                    <div class="factors">${factors[0]} × ${factors[1]} = ${number}</div>
                    <div style="font-size: 0.9rem; opacity: 0.9; margin-top: 5px;">Zeit: ${time.toFixed(2)}ms</div>
                </div>
                
                <div class="harmonic-info">
                    <h4>🎼 Harmonisches Intervall</h4>
                    <p><strong>${harmonicMatch.interval ? harmonicMatch.interval.name : harmonicMatch.name}</strong></p>
                    
                    <div class="ratio-comparison">
                        <div class="ratio-box actual">
                            <div><strong>Tatsächlich</strong></div>
                            <div>${ratio.toFixed(6)}</div>
                        </div>
                        
                        <div style="font-size: 1.5rem;">≈</div>
                        
                        <div class="ratio-box target">
                            <div><strong>Harmonisch</strong></div>
                            <div>${(harmonicMatch.harmonicRatio || harmonicMatch.interval.ratio[0]/harmonicMatch.interval.ratio[1]).toFixed(6)}</div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 15px;">
                        ${isExact ? 
                            '<span style="color: #48BB78; font-weight: bold;">🎯 EXAKTE ÜBEREINSTIMMUNG!</span>' : 
                            `<span style="color: #667eea;">Abweichung: ${deviation.toFixed(3)}%</span>`
                        }
                    </div>
                </div>
            `;
            
            showResult(content);
        }
        
        function showFailure(number, factors, ratio, time) {
            const nearestHarmonics = findNearestHarmonics(ratio);
            
            const content = `
                <div class="failure">
                    <h3>❌ Keine harmonischen Faktoren</h3>
                    <div class="factors">${factors[0]} × ${factors[1]} = ${number}</div>
                    <div style="font-size: 0.9rem; opacity: 0.9; margin-top: 5px;">Zeit: ${time.toFixed(2)}ms</div>
                </div>
                
                <div style="background: #FFF5F5; border: 1px solid #FEB2B2; padding: 15px; border-radius: 8px;">
                    <p><strong>Verhältnis:</strong> ${ratio.toFixed(6)}</p>
                    <p style="margin-top: 10px;">Dieses Verhältnis liegt außerhalb der Toleranz aller harmonischen Intervalle.</p>
                    
                    <h5 style="margin-top: 15px;">🎵 Nächste harmonische Intervalle:</h5>
                    <ul style="margin-left: 20px; margin-top: 5px;">
                        ${nearestHarmonics.map(h => 
                            `<li>${h.name}: ${h.deviation.toFixed(2)}% Abweichung</li>`
                        ).join('')}
                    </ul>
                </div>
            `;
            
            showResult(content);
        }
        
        function showError(message) {
            const content = `
                <div class="failure">
                    <h3>⚠️ Fehler</h3>
                    <p>${message}</p>
                </div>
            `;
            showResult(content);
        }
        
        function findNearestHarmonics(ratio) {
            return harmonicIntervals
                .map(interval => {
                    const harmonicRatio = interval.ratio[0] / interval.ratio[1];
                    const deviation = Math.abs(ratio - harmonicRatio) / harmonicRatio * 100;
                    return { name: interval.name, deviation: deviation };
                })
                .sort((a, b) => a.deviation - b.deviation)
                .slice(0, 3);
        }
        
        function showResult(content) {
            const resultDiv = document.getElementById('resultContent');
            resultDiv.innerHTML = content;
            resultDiv.className = 'result-content active';
        }
        
        function updateStatistics() {
            const statsDiv = document.getElementById('statistics');
            statsDiv.style.display = 'block';
            
            const successRate = statistics.totalFactorizations > 0 ? 
                (statistics.successfulFactorizations / statistics.totalFactorizations * 100).toFixed(1) : 0;
            const exactRate = statistics.totalFactorizations > 0 ? 
                (statistics.exactMatches / statistics.totalFactorizations * 100).toFixed(1) : 0;
            const avgTime = statistics.totalFactorizations > 0 ?
                (statistics.totalTime / statistics.totalFactorizations).toFixed(2) : 0;
            
            const statsContent = document.getElementById('statsContent');
            statsContent.innerHTML = `
                <div class="stat-item">
                    <div class="stat-value">${statistics.totalFactorizations}</div>
                    <div class="stat-label">Gesamt Tests</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${successRate}%</div>
                    <div class="stat-label">Erfolgsquote</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${exactRate}%</div>
                    <div class="stat-label">Exakte Treffer</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${avgTime}ms</div>
                    <div class="stat-label">⌀ Zeit</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${statistics.successfulFactorizations}</div>
                    <div class="stat-label">Harmonische</div>
                </div>
            `;
        }
    </script>
</body>
</html>